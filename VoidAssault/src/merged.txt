
// merged.txt

// reader.py
import os

def merge_files(root_dir, output_file, extensions=None):
    """
    Рекурсивно считывает все файлы из root_dir и записывает в один файл.
    Перед каждым файлом вставляется комментарий с его путём.
    extensions — список расширений, если нужно фильтровать (например ['.h', '.cpp'])
    Если extensions=None — берутся все файлы.
    """
    with open(output_file, "w", encoding="utf-8") as out:
        for folder, _, files in os.walk(root_dir):
            for file in files:
                file_path = os.path.join(folder, file)
                rel_path = os.path.relpath(file_path, root_dir)
                
                # Фильтр по расширениям, если нужно
                if extensions is not None:
                    _, ext = os.path.splitext(file)
                    if ext.lower() not in extensions:
                        continue

                out.write(f"\n// {rel_path}\n")

                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        out.write(f.read())
                except Exception as e:
                    out.write(f"[Ошибка при чтении файла: {e}]\n")


if __name__ == "__main__":
    merge_files(
        root_dir=".", 
        output_file="merged.txt",
        extensions=None 
    )

// client\AudioManager.h
﻿#pragma once
#include "raylib.h"
#include <map>
#include <string>
#include <iostream>

class AudioManager {
    std::map<std::string, Sound> sounds;
    std::map<std::string, Music> musics;
    float masterVolume = 1.0f;

public:
    AudioManager() {
        InitAudioDevice();
    }

    ~AudioManager() {
        for (auto& s : sounds) UnloadSound(s.second);
        for (auto& m : musics) UnloadMusicStream(m.second);
        CloseAudioDevice();
    }

    void LoadSnd(const std::string& key, const std::string& path) {
        Sound s = LoadSound(path.c_str());
        if (s.frameCount > 0) sounds[key] = s;
        else std::cout << "Failed to load sound: " << path << std::endl;
    }

    void LoadMus(const std::string& key, const std::string& path) {
        Music m = LoadMusicStream(path.c_str());
        if (m.frameCount > 0) musics[key] = m;
    }

    void PlaySnd(const std::string& key) {
        if (sounds.count(key)) {
            SetSoundVolume(sounds[key], masterVolume);
            PlaySound(sounds[key]);
        }
    }

    void PlayMus(const std::string& key) {
        if (musics.count(key)) {
            if (!IsMusicStreamPlaying(musics[key])) PlayMusicStream(musics[key]);
            SetMusicVolume(musics[key], masterVolume);
            UpdateMusicStream(musics[key]);
        }
    }

    void Update() {
        for (auto& pair : musics) {
            if (IsMusicStreamPlaying(pair.second)) UpdateMusicStream(pair.second);
        }
    }

    void SetVolume(float vol) { masterVolume = vol; }
    float GetVolume() const { return masterVolume; }
};
// client\CMakeLists.txt
﻿    file(GLOB CLIENT_SOURCES "*.cpp" "scenes/*.cpp")
#file(GLOB_RECURSE Imgui_SFML_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/../imgui-sfml/*.*")
if(WIN32 OR CMAKE_SYSTEM_NAME STREQUAL "Linux" OR LINUX)

    add_executable(GameClient
        ${CLIENT_SOURCES}
    )

    #if(WIN32)
      #  set_target_properties(GameClient PROPERTIES WIN32_EXECUTABLE ON)
    #endif()

    target_link_libraries(GameClient PRIVATE raylib GameEngine GameCommon enet::enet_shared nlohmann_json)

    target_include_directories(GameClient PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
    target_include_directories(GameClient PRIVATE ${ENET_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PRIVATE ${RAYGUI_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
    file(COPY ${CMAKE_SOURCE_DIR}/assets DESTINATION ${GLOBAL_OUTPUT_DIR})

elseif(ANDROID)
    add_library(gameclient SHARED ${CLIENT_SOURCES})

    target_link_libraries(gameclient  PRIVATE android log
        raylib
    GameEngine 
    GameCommon
    enet::enet_shared
    chipmunk_static
    nlohmann_json)
    target_include_directories(GameClient PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
    target_include_directories(GameClient PRIVATE ${ENET_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PRIVATE ${RAYGUI_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})

target_include_directories(gameclient PUBLIC "${CMAKE_SOURCE_DIR}/external")
endif()






// client\GameClient.cpp
﻿#include "GameClient.h"
#include "scenes/MainMenuScene.h" 
#include "scenes/GameplayScene.h"



GameClient::GameClient() {

    InitWindow(screenWidth, screenHeight, "Void Assault");
    SetTargetFPS(60);
    SetWindowState(FLAG_WINDOW_RESIZABLE);

    if (enet_initialize() != 0) {
        TraceLog(LOG_ERROR, "Failed to init ENet");
    }

    if (!network.Init()) {
        TraceLog(LOG_ERROR, "Failed to create ENet client host");
    }
    AppConfig::LoadResources();
    GuiSetStyle(DEFAULT, TEXT_SIZE, 20);
}

GameClient::~GameClient() {
    StopHost();
    if (currentScene) currentScene->Exit();
    network.Shutdown();
    enet_deinitialize();
    CloseWindow();
}

void GameClient::ChangeScene(std::shared_ptr<Scene> newScene) {
    nextScene = newScene;
}

void GameClient::StartHost() {
    if (!localServer) {
        localServer = std::make_unique<ServerHost>();
        if (localServer->Start(7777)) {
            TraceLog(LOG_INFO, "Local Server Started!");
        }
        else {
            TraceLog(LOG_ERROR, "Failed to start local server!");
        }
    }
}
void GameClient::StartHost(int port) {
    if (!localServer) {
        localServer = std::make_unique<ServerHost>();
        if (localServer->Start(port)) {
            TraceLog(LOG_INFO, "Local Server Started!");
        }
        else {
            TraceLog(LOG_ERROR, "Failed to start local server!");
        }
    }
}
void GameClient::StopHost() {
    if (localServer) {
        localServer->Stop();
        localServer.reset();
        TraceLog(LOG_INFO, "Local Server Stopped.");
    }
}

void GameClient::Run() {
    ChangeScene(std::make_shared<MainMenuScene>(this));

    while (!WindowShouldClose()) {
        if (nextScene) {
            if (currentScene) currentScene->Exit();
            currentScene = nextScene;
            currentScene->Enter();
            nextScene = nullptr;
        }

        float dt = GetFrameTime();

        ENetEvent event;
        while (enet_host_service(network.clientHost, &event, 0) > 0) {
            switch (event.type) {
            case ENET_EVENT_TYPE_CONNECT:
                network.isConnected = true;
                TraceLog(LOG_INFO, "Connected to server!");
                break;
            case ENET_EVENT_TYPE_DISCONNECT:
                network.isConnected = false;
                TraceLog(LOG_INFO, "Disconnected from server.");
                break;
            case ENET_EVENT_TYPE_RECEIVE:
                if (currentScene) {
                    currentScene->OnPacketReceived(event.packet->data, event.packet->dataLength);
                }
                enet_packet_destroy(event.packet);
                break;
            }
        }

        if (currentScene) {
            currentScene->Update(dt);

            BeginDrawing();
            ClearBackground(RAYWHITE);

            currentScene->Draw();
            currentScene->DrawGUI();

            EndDrawing();
        }
    }
}
// client\GameClient.h
﻿#pragma once
#include "raygui_wrapper.h"
#include "NetworkManager.h"
#include "../engine/Scenes/Scene.h"
#include "../engine/ServerHost.h"
#include "AudioManager.h"
#include <memory>

class GameClient {
public:
    int screenWidth = 1280;
    int screenHeight = 720;

    NetworkManager network;
    std::unique_ptr<ServerHost> localServer;
    AudioManager audio;

    std::shared_ptr<Scene> currentScene;
    std::shared_ptr<Scene> nextScene;

    GameClient();
    ~GameClient();

    void Run();
    void ChangeScene(std::shared_ptr<Scene> newScene);
    void ReturnToMenu();

    void StartHost();
    void StartHost(int port);
    void StopHost();

    int GetWidth() const { return GetScreenWidth(); }
    int GetHeight() const { return GetScreenHeight(); }
};
// client\main_client.cpp
﻿#define RAYGUI_IMPLEMENTATION
#include "GameClient.h"
#include "engine/Utils/ConfigManager.h"

int main() {
    ConfigManager::Initialize("./");
    GameClient game;


    SetTargetFPS(ConfigManager::GetClient().targetFPS);
    if (ConfigManager::GetClient().fullscreen) {
        ToggleFullscreen();
    }
    game.Run();
    return 0;
}
// client\NetworkManager.h
﻿#pragma once
#include <enet.h>
#include <string>
#include <iostream>
#include "../common/NetworkPackets.h"

class NetworkManager {
public:
    ENetHost* clientHost = nullptr;
    ENetPeer* serverPeer = nullptr;
    bool isConnected = false;

    bool Init() {
        if (enet_initialize() != 0) return false;
        clientHost = enet_host_create(NULL, 1, 2, 0, 0);
        return (clientHost != nullptr);
    }

    void Connect(const std::string& ip, int port) {
        ENetAddress address;
        enet_address_set_host(&address, ip.c_str());
        address.port = port;
        serverPeer = enet_host_connect(clientHost, &address, 2, 0);
    }

    void Disconnect() {
        if (serverPeer) {
            enet_peer_disconnect(serverPeer, 0);
            enet_host_flush(clientHost);
            serverPeer = nullptr;
        }
        isConnected = false;
    }

    void SendInput(const PlayerInputPacket& input) {
        if (!isConnected || !serverPeer) return;
        ENetPacket* packet = enet_packet_create(&input, sizeof(PlayerInputPacket), ENET_PACKET_FLAG_UNSEQUENCED);
        enet_peer_send(serverPeer, 0, packet);
    }

    void Shutdown() {
        if (clientHost) enet_host_destroy(clientHost);
        enet_deinitialize();
    }
};
// client\ParticleSystem.h
﻿#pragma once
#include "raylib.h"
#include <vector>
#include <algorithm>

struct Particle {
    Vector2 position;
    Vector2 velocity;
    float life;      // 1.0 -> 0.0
    float decayRate; // Скорость исчезновения
    float size;
    Color color;
};

class ParticleSystem {
    std::vector<Particle> particles;

public:
    void Spawn(Vector2 pos, Vector2 vel, Color col, float size, float lifeTime) {
        Particle p;
        p.position = pos;
        p.velocity = vel;
        p.color = col;
        p.size = size;
        p.life = 1.0f;
        p.decayRate = 1.0f / lifeTime;
        particles.push_back(p);
    }

    void SpawnExplosion(Vector2 pos, int count, Color col) {
        for (int i = 0; i < count; i++) {
            float angle = (float)GetRandomValue(0, 360) * DEG2RAD;
            float speed = (float)GetRandomValue(50, 200) / 10.0f;
            Vector2 vel = { cosf(angle) * speed, sinf(angle) * speed };
            Spawn(pos, vel, col, (float)GetRandomValue(3, 8), 0.5f);
        }
    }

    void Update(float dt) {
        for (auto& p : particles) {
            p.position.x += p.velocity.x * dt * 60.0f;
            p.position.y += p.velocity.y * dt * 60.0f;
            p.life -= p.decayRate * dt;
            p.size *= 0.95f;
        }

        particles.erase(
            std::remove_if(particles.begin(), particles.end(),
                [](const Particle& p) { return p.life <= 0; }),
            particles.end());
    }

    void Draw() {
        for (const auto& p : particles) {
            Color c = p.color;
            c.a = (unsigned char)(p.life * 255);
            DrawCircleV(p.position, p.size, c);
        }
    }
};
// client\raygui_wrapper.h
﻿// raygui_wrapper.h
#pragma once

#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "raylib.h"
#include "raygui.h"
// client\ResourceManager.h
﻿#pragma once
#include "raylib.h"
#include <string>

class ResourceManager {
public:
    Font mainFont;

    static ResourceManager& Get() {
        static ResourceManager instance;
        return instance;
    }

    void Load() {
        // Загружаем шрифт. Если файла нет, Raylib загрузит дефолтный, но с фильтрацией
        // В реальном проекте положи файл .ttf в папку assets
        // mainFont = LoadFontEx("assets/font.ttf", 64, 0, 0);

        // Пока используем дефолтный, но ставим фильтр для гладкости
        mainFont = GetFontDefault();
        SetTextureFilter(mainFont.texture, TEXTURE_FILTER_BILINEAR);
    }

    void Unload() {
        // UnloadFont(mainFont);
    }

    static void DrawTextCentered(const char* text, int cx, int cy, int fontSize, Color color) {
        int width = MeasureText(text, fontSize);
        DrawText(text, cx - width / 2, cy - fontSize / 2, fontSize, color);
    }
};
// client\Theme.h
#pragma once
#include "raylib.h"

namespace Theme {
    static const Color BG_COLOR = { 205, 205, 205, 255 };
    static const Color GRID_COLOR = { 170, 170, 170, 255 };
    static const Color BORDER_COLOR = { 85, 85, 85, 255 };

    static const Color COLOR_BLUE = { 0, 178, 225, 255 };
    static const Color COLOR_RED = { 241, 78, 84, 255 };
    static const Color COLOR_BARREL = { 153, 153, 153, 255 };

    static const float OUTLINE_THICKNESS = 3.0f;
    static const float BARREL_WIDTH_RATIO = 0.45f;
}
// client\VirtualJoystick.cpp
﻿#include "VirtualJoystick.h"
#include "raymath.h"

#ifndef MAX_TOUCH_POINTS
#define MAX_TOUCH_POINTS 10
#endif

VirtualJoystick::VirtualJoystick() {

}

VirtualJoystick::VirtualJoystick(Vector2 pos, float rStick, float rBody) {
    position = pos;
    stickPosition = pos;
    radiusStick = rStick;
    radiusBody = rBody;
    radiusInteraction = rBody * 1.5f;
}

void VirtualJoystick::SetPosition(Vector2 pos) {
    position = pos;
    if (!dragging) {
        stickPosition = pos;
    }
}

void VirtualJoystick::SetPosition(float x, float y) {
    SetPosition({ x, y });
}

bool VirtualJoystick::IsTouchInBounds(Vector2 touchPos) const {
    return Vector2Distance(touchPos, position) <= radiusInteraction;
}

void VirtualJoystick::Update() {
    bool inputFound = false;
    Vector2 inputPos = { 0, 0 };


    if (dragging) {
        if (touchId == -2) {
            if (IsMouseButtonDown(MOUSE_LEFT_BUTTON)) {
                inputPos = GetMousePosition();
                inputFound = true;
            }
        }
        else {
            if (touchId < GetTouchPointCount()) {
                inputPos = GetTouchPosition(touchId);
                inputFound = true;
            }
        }

        if (!inputFound) {
            Reset();
            return;
        }
    }
    else {
        int count = GetTouchPointCount();
        for (int i = 0; i < count && i < MAX_TOUCH_POINTS; i++) {
            Vector2 touchPos = GetTouchPosition(i);
            if (IsTouchInBounds(touchPos)) {
                dragging = true;
                touchId = i;
                inputPos = touchPos;
                inputFound = true;
                break;
            }
        }

        if (!inputFound && IsMouseButtonDown(MOUSE_LEFT_BUTTON)) {
            Vector2 mousePos = GetMousePosition();
            if (IsTouchInBounds(mousePos)) {
                dragging = true;
                touchId = -2;
                inputPos = mousePos;
                inputFound = true;
            }
        }
    }

    if (dragging) {
        Vector2 direction = Vector2Subtract(inputPos, position);
        float distance = Vector2Length(direction);

        if (distance > radiusBody) {
            direction = Vector2Scale(Vector2Normalize(direction), radiusBody);
            stickPosition = Vector2Add(position, direction);
        }
        else {
            stickPosition = inputPos;
        }

        if (radiusBody > 0) {
            axis = Vector2Scale(direction, 1.0f / radiusBody);
        }

        if (Vector2Length(axis) > 1.0f) {
            axis = Vector2Normalize(axis);
        }
    }
    else {
        Reset();
    }
}

void VirtualJoystick::Reset() {
    stickPosition = position;
    dragging = false;
    touchId = -1;
    axis = { 0, 0 };
}

void VirtualJoystick::Draw() {

    DrawCircleV(position, radiusBody, colorBody);
    DrawRing(position, radiusBody, radiusBody + 2, 0, 360, 24, Fade(colorBody, 0.8f));

    DrawCircleV(stickPosition, radiusStick, colorStick);

    if (dragging) {
        DrawCircleV(stickPosition, radiusStick * 0.8f, Fade(WHITE, 0.3f));
    }
}
// client\VirtualJoystick.h
﻿#pragma once
#include <raylib.h>

class VirtualJoystick {
public:
    VirtualJoystick();
    VirtualJoystick(Vector2 pos, float radiusStick, float radiusBody);

    void Update();
    void Draw();
    void Reset();


    Vector2 GetAxis() const { return axis; }

    const Vector2& GetPosition() const { return position; }
    void SetPosition(Vector2 pos);
    void SetPosition(float x, float y);

    bool IsDragging() const { return dragging; }


    void SetColors(Color body, Color stick) {
        colorBody = body;
        colorStick = stick;
    }

    void SetRadii(float body, float stick, float interaction) {
        radiusBody = body;
        radiusStick = stick;
        radiusInteraction = interaction;
    }

private:
    int touchId = -1;
    bool dragging = false;

    Vector2 position = { 0, 0 };
    Vector2 stickPosition = { 0, 0 };
    Vector2 axis = { 0, 0 };


    float radiusStick = 20.0f;
    float radiusBody = 50.0f;
    float radiusInteraction = 60.0f;


    Color colorStick = { 200, 200, 200, 255 };
    Color colorBody = { 50, 50, 50, 150 };


    bool IsTouchInBounds(Vector2 touchPos) const;
};
// client\scenes\GameplayScene.cpp
﻿#include "GameplayScene.h"
#include "MainMenuScene.h"
#include "../GameClient.h"
GameplayScene::GameplayScene(GameClient* g) : Scene(g) {}

void GameplayScene::Enter() {
    camera.zoom = 1.0f;
    camera.offset = { (float)game->GetWidth() / 2, (float)game->GetHeight() / 2 };
}

void GameplayScene::Exit() {
    game->network.Disconnect();
    game->StopHost();
    worldEntities.clear();
}

void GameplayScene::OnPacketReceived(const uint8_t* data, size_t size) {
    PacketHeader* header = (PacketHeader*)data;

    if (header->type == PacketType::server_INIT) {
        InitPacket* init = (InitPacket*)data;
        myPlayerId = init->yourPlayerId;
    }
    else if (header->type == PacketType::server_SNAPSHOT) {
        WorldSnapshotPacket* snap = (WorldSnapshotPacket*)data;
        EntityState* states = (EntityState*)(data + sizeof(WorldSnapshotPacket));

        std::vector<uint32_t> receivedIds;
        for (uint32_t i = 0; i < snap->entityCount; i++) {
            receivedIds.push_back(states[i].id);
            worldEntities[states[i].id].PushState(states[i]);
        }
        for (auto it = worldEntities.begin(); it != worldEntities.end();) {
            bool found = false;
            for (uint32_t id : receivedIds) if (id == it->first) found = true;
            if (!found) it = worldEntities.erase(it);
            else ++it;
        }
    }
}

void GameplayScene::Update(float dt) {

    leftStick->Update();
    rightStick->Update();

    PlayerInputPacket pkt;
    pkt.type = PacketType::client_INPUT;


    Vector2 moveDir = leftStick->GetAxis();
    pkt.movement = moveDir;


    if (IsKeyDown(KEY_W)) pkt.movement.y -= 1.0f;
    if (IsKeyDown(KEY_S)) pkt.movement.y += 1.0f;
    if (IsKeyDown(KEY_A)) pkt.movement.x -= 1.0f;
    if (IsKeyDown(KEY_D)) pkt.movement.x += 1.0f;

    if (Vector2Length(pkt.movement) > 1.0f) {
        pkt.movement = Vector2Normalize(pkt.movement);
    }

    Vector2 aimDir = rightStick->GetAxis();

    if (Vector2Length(aimDir) > 0.2f) {
        pkt.isShooting = true;

        if (worldEntities.count(myPlayerId)) {
            Vector2 playerPos = worldEntities[myPlayerId].renderPos;
            pkt.aimTarget = Vector2Add(playerPos, Vector2Scale(aimDir, 200.0f));
        }
        else {
            pkt.aimTarget = Vector2Scale(aimDir, 200.0f);
        }
    }
    else {
        pkt.aimTarget = GetScreenToWorld2D(GetMousePosition(), camera);
        pkt.isShooting = IsMouseButtonDown(MOUSE_LEFT_BUTTON);
    }

    game->network.SendInput(pkt);

    for (auto& [id, ent] : worldEntities) {
        ent.UpdateInterpolation();
    }

    if (worldEntities.count(myPlayerId)) {
        Vector2 target = worldEntities[myPlayerId].renderPos;
        camera.target = Vector2Lerp(camera.target, target, 0.1f);
    }
}

void GameplayScene::Draw() {
    BeginMode2D(camera);
    DrawGrid(100, 50);
    DrawRectangleLines(0, 0, 2000, 2000, GRAY);

    for (auto& [id, ent] : worldEntities) {
        EntityState& st = ent.current;

        if (st.type == EntityType::PLAYER) {
            DrawCircleV(ent.renderPos, st.radius, st.color);
            Vector2 barrelEnd = {
                ent.renderPos.x + cosf(ent.renderRot * DEG2RAD) * 40,
                ent.renderPos.y + sinf(ent.renderRot * DEG2RAD) * 40
            };
            DrawLineEx(ent.renderPos, barrelEnd, 15, DARKGRAY);

            float hpPct = st.health / st.maxHealth;
            DrawRectangle((int)ent.renderPos.x - 20, (int)ent.renderPos.y - 40, 40, 5, RED);
            DrawRectangle((int)ent.renderPos.x - 20, (int)ent.renderPos.y - 40, (int)(40 * hpPct), 5, GREEN);
        }
        else if (st.type == EntityType::BULLET) {
            DrawCircleV(ent.renderPos, st.radius, RED);
        }
    }
    EndMode2D();
}

void GameplayScene::DrawGUI() {
    DrawFPS(10, 10);
    if (!game->network.isConnected) {
        DrawText("Connecting to server...", game->GetWidth() / 2 - 100, 20, 20, RED);
    }
    leftStick->Draw();
    rightStick->Draw();
    if (GuiButton(Rectangle{ (float)game->GetWidth() - 100, 10, 90, 30 }, "DISCONNECT")) {
        game->ChangeScene(std::make_shared<MainMenuScene>(game));
    }
}
// client\scenes\GameplayScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"
#include "../../common/NetworkPackets.h"
#include "../ParticleSystem.h"
#include "../VirtualJoystick.h"
#include "raymath.h"
#include <map>
#include <vector>
#include <memory>
class GameClient;
struct InterpolatedEntity {
    EntityState current;
    EntityState previous;
    float lastUpdateTime;
    Vector2 renderPos;
    float renderRot;


    InterpolatedEntity() : lastUpdateTime(0), renderRot(0) {}

    void PushState(const EntityState& newState) {
        previous = current;
        current = newState;
        lastUpdateTime = (float)GetTime();
        if (previous.id == 0) previous = current;
    }

    void UpdateInterpolation() {
        double serverTickRate = 0.05;
        double t = (GetTime() - lastUpdateTime) / serverTickRate;
        if (t > 1.0) t = 1.0;
        if (t < 0.0) t = 0.0;

        renderPos = Vector2Lerp(previous.position, current.position, (float)t);
        renderRot = Lerp(previous.rotation, current.rotation, (float)t);
    }
};

class GameplayScene : public Scene {
    Camera2D camera = { 0 };
    std::map<uint32_t, InterpolatedEntity> worldEntities;
    uint32_t myPlayerId = 0;
    std::unique_ptr<VirtualJoystick> leftStick;
    std::unique_ptr<VirtualJoystick> rightStick;


public:
    GameplayScene(GameClient* g);
    virtual ~GameplayScene() = default;

    void Enter() override;
    void Exit() override;
    void OnPacketReceived(const uint8_t* data, size_t size) override;
    void Update(float dt) override;
    void Draw() override;
    void DrawGUI() override;
};
// client\scenes\MainMenuScene.cpp
﻿#include "MainMenuScene.h"
#include "raygui.h"
#include "GameClient.h"
#include "engine/Utils/ConfigManager.h"
enum MenuState { MAIN, MULTIPLAYER, SETTINGS };

enum MultiTab { ONLINE_LIST, DIRECT_CONNECT };

MenuState currentMenuState = MAIN;
MultiTab currentMultiTab = DIRECT_CONNECT;


char ipBuffer[64] = "127.0.0.1";
char portBuffer[8] = "7777";
char nameBuffer[32] = "Player";
bool isEditingIp = false;
bool isEditingPort = false;
bool isEditingName = false;


MainMenuScene::MainMenuScene(GameClient* g) : Scene(g) {}

void MainMenuScene::Draw() {
    ClearBackground(GetColor(0x181818FF));

    int w = GetScreenWidth();
    int h = GetScreenHeight();


    const char* title = "VOID ASSAULT";
    DrawText(title, w / 2 - MeasureText(title, 60) / 2, 50, 60, WHITE);

    if (currentMenuState == MAIN) {
        float btnW = 300;
        float btnH = 50;
        float startY = 200;
        float spacing = 70;

        if (GuiButton({ (float)w / 2 - btnW / 2, startY, btnW, btnH }, AppConfig::GetText("play_single"))) {
            ServerConfig& sCfg = ConfigManager::GetServer();
            game->StartHost(sCfg.port);
            game->StartHost();
        }

        // Кнопка Сетевая игра
        if (GuiButton({ (float)w / 2 - btnW / 2, startY + spacing, btnW, btnH }, AppConfig::GetText("multiplayer"))) {
            currentMenuState = MULTIPLAYER;
            // Копируем текущие настройки в буферы для редактирования
            strcpy(ipBuffer, AppConfig::settings.serverIp.c_str());
            sprintf(portBuffer, "%d", AppConfig::settings.serverPort);
            strcpy(nameBuffer, AppConfig::settings.playerName.c_str());
        }

        // Кнопка Настройки
        if (GuiButton({ (float)w / 2 - btnW / 2, startY + spacing * 2, btnW, btnH }, AppConfig::GetText("settings"))) {
            currentMenuState = SETTINGS;
        }

        // Выход
        if (GuiButton({ (float)w / 2 - btnW / 2, startY + spacing * 3, btnW, btnH }, "EXIT")) {
            CloseWindow();
        }
    }
    else if (currentMenuState == MULTIPLAYER) {
        // --- МЕНЮ СЕТЕВОЙ ИГРЫ ---

        // Вкладки
        float tabW = 200;
        if (GuiButton({ (float)w / 2 - tabW - 10, 150, tabW, 40 }, AppConfig::GetText("tab_online"))) {
            currentMultiTab = ONLINE_LIST;
        }
        if (GuiButton({ (float)w / 2 + 10, 150, tabW, 40 }, AppConfig::GetText("tab_direct"))) {
            currentMultiTab = DIRECT_CONNECT;
        }

        // Поле имени игрока (общее)
        GuiLabel({ (float)w / 2 - 150, 210, 300, 20 }, AppConfig::GetText("enter_name"));
        if (GuiTextBox({ (float)w / 2 - 150, 230, 300, 30 }, nameBuffer, 32, isEditingName)) {
            isEditingName = !isEditingName;
            AppConfig::settings.playerName = std::string(nameBuffer);
        }

        if (currentMultiTab == DIRECT_CONNECT) {
            float startY = 300;

            // Поле IP
            GuiLabel({ (float)w / 2 - 150, startY, 300, 20 }, AppConfig::GetText("ip_addr"));
            if (GuiTextBox({ (float)w / 2 - 150, startY + 20, 200, 30 }, ipBuffer, 64, isEditingIp)) {
                isEditingIp = !isEditingIp;
            }

            // Поле Порт
            GuiLabel({ (float)w / 2 + 60, startY, 90, 20 }, AppConfig::GetText("port"));
            if (GuiTextBox({ (float)w / 2 + 60, startY + 20, 90, 30 }, portBuffer, 8, isEditingPort)) {
                isEditingPort = !isEditingPort;
            }

            // Кнопка Подключиться
            if (GuiButton({ (float)w / 2 - 150, startY + 80, 300, 40 }, AppConfig::GetText("connect"))) {
                // Сохраняем введенные данные
                AppConfig::settings.serverIp = std::string(ipBuffer);
                AppConfig::settings.serverPort = atoi(portBuffer);

                // Логика подключения
                game->network.Connect(AppConfig::settings.serverIp, AppConfig::settings.serverPort);
                // Переход в лобби/игру (обрабатывается в коллбэке сети, но пока так)
                // game->ChangeScene(std::make_shared<LobbyScene>(game)); 
            }

            // Кнопка Создать Сервер (LAN)
            if (GuiButton({ (float)w / 2 - 150, startY + 140, 300, 40 }, AppConfig::GetText("host"))) {
                AppConfig::settings.serverPort = atoi(portBuffer);
                game->StartHost();//AppConfig::settings.serverPort
            }
        }
        else if (currentMultiTab == ONLINE_LIST) {
            // Имитация списка серверов
            GuiGroupBox({ (float)w / 2 - 200, 300, 400, 200 }, "Server Browser (Mockup)");
            if (GuiButton({ (float)w / 2 - 180, 320, 360, 30 }, "Official Server EU [Ping: 45]")) {
                game->network.Connect("185.x.x.x", 7777);
            }
            if (GuiButton({ (float)w / 2 - 180, 360, 360, 30 }, "Local Test [Ping: 1]")) {
                game->network.Connect("127.0.0.1", 7777);
            }
        }

        // Кнопка Назад
        if (GuiButton({ 20, 20, 100, 40 }, AppConfig::GetText("back"))) {
            currentMenuState = MAIN;
        }
    }
    else if (currentMenuState == SETTINGS) {
        // Смена языка
        if (GuiButton({ (float)w / 2 - 100, 300, 200, 40 }, "Language: EN/RU")) {
            if (AppConfig::settings.language == Language::RU) AppConfig::settings.language = Language::EN;
            else AppConfig::settings.language = Language::RU;
        }

        if (GuiButton({ 20, 20, 100, 40 }, AppConfig::GetText("back"))) {
            currentMenuState = MAIN;
        }
    }
}
void MainMenuScene::DrawGUI() {
}
// client\scenes\MainMenuScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"

class GameClient;
class MainMenuScene : public Scene {
    char ipBuffer[64] = "127.0.0.1";
    bool ipEditMode = false;
public:
    MainMenuScene(GameClient* g);
    virtual ~MainMenuScene() = default;

    void Enter() override {}
    void Exit() override {}
    void Update(float dt) override {}
    void Draw() override;
    void DrawGUI() override;
};
// client\scenes\SettingsScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"
#include "../../client/GameClient.h"
#include "../Theme.h"

class SettingsScene : public Scene {
public:
    SettingsScene(GameClient* g) : Scene(g) {}

    void Enter() override {}
    void Exit() override {}
    void Update(float dt) override {} // Логика в DrawGUI

    void Draw() override {
        ClearBackground(Theme::BG_COLOR);
        ResourceManager::DrawTextCentered("SETTINGS", game->GetWidth() / 2, 100, 60, Theme::COLOR_BLUE);
    }

    void DrawGUI() override {
        float cx = game->GetWidth() / 2.0f - 150;
        float cy = 200;

        // Управление громкостью
        GuiLabel(Rectangle{ cx, cy - 30, 300, 20 }, "Master Volume");
        float vol = game->audio.GetVolume();
        if (GuiSlider(Rectangle{ cx, cy, 300, 30 }, "0", "1", &vol, 0.0f, 1.0f)) {
            game->audio.SetVolume(vol);
        }
        cy += 80;

        // Полноэкранный режим (для ПК)
        static bool fullscreen = IsWindowFullscreen();
        if (GuiCheckBox(Rectangle{ cx, cy, 30, 30 }, "Fullscreen", &fullscreen)) {
            ToggleFullscreen();
        }
        cy += 80;

        // Кнопка назад
        if (GuiButton(Rectangle{ cx, game->GetHeight() - 100.0f, 300, 50 }, "BACK")) {
            // Возвращаемся в главное меню (нужен forward declaration или include)
            // Для простоты в GameClient сделаем метод ReturnToMenu
            game->ReturnToMenu();
        }
    }
};
// common\CMakeLists.txt
﻿add_library(GameCommon SHARED
    NetworkPackets.h Common.cpp
)

target_link_libraries(GameCommon PUBLIC enet::enet_shared raylib)
target_include_directories(GameCommon PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameCommon PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
// common\Common.cpp

// common\NetworkPackets.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif
#include <cstdint>
#include "raylib.h"

enum class PacketType : uint8_t {
    client_CONNECT,
    client_INPUT,
    server_INIT,
    server_SNAPSHOT,
    server_EVENT
};

struct PacketHeader {
    PacketType type;
};

struct PlayerInputPacket : PacketHeader {
    Vector2 movement;
    Vector2 aimTarget;
    bool isShooting;
};

enum class EntityType : uint8_t { PLAYER, BULLET, ENEMY };

struct EntityState {
    uint32_t id;
    Vector2 position;
    float rotation;
    float health;
    float maxHealth;
    EntityType type;
    float radius;
    Color color;
};

struct WorldSnapshotPacket : PacketHeader {
    uint32_t entityCount;
};


struct InitPacket : PacketHeader {
    uint32_t yourPlayerId;
};


enum class GameEvent : uint8_t {
    BULLET_HIT,
    PLAYER_DEATH
};

struct EventPacket : PacketHeader {
    GameEvent eventId;
    Vector2 position;
};
// engine\CMakeLists.txt
﻿#Engine module CMakeLists.txt
add_library(GameEngine SHARED
    Utils/ConfigManager.h
    Utils/ConfigManager.cpp
    ECS/GameObject.h
    ECS/Player.h
    ECS/Bullet.h
    Scenes/GameScene.h
    ServerHost.h
 "ServerHost.h"
 ServerHost.cpp
 "Utils/ConfigManager.h")

target_include_directories(GameEngine PUBLIC ${CHIPMUNK2D_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameEngine PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})

target_link_libraries(GameEngine PUBLIC chipmunk_static GameCommon enet::enet_shared raylib nlohmann_json)
target_include_directories(GameEngine PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

if(ANDROID)
    target_link_libraries(GameEngine PRIVATE log)
endif()
// engine\PhysicsUtils.h
﻿#pragma once
#include "raylib_compatibility.h"
#include "chipmunk/chipmunk.h"


// Конвертация Raylib Vector2 -> Chipmunk cpVect
inline cpVect ToCp(Vector2 v) {
    return cpv(v.x, v.y);
}

// Конвертация Chipmunk cpVect -> Raylib Vector2
inline Vector2 ToRay(cpVect v) {
    return Vector2{ (float)v.x, (float)v.y };
}
// engine\raylib_compatibility.h
﻿// raylib_compatibility.h
#pragma once

#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "raylib.h"
// engine\ServerHost.cpp
﻿#define _CRT_SECURE_NO_WARNINGS
#include "ServerHost.h"
#include <iostream>

ServerHost::ServerHost() : running(false) {}

ServerHost::~ServerHost() {
    Stop();
}

bool ServerHost::Start(int port) {
    if (running) return false;

    ENetAddress address;
    address.host = ENET_HOST_ANY;
    address.port = port;

    server = enet_host_create(&address, 32, 2, 0, 0);
    if (!server) {
        std::cerr << "An error occurred while trying to create an ENet server host.\n";
        return false;
    }

    running = true;
    // Запускаем цикл в отдельном потоке
    serverThread = std::thread(&ServerHost::ServerLoop, this);
    return true;
}

void ServerHost::Stop() {
    running = false;
    if (serverThread.joinable()) {
        serverThread.join();
    }
    if (server) {
        enet_host_destroy(server);
        server = nullptr;
    }
}

void ServerHost::ServerLoop() {
    std::cout << "Server started loop.\n";
    const double dt = 1.0 / 60.0;
    double accumulator = 0.0;
    double lastTime = GetTime();

    while (running) {
        double currentTime = GetTime();
        double frameTime = currentTime - lastTime;
        lastTime = currentTime;
        accumulator += frameTime;

        ENetEvent event;
        while (enet_host_service(server, &event, 0) > 0) {
            switch (event.type) {
            case ENET_EVENT_TYPE_CONNECT: {
                std::cout << "A new client connected from...\n";// << event.peer->address.host.u.Word << ":" << event.peer->address.port << ".\n";

                auto player = gameScene.CreatePlayer();

                event.peer->data = (void*)(uintptr_t)player->id;

                InitPacket initPkt;
                initPkt.type = PacketType::server_INIT;
                initPkt.yourPlayerId = player->id;

                ENetPacket* packet = enet_packet_create(&initPkt, sizeof(InitPacket), ENET_PACKET_FLAG_RELIABLE);
                enet_peer_send(event.peer, 0, packet);
                break;
            }
            case ENET_EVENT_TYPE_RECEIVE: {
                PacketHeader* header = (PacketHeader*)event.packet->data;
                if (header->type == PacketType::client_INPUT) {
                    PlayerInputPacket* input = (PlayerInputPacket*)event.packet->data;
                    uint32_t playerId = (uint32_t)(uintptr_t)event.peer->data;

                    if (gameScene.objects.count(playerId)) {
                        auto p = std::dynamic_pointer_cast<Player>(gameScene.objects[playerId]);
                        if (p) {
                            p->ApplyInput(input->movement);
                            p->aimTarget = input->aimTarget;
                            p->wantsToShoot = input->isShooting;
                        }
                    }
                }
                enet_packet_destroy(event.packet);
                break;
            }
            case ENET_EVENT_TYPE_DISCONNECT:
                uint32_t playerId = (uint32_t)(uintptr_t)event.peer->data;
                gameScene.objects.erase(playerId);
                std::cout << "Client disconnected.\n";
            }
        }

        // Физический апдейт
        while (accumulator >= dt) {
            gameScene.Update((float)dt);
            accumulator -= dt;
        }

        // Рассылка снапшота (раз в 2 тика, например, или каждый тик)
        static double snapshotTimer = 0;
        snapshotTimer += frameTime;
        if (snapshotTimer > 0.05) { // 20 раз в секунду
            snapshotTimer = 0;
            auto data = gameScene.SerializeSnapshot();

            ENetPacket* packet = enet_packet_create(data.data(), data.size(), ENET_PACKET_FLAG_UNSEQUENCED);
            enet_host_broadcast(server, 1, packet);
        }

        // Небольшой sleep, чтобы не грузить CPU на 100% в пустом цикле
        WaitTime(0.001);
    }
}
// engine\ServerHost.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include <enet.h>

#include <thread>
#include <atomic>
#include "Scenes/GameScene.h"

class ServerHost {
    ENetHost* server = nullptr;
    GameScene gameScene;
    std::atomic<bool> running;
    std::thread serverThread;

public:
    ServerHost();
    ~ServerHost();

    bool Start(int port);
    void Stop();

    void ServerLoop();
};
// engine\ECS\Bullet.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"

class Bullet : public GameObject {
public:
    uint32_t ownerId;
    float lifeTime = 2.0f;

    Bullet(uint32_t id, Vector2 pos, Vector2 dir, uint32_t owner, cpSpace* space)
        : GameObject(id, EntityType::BULLET), ownerId(owner)
    {
        spaceRef = space;
        color = BLACK;
        float moveSpeed = 600.0f;

        cpFloat radius = 5.0;
        cpFloat mass = 1.0;
        // Пуля - кинематический или легкий динамический объект
        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);

        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(pos));

        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetElasticity(shape, 0.8);
        cpShapeSetCollisionType(shape, COLLISION_BULLET);
        cpShapeSetUserData(shape, (void*)this);

        // Задаем скорость
        Vector2 normDir = Vector2Normalize(dir);
        cpBodySetVelocity(body, cpv(normDir.x * moveSpeed, normDir.y * moveSpeed));
    }

    void Update(float dt) override {
        lifeTime -= dt;
        if (lifeTime <= 0) destroyFlag = true;
    }
};
// engine\ECS\GameObject.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif
#include "raylib.h"
#include "chipmunk/chipmunk.h"
#include "../../common/NetworkPackets.h"

// Определяем типы коллизий для фильтрации (понадобится в будущем)
enum CollisionType {
    COLLISION_PLAYER = 1,
    COLLISION_BULLET = 2,
    COLLISION_WALL = 3
};

class GameObject {
public:
    uint32_t id;
    EntityType type;

    // Ссылки на физические объекты
    cpBody* body = nullptr;
    cpShape* shape = nullptr;
    cpSpace* spaceRef = nullptr; // Ссылка на мир для очистки

    bool destroyFlag = false;
    Color color = RED;
    float rotation = 0.0f;
    float health = 100.0f;
    float maxHealth = 100.0f;

    GameObject(uint32_t _id, EntityType _type) : id(_id), type(_type) {}

    virtual ~GameObject() {
        if (spaceRef) {
            if (shape) {
                cpSpaceRemoveShape(spaceRef, shape);
                cpShapeFree(shape);
            }
            if (body) {
                cpSpaceRemoveBody(spaceRef, body);
                cpBodyFree(body);
            }
        }
    }

    virtual void Update(float dt) = 0;
};
// engine\ECS\Player.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"

class Player : public GameObject {
public:
    float speed = 200.0f; // Сила/Скорость движения
    float shootCooldown = 0.0f;
    const float FIRE_RATE = 0.2f;

    bool wantsToShoot = false;
    Vector2 aimTarget = { 0,0 };
    bool spawnBulletSignal = false;
    Vector2 bulletDir = { 0,0 };

    Player(uint32_t id, Vector2 startPos, cpSpace* space) : GameObject(id, EntityType::PLAYER) {
        spaceRef = space;
        color = BLUE;

        // 1. Создаем тело (масса 10, инерция для круга)
        cpFloat radius = 20.0;
        cpFloat mass = 10.0;
        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);

        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(startPos));

        // Отключаем вращение от коллизий (бесконечная инерция)
        cpBodySetMoment(body, INFINITY);

        // 2. Создаем форму (коллизию)
        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetFriction(shape, 0.7);
        cpShapeSetElasticity(shape, 0.1); // Упругость
        cpShapeSetCollisionType(shape, COLLISION_PLAYER);

        // Pointer на самого себя для логики коллизий
        cpShapeSetUserData(shape, (void*)this);
    }

    void Update(float dt) override {
        if (shootCooldown > 0) shootCooldown -= dt;

        // Позиция для стрельбы и камеры
        Vector2 pos = ToRay(cpBodyGetPosition(body));

        if (wantsToShoot && shootCooldown <= 0) {
            shootCooldown = FIRE_RATE;
            spawnBulletSignal = true;
            bulletDir = Vector2Subtract(aimTarget, pos);
        }

        // Вычисляем угол поворота (визуально)
        Vector2 diff = Vector2Subtract(aimTarget, pos);
        rotation = atan2(diff.y, diff.x) * RAD2DEG;

        // Передаем угол в физику (хоть она и не вращается от ударов)
        cpBodySetAngle(body, atan2(diff.y, diff.x));

        // Линейное затухание (трение о воздух/землю)
        // В Chipmunk это делается через damping space, но можно и вручную:
        cpVect vel = cpBodyGetVelocity(body);
        cpBodySetVelocity(body, cpvmult(vel, 0.90f)); // Торможение
    }

    void ApplyInput(Vector2 move) {
        if (body) {
            // Прямая установка скорости для четкого управления
            // (или можно использовать forces для "ледяного" управления)
            cpBodySetVelocity(body, cpv(move.x * speed, move.y * speed));
        }
    }
};
// engine\Scenes\GameScene.h
﻿#pragma once
#include <vector>
#include <memory>
#include <map>
#include <algorithm>
#include "../ECS/Player.h"
#include "../ECS/Bullet.h"
#include "../PhysicsUtils.h"

class GameScene {
public:
    cpSpace* space;
    std::map<uint32_t, std::shared_ptr<GameObject>> objects;
    uint32_t nextId = 1;
    float width = 2000;
    float height = 2000;

    GameScene() {
        space = cpSpaceNew();
        // Гравитации нет
        cpSpaceSetGravity(space, cpv(0, 0));

        CreateMapBoundaries();
    }

    ~GameScene() {
        // Сначала очищаем объекты (их деструкторы удалят тела из space)
        objects.clear();
        // Потом удаляем space
        cpSpaceFree(space);
    }

    void CreateMapBoundaries() {
        // Статическое тело для стен (не добавляем его в space, только shape)
        cpBody* staticBody = cpSpaceGetStaticBody(space);

        float w = width;
        float h = height;
        float thick = 20.0f;

        // 4 Стены (Segment Shapes)
        auto addWall = [&](Vector2 a, Vector2 b) {
            cpShape* wall = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, ToCp(a), ToCp(b), thick));
            cpShapeSetElasticity(wall, 0.5f);
            cpShapeSetFriction(wall, 1.0f);
            cpShapeSetCollisionType(wall, COLLISION_WALL);
            };

        addWall({ 0,0 }, { w, 0 });      // Top
        addWall({ 0,h }, { w, h });      // Bottom
        addWall({ 0,0 }, { 0, h });      // Left
        addWall({ w,0 }, { w, h });      // Right
    }

    std::shared_ptr<Player> CreatePlayer() {
        Vector2 startPos = { width / 2, height / 2 };
        auto p = std::make_shared<Player>(nextId++, startPos, space);
        objects[p->id] = p;
        return p;
    }

    void Update(float dt) {
        // Шаг физики (фиксированный шаг для стабильности)
        cpSpaceStep(space, dt);

        // Логика объектов и спавн пуль
        std::vector<std::shared_ptr<Bullet>> newBullets;

        for (auto it = objects.begin(); it != objects.end();) {
            auto& obj = it->second;
            obj->Update(dt);

            if (obj->type == EntityType::PLAYER) {
                auto p = std::dynamic_pointer_cast<Player>(obj);
                if (p && p->spawnBulletSignal) {
                    p->spawnBulletSignal = false;
                    Vector2 spawnPos = ToRay(cpBodyGetPosition(p->body));
                    auto b = std::make_shared<Bullet>(nextId++, spawnPos, p->bulletDir, p->id, space);
                    newBullets.push_back(b);
                }
            }

            if (obj->destroyFlag) {
                it = objects.erase(it); // Деструктор GameObject очистит Chipmunk ресурсы
            }
            else {
                ++it;
            }
        }

        for (auto& b : newBullets) objects[b->id] = b;

        // Обработка урона (Manual Query)
        // Chipmunk имеет систему коллбеков, но для совместимости с вашей логикой
        // сделаем простую проверку расстояний, но физика отталкивания будет от Chipmunk.
        HandleDamageManual();
    }

    void HandleDamageManual() {
        for (auto& [bid, bObj] : objects) {
            if (bObj->type != EntityType::BULLET) continue;
            auto bullet = std::dynamic_pointer_cast<Bullet>(bObj);

            Vector2 bPos = ToRay(cpBodyGetPosition(bullet->body));

            for (auto& [pid, pObj] : objects) {
                if (pObj->type != EntityType::PLAYER) continue;
                if (pid == bullet->ownerId) continue;

                Vector2 pPos = ToRay(cpBodyGetPosition(pObj->body));

                // Простая проверка радиуса (20 танк + 5 пуля)
                if (Vector2Distance(bPos, pPos) < 25.0f) {
                    pObj->health -= 10;
                    bullet->destroyFlag = true;

                    if (pObj->health <= 0) {
                        // Respawn
                        pObj->health = 100;
                        cpVect randPos = cpv(GetRandomValue(100, (int)width - 100), GetRandomValue(100, (int)height - 100));
                        cpBodySetPosition(pObj->body, randPos);
                        cpBodySetVelocity(pObj->body, cpvzero);
                    }
                }
            }
        }
    }

    std::vector<uint8_t> SerializeSnapshot() {
        size_t size = sizeof(WorldSnapshotPacket) + (objects.size() * sizeof(EntityState));
        std::vector<uint8_t> buffer(size);

        WorldSnapshotPacket* header = (WorldSnapshotPacket*)buffer.data();
        header->type = PacketType::server_SNAPSHOT;
        header->entityCount = (uint32_t)objects.size();

        EntityState* states = (EntityState*)(buffer.data() + sizeof(WorldSnapshotPacket));
        int i = 0;
        for (auto& [id, obj] : objects) {
            states[i].id = obj->id;

            // Берем координаты из Chipmunk
            if (obj->body) {
                states[i].position = ToRay(cpBodyGetPosition(obj->body));
                states[i].rotation = (float)cpBodyGetAngle(obj->body) * RAD2DEG;
            }

            states[i].health = obj->health;
            states[i].maxHealth = obj->maxHealth;
            states[i].type = obj->type;
            states[i].radius = (obj->type == EntityType::BULLET) ? 5.0f : 20.0f;
            states[i].color = obj->color;
            i++;
        }
        return buffer;
    }
};
// engine\Scenes\Scene.h
﻿#pragma once

#include "raylib.h"
#include <vector>
#include <cstdint>

class GameClient;

class Scene {
protected:
    GameClient* game;

public:
    Scene(GameClient* _game) : game(_game) {}
    virtual ~Scene() = default;

    virtual void Enter() = 0;
    virtual void Update(float dt) = 0;
    virtual void Draw() = 0;
    virtual void DrawGUI() = 0;
    virtual void Exit() = 0;
    virtual void OnPacketReceived(const uint8_t* data, size_t size) {};
};
// engine\Utils\ConfigManager.cpp
﻿#include "ConfigManager.h"

GameConfig ConfigManager::config;
std::string ConfigManager::configPath;
Font ConfigManager::mainFont = { 0 };

void ConfigManager::Initialize(const std::string& savePath) {
    if (!std::filesystem::exists(savePath)) {
        try {
            std::filesystem::create_directories(savePath);
        }
        catch (const std::exception& e) {
            std::cerr << "Error creating directory: " << e.what() << std::endl;
        }
    }

    configPath = savePath + "config.json";

    Load();
    LoadFonts();
}

void ConfigManager::CreateDefaultConfig() {
    std::cout << "Config file not found. Creating default configuration..." << std::endl;

    config.client.playerName = "Rookie";
    config.client.lastIp = "127.0.0.1";
    config.client.language = "ru";
    config.client.masterVolume = 1.0f;
    config.client.musicVolume = 0.6f;
    config.client.fullscreen = false;
    config.client.targetFPS = 60;

    config.server.port = 7777;
    config.server.maxPlayers = 4;
    config.server.tickRate = 60;
    config.server.serverName = "My Void Server";
    config.server.password = "";


    Save();
}

void ConfigManager::Save() {
    json j;


    j["client"] = {
        {"playerName", config.client.playerName},
        {"lastIp", config.client.lastIp},
        {"language", config.client.language},
        {"masterVolume", config.client.masterVolume},
        {"musicVolume", config.client.musicVolume},
        {"sfxVolume", config.client.sfxVolume},
        {"fullscreen", config.client.fullscreen},
        {"targetFPS", config.client.targetFPS}
    };


    j["server"] = {
        {"port", config.server.port},
        {"maxPlayers", config.server.maxPlayers},
        {"tickRate", config.server.tickRate},
        {"serverName", config.server.serverName},
        {"password", config.server.password}
    };

    std::ofstream file(configPath);
    if (file.is_open()) {
        file << j.dump(4);
        file.close();
        std::cout << "Config saved to: " << configPath << std::endl;
    }
    else {
        std::cerr << "Failed to save config to: " << configPath << std::endl;
    }
}

void ConfigManager::Load() {
    if (!std::filesystem::exists(configPath)) {
        CreateDefaultConfig();
        return;
    }

    std::ifstream file(configPath);
    if (file.is_open()) {
        try {
            json j = json::parse(file);

            if (j.contains("client")) {
                auto& c = j["client"];
                config.client.playerName = c.value("playerName", "Player");
                config.client.lastIp = c.value("lastIp", "127.0.0.1");
                config.client.language = c.value("language", "ru");
                config.client.masterVolume = c.value("masterVolume", 1.0f);
                config.client.musicVolume = c.value("musicVolume", 0.7f);
                config.client.sfxVolume = c.value("sfxVolume", 0.8f);
                config.client.fullscreen = c.value("fullscreen", false);
                config.client.targetFPS = c.value("targetFPS", 60);
            }

            if (j.contains("server")) {
                auto& s = j["server"];
                config.server.port = s.value("port", 7777);
                config.server.maxPlayers = s.value("maxPlayers", 8);
                config.server.tickRate = s.value("tickRate", 60);
                config.server.serverName = s.value("serverName", "Void Server");
                config.server.password = s.value("password", "");
            }

            std::cout << "Config loaded successfully." << std::endl;

        }
        catch (const json::parse_error& e) {
            std::cerr << "JSON Parse Error: " << e.what() << ". Recreating defaults." << std::endl;
            file.close();
            CreateDefaultConfig();
        }
    }
}

void ConfigManager::LoadFonts() {

    int codepoints[512] = { 0 };
    for (int i = 0; i < 95; i++) codepoints[i] = 32 + i;
    for (int i = 0; i < 255; i++) codepoints[96 + i] = 0x400 + i;


    const char* fontPath = "assets/fonts/Roboto-Regular.ttf";

    if (FileExists(fontPath)) {
        mainFont = LoadFontEx(fontPath, 32, codepoints, 512);
        GuiSetFont(mainFont);
    }
    else {
        std::cerr << "WARNING: Font not found at " << fontPath << ". Using default font." << std::endl;
        mainFont = GetFontDefault();
    }
}

void ConfigManager::UnloadResources() {
    if (mainFont.texture.id != 0) {
        UnloadFont(mainFont);
    }
}
// engine\Utils\ConfigManager.h
﻿#pragma once
#include <string>
#include <fstream>
#include <filesystem>
#include <iostream>
#include "raylib.h"
#include "nlohmann/json.hpp"

using json = nlohmann::json;

struct ClientConfig {
    std::string playerName = "Player";
    std::string lastIp = "127.0.0.1";
    std::string language = "ru";
    float masterVolume = 1.0f;
    float musicVolume = 0.7f;
    float sfxVolume = 0.8f;
    bool fullscreen = false;
    int targetFPS = 60;
};

struct ServerConfig {
    int port = 7777;
    int maxPlayers = 8;
    int tickRate = 60;
    std::string serverName = "Void Assault Server";
    std::string password = "";
};

struct GameConfig {
    ClientConfig client;
    ServerConfig server;
};

class ConfigManager {
private:
    static GameConfig config;
    static std::string configPath;
    static Font mainFont;

    static void CreateDefaultConfig();

public:
    static void Initialize(const std::string& savePath);

    static void Save();
    static void Load();


    static ClientConfig& GetClient() { return config.client; }
    static ServerConfig& GetServer() { return config.server; }

    static void LoadFonts();
    static Font GetFont() { return mainFont; }
    static void UnloadResources();
};

// server\CMakeLists.txt
﻿#server module CMakeLists.txt
add_executable(GameServer
    main_server.cpp
)
target_include_directories(GameServer PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_link_libraries(GameServer PRIVATE GameEngine GameCommon enet::enet_shared)

// server\main_server.cpp
﻿#include "../engine/ServerHost.h"
#include <iostream>
#include <string>

int main() {
    if (enet_initialize() != 0) {
        std::cerr << "An error occurred while initializing ENet.\n";
        return 1;
    }

    InitWindow(100, 100, "ServerHeadless");
    SetWindowState(FLAG_WINDOW_HIDDEN);

    ServerHost server;
    if (server.Start(7777)) {
        std::cout << "Dedicated Server started on port 7777. Type 'quit' to stop.\n";

        std::string cmd;
        while (std::cin >> cmd) {
            if (cmd == "quit") break;
        }

        server.Stop();
    }

    CloseWindow();
    enet_deinitialize();
    return 0;
}