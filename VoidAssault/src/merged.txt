
// merged.txt

// reader.py
import os

def merge_files(root_dir, output_file, extensions=None):
    """
    Рекурсивно считывает все файлы из root_dir и записывает в один файл.
    Перед каждым файлом вставляется комментарий с его путём.
    extensions — список расширений, если нужно фильтровать (например ['.h', '.cpp'])
    Если extensions=None — берутся все файлы.
    """
    with open(output_file, "w", encoding="utf-8") as out:
        for folder, _, files in os.walk(root_dir):
            for file in files:
                file_path = os.path.join(folder, file)
                rel_path = os.path.relpath(file_path, root_dir)
                
                # Фильтр по расширениям, если нужно
                if extensions is not None:
                    _, ext = os.path.splitext(file)
                    if ext.lower() not in extensions:
                        continue

                out.write(f"\n// {rel_path}\n")

                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        out.write(f.read())
                except Exception as e:
                    out.write(f"[Ошибка при чтении файла: {e}]\n")


if __name__ == "__main__":
    merge_files(
        root_dir=".", 
        output_file="merged.txt",
        extensions=None 
    )

// client\AudioManager.h
﻿#pragma once
#include "raylib.h"
#include <map>
#include <string>
#include <iostream>

class AudioManager {
    std::map<std::string, Sound> sounds;
    std::map<std::string, Music> musics;
    float masterVolume = 1.0f;

public:
    AudioManager() {
        InitAudioDevice();
    }

    ~AudioManager() {
        for (auto& s : sounds) UnloadSound(s.second);
        for (auto& m : musics) UnloadMusicStream(m.second);
        CloseAudioDevice();
    }

    void LoadSnd(const std::string& key, const std::string& path) {
        Sound s = LoadSound(path.c_str());
        if (s.frameCount > 0) sounds[key] = s;
        else std::cout << "Failed to load sound: " << path << std::endl;
    }

    void LoadMus(const std::string& key, const std::string& path) {
        Music m = LoadMusicStream(path.c_str());
        if (m.frameCount > 0) musics[key] = m;
    }

    void PlaySnd(const std::string& key) {
        if (sounds.count(key)) {
            SetSoundVolume(sounds[key], masterVolume);
            PlaySound(sounds[key]);
        }
    }

    void PlayMus(const std::string& key) {
        if (musics.count(key)) {
            if (!IsMusicStreamPlaying(musics[key])) PlayMusicStream(musics[key]);
            SetMusicVolume(musics[key], masterVolume);
            UpdateMusicStream(musics[key]);
        }
    }

    void Update() {
        for (auto& pair : musics) {
            if (IsMusicStreamPlaying(pair.second)) UpdateMusicStream(pair.second);
        }
    }

    void SetVolume(float vol) { masterVolume = vol; }
    float GetVolume() const { return masterVolume; }
};
// client\CMakeLists.txt
﻿    file(GLOB CLIENT_SOURCES "*.cpp" "scenes/*.cpp")
#file(GLOB_RECURSE Imgui_SFML_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/../imgui-sfml/*.*")
if(WIN32 OR CMAKE_SYSTEM_NAME STREQUAL "Linux" OR LINUX)

    add_executable(GameClient
        ${CLIENT_SOURCES}
    )

    #if(WIN32)
      #  set_target_properties(GameClient PROPERTIES WIN32_EXECUTABLE ON)
    #endif()

    target_link_libraries(GameClient PRIVATE raylib GameEngine GameCommon enet::enet_shared nlohmann_json)

    target_include_directories(GameClient PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
    target_include_directories(GameClient PRIVATE ${PROJECT_INCLUDE_DIR})
    target_include_directories(GameClient PRIVATE ${ENET_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PRIVATE ${RAYGUI_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
    file(COPY ${CMAKE_SOURCE_DIR}/assets DESTINATION ${GLOBAL_OUTPUT_DIR})

elseif(ANDROID)
    add_library(gameclient SHARED ${CLIENT_SOURCES})

    target_link_libraries(gameclient  PRIVATE android log
        raylib
    GameEngine 
    GameCommon
    enet::enet_shared
    chipmunk_static
    nlohmann_json)
    target_include_directories(gameclient PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
    target_include_directories(gameclient PRIVATE ${PROJECT_INCLUDE_DIR})
    target_include_directories(gameclient PRIVATE ${ENET_EXTERNAL_INCLUDE_DIR})
    target_include_directories(gameclient PRIVATE ${RAYGUI_EXTERNAL_INCLUDE_DIR})
    target_include_directories(gameclient PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})

target_include_directories(gameclient PUBLIC "${CMAKE_SOURCE_DIR}/external")
endif()






// client\GameClient.cpp
﻿#include "GameClient.h"
#include "scenes/MainMenuScene.h" 
#include "scenes/GameplayScene.h"



GameClient::GameClient() {

    InitWindow(screenWidth, screenHeight, "Void Assault");
    SetTargetFPS(60);
    SetWindowState(FLAG_WINDOW_RESIZABLE);

    if (enet_initialize() != 0) {
        TraceLog(LOG_ERROR, "Failed to init ENet");
    }

    if (!network.Init()) {
        TraceLog(LOG_ERROR, "Failed to create ENet client host");
    }
    GuiSetStyle(DEFAULT, TEXT_SIZE, 20);
}

GameClient::~GameClient() {
    StopHost();
    if (currentScene) currentScene->Exit();
    network.Shutdown();
    enet_deinitialize();
    CloseWindow();
}

void GameClient::ChangeScene(std::shared_ptr<Scene> newScene) {
    nextScene = newScene;
}

void GameClient::StartHost() {
    if (!localServer) {
        localServer = std::make_unique<ServerHost>();
        if (localServer->Start(7777)) {
            TraceLog(LOG_INFO, "Local Server Started!");
        }
        else {
            TraceLog(LOG_ERROR, "Failed to start local server!");
        }
    }
}
void GameClient::StartHost(int port) {
    if (!localServer) {
        localServer = std::make_unique<ServerHost>();
        if (localServer->Start(port)) {
            TraceLog(LOG_INFO, "Local Server Started!");
        }
        else {
            TraceLog(LOG_ERROR, "Failed to start local server!");
        }
    }
}
void GameClient::StopHost() {
    if (localServer) {
        localServer->Stop();
        localServer.reset();
        TraceLog(LOG_INFO, "Local Server Stopped.");
    }
}

void GameClient::Run() {
    ChangeScene(std::make_shared<MainMenuScene>(this));

    while (!WindowShouldClose()) {
        if (nextScene) {
            if (currentScene) currentScene->Exit();
            currentScene = nextScene;
            currentScene->Enter();
            nextScene = nullptr;
        }

        float dt = GetFrameTime();

        ENetEvent event;
        while (enet_host_service(network.clientHost, &event, 0) > 0) {
            switch (event.type) {
            case ENET_EVENT_TYPE_CONNECT:
                network.isConnected = true;
                TraceLog(LOG_INFO, "Connected to server!");
                ChangeScene(std::make_shared<GameplayScene>(this));
                break;
            case ENET_EVENT_TYPE_DISCONNECT:
                network.isConnected = false;
                TraceLog(LOG_INFO, "Disconnected from server.");
                break;
            case ENET_EVENT_TYPE_RECEIVE:
                if (currentScene) {
                    currentScene->OnPacketReceived(event.packet->data, event.packet->dataLength);
                }
                enet_packet_destroy(event.packet);
                break;
            }
        }

        if (currentScene) {
            currentScene->Update(dt);

            BeginDrawing();
            ClearBackground(RAYWHITE);

            currentScene->Draw();
            currentScene->DrawGUI();

            EndDrawing();
        }
    }
}
// client\GameClient.h
﻿#pragma once
#include "raygui_wrapper.h"
#include "NetworkManager.h"
#include "../engine/Scenes/Scene.h"
#include "../engine/ServerHost.h"
#include "AudioManager.h"
#include <memory>

class GameClient {
public:
    int screenWidth = 1280;
    int screenHeight = 720;

    NetworkManager network;
    std::unique_ptr<ServerHost> localServer;
    AudioManager audio;

    std::shared_ptr<Scene> currentScene;
    std::shared_ptr<Scene> nextScene;

    GameClient();
    ~GameClient();

    void Run();
    void ChangeScene(std::shared_ptr<Scene> newScene);
    void ReturnToMenu();

    void StartHost();
    void StartHost(int port);
    void StopHost();

    int GetWidth() const { return GetScreenWidth(); }
    int GetHeight() const { return GetScreenHeight(); }
};
// client\main_client.cpp
﻿#define RAYGUI_IMPLEMENTATION
#include "GameClient.h"
#include "engine/Utils/ConfigManager.h"
int* GetCompleteCodepoints(int* count) {
    static int completeChars[] = {
            0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029,
            0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, 0x0030, 0x0031, 0x0032, 0x0033,
            0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D,
            0x003E, 0x003F, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
            0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, 0x0050, 0x0051,
            0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B,
            0x005C, 0x005D, 0x005E, 0x005F, 0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065,
            0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
            0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079,
            0x007A, 0x007B, 0x007C, 0x007D, 0x007E,
            0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419,
            0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F, 0x0420, 0x0421, 0x0422, 0x0423,
            0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D,
            0x042E, 0x042F, 0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
            0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F, 0x0440, 0x0441,
            0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044A, 0x044B,
            0x044C, 0x044D, 0x044E, 0x044F, 0x0401, 0x0451
    };

    *count = sizeof(completeChars) / sizeof(completeChars[0]);
    int* result = (int*)malloc(*count * sizeof(int));
    memcpy(result, completeChars, *count * sizeof(int));
    return result;
}
Font LoadFont() {
    int codepointCount = 0;
    int* completeCodepoints = GetCompleteCodepoints(&codepointCount);
	Font mainFont;
#ifdef ANDROID
    mainFont = LoadFontEx("assets/fonts//Roboto-Regular.ttf", 70, completeCodepoints, codepointCount);
    GuiSetStyle(DEFAULT, TEXT_SIZE, 58);
#else
    mainFont = LoadFontEx("assets/fonts//Roboto-Regular.ttf", 36, completeCodepoints, codepointCount);
    GuiSetStyle(DEFAULT, TEXT_SIZE, 20);

#endif // ANDROID
    free(completeCodepoints);

    GuiSetFont(mainFont);

	return mainFont;
}
int main() {
    std::string configPath = "./";

#if defined(ANDROID) || defined(PLATFORM_ANDROID)

    configPath = GetApplicationDirectory();
#endif

    ConfigManager::Initialize(configPath);

    GameClient game;
    LoadFont();
    GuiSetFont(ConfigManager::GetFont());

    SetTargetFPS(ConfigManager::GetClient().targetFPS);
    if (ConfigManager::GetClient().fullscreen) {
        ToggleFullscreen();
    }

    game.Run();
    return 0;
}
// client\NetworkManager.h
﻿#pragma once
#include <enet.h>
#include <string>
#include <iostream>
#include "../common/NetworkPackets.h"

class NetworkManager {
public:
    ENetHost* clientHost = nullptr;
    ENetPeer* serverPeer = nullptr;
    bool isConnected = false;

    bool Init() {
        if (enet_initialize() != 0) return false;
        clientHost = enet_host_create(NULL, 1, 2, 0, 0);
        return (clientHost != nullptr);
    }

    void Connect(const std::string& ip, int port) {
        ENetAddress address;
        enet_address_set_host(&address, ip.c_str());
        address.port = port;
        serverPeer = enet_host_connect(clientHost, &address, 2, 0);
    }

    void Disconnect() {
        if (serverPeer) {
            enet_peer_disconnect(serverPeer, 0);
            enet_host_flush(clientHost);
            serverPeer = nullptr;
        }
        isConnected = false;
    }

    void SendInput(const PlayerInputPacket& input) {
        if (!isConnected || !serverPeer) return;
        ENetPacket* packet = enet_packet_create(&input, sizeof(PlayerInputPacket), ENET_PACKET_FLAG_UNSEQUENCED);
        enet_peer_send(serverPeer, 0, packet);
    }

    void Shutdown() {
        if (clientHost) enet_host_destroy(clientHost);
        enet_deinitialize();
    }
};
// client\ParticleSystem.h
﻿#pragma once
#include "raylib.h"
#include <vector>
#include <algorithm>

struct Particle {
    Vector2 position;
    Vector2 velocity;
    float life;      // 1.0 -> 0.0
    float decayRate; // Скорость исчезновения
    float size;
    Color color;
};

class ParticleSystem {
    std::vector<Particle> particles;

public:
    void Spawn(Vector2 pos, Vector2 vel, Color col, float size, float lifeTime) {
        Particle p;
        p.position = pos;
        p.velocity = vel;
        p.color = col;
        p.size = size;
        p.life = 1.0f;
        p.decayRate = 1.0f / lifeTime;
        particles.push_back(p);
    }

    void SpawnExplosion(Vector2 pos, int count, Color col) {
        for (int i = 0; i < count; i++) {
            float angle = (float)GetRandomValue(0, 360) * DEG2RAD;
            float speed = (float)GetRandomValue(50, 200) / 10.0f;
            Vector2 vel = { cosf(angle) * speed, sinf(angle) * speed };
            Spawn(pos, vel, col, (float)GetRandomValue(3, 8), 0.5f);
        }
    }

    void Update(float dt) {
        for (auto& p : particles) {
            p.position.x += p.velocity.x * dt * 60.0f;
            p.position.y += p.velocity.y * dt * 60.0f;
            p.life -= p.decayRate * dt;
            p.size *= 0.95f;
        }

        particles.erase(
            std::remove_if(particles.begin(), particles.end(),
                [](const Particle& p) { return p.life <= 0; }),
            particles.end());
    }

    void Draw() {
        for (const auto& p : particles) {
            Color c = p.color;
            c.a = (unsigned char)(p.life * 255);
            DrawCircleV(p.position, p.size, c);
        }
    }
};
// client\raygui_wrapper.h
﻿// raygui_wrapper.h
#pragma once

#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "raylib.h"
#include "raygui.h"
// client\ResourceManager.h
﻿#pragma once
#include "raylib.h"
#include <string>

class ResourceManager {
public:
    Font mainFont;

    static ResourceManager& Get() {
        static ResourceManager instance;
        return instance;
    }

    void Load() {
        // Загружаем шрифт. Если файла нет, Raylib загрузит дефолтный, но с фильтрацией
        // В реальном проекте положи файл .ttf в папку assets
        // mainFont = LoadFontEx("assets/font.ttf", 64, 0, 0);

        // Пока используем дефолтный, но ставим фильтр для гладкости
        mainFont = GetFontDefault();
        SetTextureFilter(mainFont.texture, TEXTURE_FILTER_BILINEAR);
    }

    void Unload() {
        // UnloadFont(mainFont);
    }

    static void DrawTextCentered(const char* text, int cx, int cy, int fontSize, Color color) {
        int width = MeasureText(text, fontSize);
        DrawText(text, cx - width / 2, cy - fontSize / 2, fontSize, color);
    }
};
// client\Theme.h
#pragma once
#include "raylib.h"

namespace Theme {
    static const Color BG_COLOR = { 205, 205, 205, 255 };
    static const Color GRID_COLOR = { 170, 170, 170, 255 };
    static const Color BORDER_COLOR = { 85, 85, 85, 255 };

    static const Color COLOR_BLUE = { 0, 178, 225, 255 };
    static const Color COLOR_RED = { 241, 78, 84, 255 };
    static const Color COLOR_BARREL = { 153, 153, 153, 255 };

    static const float OUTLINE_THICKNESS = 3.0f;
    static const float BARREL_WIDTH_RATIO = 0.45f;
}
// client\VirtualJoystick.cpp
﻿#include "VirtualJoystick.h"
#include "raymath.h"

#ifndef MAX_TOUCH_POINTS
#define MAX_TOUCH_POINTS 10
#endif

VirtualJoystick::VirtualJoystick() {

}

VirtualJoystick::VirtualJoystick(Vector2 pos, float rStick, float rBody) {
    position = pos;
    stickPosition = pos;
    radiusStick = rStick;
    radiusBody = rBody;
    radiusInteraction = rBody * 1.5f;
}

void VirtualJoystick::SetPosition(Vector2 pos) {
    position = pos;
    if (!dragging) {
        stickPosition = pos;
    }
}

void VirtualJoystick::SetPosition(float x, float y) {
    SetPosition({ x, y });
}

bool VirtualJoystick::IsTouchInBounds(Vector2 touchPos) const {
    return Vector2Distance(touchPos, position) <= radiusInteraction;
}

void VirtualJoystick::Update() {
    bool inputFound = false;
    Vector2 inputPos = { 0, 0 };


    if (dragging) {
        if (touchId == -2) {
            if (IsMouseButtonDown(MOUSE_LEFT_BUTTON)) {
                inputPos = GetMousePosition();
                inputFound = true;
            }
        }
        else {
            if (touchId < GetTouchPointCount()) {
                inputPos = GetTouchPosition(touchId);
                inputFound = true;
            }
        }

        if (!inputFound) {
            Reset();
            return;
        }
    }
    else {
        int count = GetTouchPointCount();
        for (int i = 0; i < count && i < MAX_TOUCH_POINTS; i++) {
            Vector2 touchPos = GetTouchPosition(i);
            if (IsTouchInBounds(touchPos)) {
                dragging = true;
                touchId = i;
                inputPos = touchPos;
                inputFound = true;
                break;
            }
        }

        if (!inputFound && IsMouseButtonDown(MOUSE_LEFT_BUTTON)) {
            Vector2 mousePos = GetMousePosition();
            if (IsTouchInBounds(mousePos)) {
                dragging = true;
                touchId = -2;
                inputPos = mousePos;
                inputFound = true;
            }
        }
    }

    if (dragging) {
        Vector2 direction = Vector2Subtract(inputPos, position);
        float distance = Vector2Length(direction);

        if (distance > radiusBody) {
            direction = Vector2Scale(Vector2Normalize(direction), radiusBody);
            stickPosition = Vector2Add(position, direction);
        }
        else {
            stickPosition = inputPos;
        }

        if (radiusBody > 0) {
            axis = Vector2Scale(direction, 1.0f / radiusBody);
        }

        if (Vector2Length(axis) > 1.0f) {
            axis = Vector2Normalize(axis);
        }
    }
    else {
        Reset();
    }
}

void VirtualJoystick::Reset() {
    stickPosition = position;
    dragging = false;
    touchId = -1;
    axis = { 0, 0 };
}

void VirtualJoystick::Draw() {

    DrawCircleV(position, radiusBody, colorBody);
    DrawRing(position, radiusBody, radiusBody + 2, 0, 360, 24, Fade(colorBody, 0.8f));

    DrawCircleV(stickPosition, radiusStick, colorStick);

    if (dragging) {
        DrawCircleV(stickPosition, radiusStick * 0.8f, Fade(WHITE, 0.3f));
    }
}
// client\VirtualJoystick.h
﻿#pragma once
#include <raylib.h>

class VirtualJoystick {
public:
    VirtualJoystick();
    VirtualJoystick(Vector2 pos, float radiusStick, float radiusBody);

    void Update();
    void Draw();
    void Reset();


    Vector2 GetAxis() const { return axis; }

    const Vector2& GetPosition() const { return position; }
    void SetPosition(Vector2 pos);
    void SetPosition(float x, float y);

    bool IsDragging() const { return dragging; }


    void SetColors(Color body, Color stick) {
        colorBody = body;
        colorStick = stick;
    }

    void SetRadii(float body, float stick, float interaction) {
        radiusBody = body;
        radiusStick = stick;
        radiusInteraction = interaction;
    }

private:
    int touchId = -1;
    bool dragging = false;

    Vector2 position = { 0, 0 };
    Vector2 stickPosition = { 0, 0 };
    Vector2 axis = { 0, 0 };


    float radiusStick = 20.0f;
    float radiusBody = 50.0f;
    float radiusInteraction = 60.0f;


    Color colorStick = { 200, 200, 200, 255 };
    Color colorBody = { 50, 50, 50, 150 };


    bool IsTouchInBounds(Vector2 touchPos) const;
};
// client\scenes\GameplayScene.cpp
﻿#include "GameplayScene.h"
#include "MainMenuScene.h"
#include "../GameClient.h"
GameplayScene::GameplayScene(GameClient* g) : Scene(g) {}

void GameplayScene::Enter() {
    float w = (float)game->GetWidth();
    float h = (float)game->GetHeight();

    camera.zoom = 1.0f;
    camera.offset = { w / 2, h / 2 };

    // Инициализация джойстиков
    // Слева - Движение
    leftStick = std::make_unique<VirtualJoystick>(Vector2{ 150, h - 150 }, 40.0f, 90.0f);

    // Справа - Стрельба (Красный)
    rightStick = std::make_unique<VirtualJoystick>(Vector2{ w - 150, h - 150 }, 40.0f, 90.0f);
    rightStick->SetColors({ 60, 0, 0, 150 }, { 220, 50, 50, 200 });
}



void GameplayScene::Exit() {
    game->network.Disconnect();
    game->StopHost();
    worldEntities.clear();
}

void GameplayScene::OnPacketReceived(const uint8_t* data, size_t size) {
    PacketHeader* header = (PacketHeader*)data;

    if (header->type == PacketType::server_INIT) {
        InitPacket* init = (InitPacket*)data;
        myPlayerId = init->yourPlayerId;
    }
    else if (header->type == PacketType::server_SNAPSHOT) {
        WorldSnapshotPacket* snap = (WorldSnapshotPacket*)data;
        EntityState* states = (EntityState*)(data + sizeof(WorldSnapshotPacket));

        std::vector<uint32_t> receivedIds;
        for (uint32_t i = 0; i < snap->entityCount; i++) {
            receivedIds.push_back(states[i].id);
            worldEntities[states[i].id].PushState(states[i]);
        }
        for (auto it = worldEntities.begin(); it != worldEntities.end();) {
            bool found = false;
            for (uint32_t id : receivedIds) if (id == it->first) found = true;
            if (!found) it = worldEntities.erase(it);
            else ++it;
        }
    }
}

void GameplayScene::Update(float dt) {
    // 1. Обновляем джойстики
    leftStick->Update();
    rightStick->Update();

    PlayerInputPacket pkt;
    pkt.type = PacketType::client_INPUT;

    // 2. Логика движения
    Vector2 moveDir = leftStick->GetAxis();
    pkt.movement = moveDir;

    // Поддержка клавиатуры (WASD)
    if (IsKeyDown(KEY_W)) pkt.movement.y -= 1.0f;
    if (IsKeyDown(KEY_S)) pkt.movement.y += 1.0f;
    if (IsKeyDown(KEY_A)) pkt.movement.x -= 1.0f;
    if (IsKeyDown(KEY_D)) pkt.movement.x += 1.0f;

    // Нормализация
    if (Vector2Length(pkt.movement) > 1.0f) {
        pkt.movement = Vector2Normalize(pkt.movement);
    }

    // 3. Логика стрельбы
    Vector2 aimDir = rightStick->GetAxis();

    // Если джойстик отклонен
    if (Vector2Length(aimDir) > 0.2f) { // Deadzone
        pkt.isShooting = true;

        if (worldEntities.count(myPlayerId)) {
            // Стреляем относительно игрока
            Vector2 playerPos = worldEntities[myPlayerId].renderPos;
            pkt.aimTarget = Vector2Add(playerPos, Vector2Scale(aimDir, 300.0f));
        }
    }
    // Если джойстик не трогают - управление мышью
    else {
        pkt.aimTarget = GetScreenToWorld2D(GetMousePosition(), camera);
        pkt.isShooting = IsMouseButtonDown(MOUSE_LEFT_BUTTON);
    }

    // 4. Отправка и обновление
    game->network.SendInput(pkt);

    for (auto& [id, ent] : worldEntities) {
        ent.UpdateInterpolation();
    }

    if (worldEntities.count(myPlayerId)) {
        Vector2 target = worldEntities[myPlayerId].renderPos;
        camera.target = Vector2Lerp(camera.target, target, 0.1f);
    }
}

void GameplayScene::Draw() {
    BeginMode2D(camera);
    DrawGrid(100, 50);
    DrawRectangleLines(0, 0, 2000, 2000, GRAY);

    for (auto& [id, ent] : worldEntities) {
        EntityState& st = ent.current;

        if (st.type == EntityType::PLAYER) {
            DrawCircleV(ent.renderPos, st.radius, st.color);
            Vector2 barrelEnd = {
                ent.renderPos.x + cosf(ent.renderRot * DEG2RAD) * 40,
                ent.renderPos.y + sinf(ent.renderRot * DEG2RAD) * 40
            };
            DrawLineEx(ent.renderPos, barrelEnd, 15, DARKGRAY);

            float hpPct = st.health / st.maxHealth;
            DrawRectangle((int)ent.renderPos.x - 20, (int)ent.renderPos.y - 40, 40, 5, RED);
            DrawRectangle((int)ent.renderPos.x - 20, (int)ent.renderPos.y - 40, (int)(40 * hpPct), 5, GREEN);
        }
        else if (st.type == EntityType::BULLET) {
            DrawCircleV(ent.renderPos, st.radius, RED);
        }
    }
    EndMode2D();
}

void GameplayScene::DrawGUI() {
    DrawFPS(10, 10);
    if (!game->network.isConnected) {
        DrawText("Connecting to server...", game->GetWidth() / 2 - 100, 20, 20, RED);
    }
    leftStick->Draw();
    rightStick->Draw();
    if (GuiButton(Rectangle{ (float)game->GetWidth() - 100, 10, 90, 30 }, "DISCONNECT")) {
        game->ChangeScene(std::make_shared<MainMenuScene>(game));
    }
}
// client\scenes\GameplayScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"
#include "../../common/NetworkPackets.h"
#include "../ParticleSystem.h"
#include "../VirtualJoystick.h"
#include "raymath.h"
#include <map>
#include <vector>
#include <memory>
class GameClient;
struct InterpolatedEntity {
    EntityState current;
    EntityState previous;
    float lastUpdateTime;
    Vector2 renderPos;
    float renderRot;


    InterpolatedEntity() : lastUpdateTime(0), renderRot(0) {}

    void PushState(const EntityState& newState) {
        previous = current;
        current = newState;
        lastUpdateTime = (float)GetTime();
        if (previous.id == 0) previous = current;
    }

    void UpdateInterpolation() {
        double serverTickRate = 0.05;
        double t = (GetTime() - lastUpdateTime) / serverTickRate;
        if (t > 1.0) t = 1.0;
        if (t < 0.0) t = 0.0;

        renderPos = Vector2Lerp(previous.position, current.position, (float)t);
        renderRot = Lerp(previous.rotation, current.rotation, (float)t);
    }
};

class GameplayScene : public Scene {
    Camera2D camera = { 0 };
    std::map<uint32_t, InterpolatedEntity> worldEntities;
    uint32_t myPlayerId = 0;
    std::unique_ptr<VirtualJoystick> leftStick;
    std::unique_ptr<VirtualJoystick> rightStick;


public:
    GameplayScene(GameClient* g);
    virtual ~GameplayScene() = default;

    void Enter() override;
    void Exit() override;
    void OnPacketReceived(const uint8_t* data, size_t size) override;
    void Update(float dt) override;
    void Draw() override;
    void DrawGUI() override;
};
// client\scenes\MainMenuScene.cpp
﻿#include "MainMenuScene.h"
#include "raygui.h"
#include "GameClient.h"
#include "engine/Utils/ConfigManager.h"
#include <cstring> // для strcpy

enum MenuState { MAIN, MULTIPLAYER, SETTINGS };
static MenuState currentMenuState = MAIN;

MainMenuScene::MainMenuScene(GameClient* g) : Scene(g) {}

void MainMenuScene::Enter() {
    // Копируем данные из конфига в буферы при входе
    ClientConfig& cfg = ConfigManager::GetClient();
    ServerConfig& sCfg = ConfigManager::GetServer();

    strcpy(ipBuffer, cfg.lastIp.c_str());
    sprintf(portBuffer, "%d", cfg.lastPort > 0 ? cfg.lastPort : sCfg.port);
    strcpy(nameBuffer, cfg.playerName.c_str());
}

void MainMenuScene::Draw() {
    ClearBackground(GetColor(0x181818FF));
    int w = GetScreenWidth();
    int h = GetScreenHeight();

    const char* title = ConfigManager::Text("title_void_assault");
    DrawText(title, w / 2 - MeasureText(title, 60) / 2, 50, 60, WHITE);

    if (currentMenuState == MAIN) {
        float btnW = 300; float btnH = 50; float startY = 200; float spacing = 70;

        // Одиночная игра (Хост + Клиент)
        if (GuiButton({ (float)w / 2 - btnW / 2, startY, btnW, btnH }, ConfigManager::Text("btn_singleplayer"))) {
            game->StartHost(7777);
            // После старта хоста подключаемся к самому себе
            game->network.Connect("127.0.0.1", 7777);
            // Сцена сменится при получении пакета коннекта или вручную тут
        }

        // Сетевая игра
        if (GuiButton({ (float)w / 2 - btnW / 2, startY + spacing, btnW, btnH }, ConfigManager::Text("btn_multiplayer"))) {
            currentMenuState = MULTIPLAYER;
        }

        // Настройки
        if (GuiButton({ (float)w / 2 - btnW / 2, startY + spacing * 2, btnW, btnH }, ConfigManager::Text("btn_settings"))) {
            currentMenuState = SETTINGS;
        }

        // Выход
        if (GuiButton({ (float)w / 2 - btnW / 2, startY + spacing * 3, btnW, btnH }, ConfigManager::Text("btn_exit"))) {
            CloseWindow();
        }
    }
    else if (currentMenuState == MULTIPLAYER) {
        // Настройка имени
        GuiGroupBox({ (float)w / 2 - 200, 130, 400, 60 }, ConfigManager::Text("lbl_player_setup"));
        GuiLabel({ (float)w / 2 - 180, 150, 100, 30 }, ConfigManager::Text("lbl_nickname"));
        if (GuiTextBox({ (float)w / 2 - 80, 150, 260, 30 }, nameBuffer, 32, isEditingName)) {
            isEditingName = !isEditingName;
            ConfigManager::GetClient().playerName = std::string(nameBuffer);
            ConfigManager::Save();
        }

        // Вкладки
        activeTab = GuiToggleGroup({ (float)w / 2 - 200, 220, 200, 40 }, ConfigManager::Text("tabs_multiplayer"), &activeTab);

        float startY = 280;

        if (activeTab == 0) { // ПОДКЛЮЧЕНИЕ
            GuiLabel({ (float)w / 2 - 180, startY, 50, 30 }, ConfigManager::Text("lbl_ip"));
            if (GuiTextBox({ (float)w / 2 - 130, startY, 200, 30 }, ipBuffer, 64, isEditingIp)) isEditingIp = !isEditingIp;

            GuiLabel({ (float)w / 2 + 80, startY, 50, 30 }, ConfigManager::Text("lbl_port"));
            if (GuiTextBox({ (float)w / 2 + 120, startY, 80, 30 }, portBuffer, 16, isEditingPort)) isEditingPort = !isEditingPort;

            if (GuiButton({ (float)w / 2 - 150, startY + 60, 300, 50 }, ConfigManager::Text("btn_join"))) {
                ClientConfig& cfg = ConfigManager::GetClient();
                cfg.lastIp = std::string(ipBuffer);
                cfg.lastPort = atoi(portBuffer);
                ConfigManager::Save();

                game->network.Connect(cfg.lastIp, cfg.lastPort);
                // Переход в игру произойдет автоматически при событии ENET_CONNECT в GameClient::Run
            }
        }
        else if (activeTab == 1) { // СОЗДАНИЕ
            GuiLabel({ (float)w / 2 - 50, startY, 50, 30 }, ConfigManager::Text("lbl_port"));
            if (GuiTextBox({ (float)w / 2, startY, 100, 30 }, portBuffer, 16, isEditingPort)) isEditingPort = !isEditingPort;

            if (GuiButton({ (float)w / 2 - 150, startY + 60, 300, 50 }, ConfigManager::Text("btn_create_lobby"))) {
                int port = atoi(portBuffer);
                ConfigManager::GetServer().port = port;
                ConfigManager::Save();

                game->StartHost(port);
                game->network.Connect("127.0.0.1", port);
            }
        }

        if (GuiButton({ 20, 20, 100, 40 }, ConfigManager::Text("btn_back"))) {
            currentMenuState = MAIN;
        }
    }
    else if (currentMenuState == SETTINGS) {
        // Смена языка
        if (GuiButton({ (float)w / 2 - 100, 200, 200, 40 }, "Language: RU / EN")) {
            ClientConfig& cfg = ConfigManager::GetClient();
            cfg.language = (cfg.language == "ru") ? "en" : "ru";
            ConfigManager::LoadLanguage(cfg.language);
            ConfigManager::Save();
        }

        if (GuiButton({ 20, 20, 100, 40 }, ConfigManager::Text("btn_back"))) {
            currentMenuState = MAIN;
        }
    }
}
// client\scenes\MainMenuScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"

class GameClient;

class MainMenuScene : public Scene {
    char ipBuffer[64] = "";
    char portBuffer[16] = "";
    char nameBuffer[32] = "";

    bool isEditingIp = false;
    bool isEditingPort = false;
    bool isEditingName = false;

    // Состояние табов
    int activeTab = 0; // 0 = Connect, 1 = Host

public:
    MainMenuScene(GameClient* g);
    virtual ~MainMenuScene() = default;

    void Enter() override;
    void Exit() override {}
    void Update(float dt) override {}
    void Draw() override;
    void DrawGUI() override {}
};
// client\scenes\SettingsScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"
#include "../../client/GameClient.h"
#include "../Theme.h"

class SettingsScene : public Scene {
public:
    SettingsScene(GameClient* g) : Scene(g) {}

    void Enter() override {}
    void Exit() override {}
    void Update(float dt) override {} // Логика в DrawGUI

    void Draw() override {
        ClearBackground(Theme::BG_COLOR);
        ResourceManager::DrawTextCentered("SETTINGS", game->GetWidth() / 2, 100, 60, Theme::COLOR_BLUE);
    }

    void DrawGUI() override {
        float cx = game->GetWidth() / 2.0f - 150;
        float cy = 200;

        // Управление громкостью
        GuiLabel(Rectangle{ cx, cy - 30, 300, 20 }, "Master Volume");
        float vol = game->audio.GetVolume();
        if (GuiSlider(Rectangle{ cx, cy, 300, 30 }, "0", "1", &vol, 0.0f, 1.0f)) {
            game->audio.SetVolume(vol);
        }
        cy += 80;

        // Полноэкранный режим (для ПК)
        static bool fullscreen = IsWindowFullscreen();
        if (GuiCheckBox(Rectangle{ cx, cy, 30, 30 }, "Fullscreen", &fullscreen)) {
            ToggleFullscreen();
        }
        cy += 80;

        // Кнопка назад
        if (GuiButton(Rectangle{ cx, game->GetHeight() - 100.0f, 300, 50 }, "BACK")) {
            // Возвращаемся в главное меню (нужен forward declaration или include)
            // Для простоты в GameClient сделаем метод ReturnToMenu
            game->ReturnToMenu();
        }
    }
};
// common\CMakeLists.txt
﻿add_library(GameCommon SHARED
    NetworkPackets.h Common.cpp
)

target_link_libraries(GameCommon PUBLIC enet::enet_shared raylib)
target_include_directories(GameCommon PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameCommon PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
// common\Common.cpp

// common\NetworkPackets.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif
#include <cstdint>
#include "raylib.h"

enum class PacketType : uint8_t {
    client_CONNECT,
    client_INPUT,
    server_INIT,
    server_SNAPSHOT,
    server_EVENT
};

struct PacketHeader {
    PacketType type;
};

struct PlayerInputPacket : PacketHeader {
    Vector2 movement;
    Vector2 aimTarget;
    bool isShooting;
};

enum class EntityType : uint8_t { PLAYER, BULLET, ENEMY };

struct EntityState {
    uint32_t id;
    Vector2 position;
    float rotation;
    float health;
    float maxHealth;
    EntityType type;
    float radius;
    Color color;
};

struct WorldSnapshotPacket : PacketHeader {
    uint32_t entityCount;
};


struct InitPacket : PacketHeader {
    uint32_t yourPlayerId;
};


enum class GameEvent : uint8_t {
    BULLET_HIT,
    PLAYER_DEATH
};

struct EventPacket : PacketHeader {
    GameEvent eventId;
    Vector2 position;
};
// engine\CMakeLists.txt
﻿#Engine module CMakeLists.txt
add_library(GameEngine SHARED
    Utils/ConfigManager.h
    Utils/ConfigManager.cpp
    ECS/GameObject.h
    ECS/Player.h
    ECS/Bullet.h
    Scenes/GameScene.h
    ServerHost.h
 "ServerHost.h"
 ServerHost.cpp
 "Utils/ConfigManager.h")
target_include_directories(GameEngine PUBLIC ${CHIPMUNK2D_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameEngine PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})

target_link_libraries(GameEngine PUBLIC chipmunk_static GameCommon enet::enet_shared raylib nlohmann_json)
target_include_directories(GameEngine PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

if(ANDROID)
    target_link_libraries(GameEngine PRIVATE log)
endif()
// engine\PhysicsUtils.h
﻿#pragma once
#include "raylib_compatibility.h"
#include "chipmunk/chipmunk.h"


// Конвертация Raylib Vector2 -> Chipmunk cpVect
inline cpVect ToCp(Vector2 v) {
    return cpv(v.x, v.y);
}

// Конвертация Chipmunk cpVect -> Raylib Vector2
inline Vector2 ToRay(cpVect v) {
    return Vector2{ (float)v.x, (float)v.y };
}
// engine\raylib_compatibility.h
﻿// raylib_compatibility.h
#pragma once

#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "raylib.h"
// engine\ServerHost.cpp
﻿#define _CRT_SECURE_NO_WARNINGS
#include "ServerHost.h"
#include <iostream>

ServerHost::ServerHost() : running(false) {}

ServerHost::~ServerHost() {
    Stop();
}

bool ServerHost::Start(int port) {
    if (running) return false;

    ENetAddress address;
    address.host = ENET_HOST_ANY;
    address.port = port;

    server = enet_host_create(&address, 32, 2, 0, 0);
    if (!server) {
        std::cerr << "An error occurred while trying to create an ENet server host.\n";
        return false;
    }

    running = true;
    // Запускаем цикл в отдельном потоке
    serverThread = std::thread(&ServerHost::ServerLoop, this);
    return true;
}

void ServerHost::Stop() {
    running = false;
    if (serverThread.joinable()) {
        serverThread.join();
    }
    if (server) {
        enet_host_destroy(server);
        server = nullptr;
    }
}

void ServerHost::ServerLoop() {
    std::cout << "Server started loop.\n";
    const double dt = 1.0 / 60.0;
    double accumulator = 0.0;
    double lastTime = GetTime();

    while (running) {
        double currentTime = GetTime();
        double frameTime = currentTime - lastTime;
        lastTime = currentTime;
        accumulator += frameTime;

        ENetEvent event;
        while (enet_host_service(server, &event, 0) > 0) {
            switch (event.type) {
            case ENET_EVENT_TYPE_CONNECT: {
                std::cout << "A new client connected from...\n";// << event.peer->address.host.u.Word << ":" << event.peer->address.port << ".\n";

                auto player = gameScene.CreatePlayer();

                event.peer->data = (void*)(uintptr_t)player->id;

                InitPacket initPkt;
                initPkt.type = PacketType::server_INIT;
                initPkt.yourPlayerId = player->id;

                ENetPacket* packet = enet_packet_create(&initPkt, sizeof(InitPacket), ENET_PACKET_FLAG_RELIABLE);
                enet_peer_send(event.peer, 0, packet);
                break;
            }
            case ENET_EVENT_TYPE_RECEIVE: {
                PacketHeader* header = (PacketHeader*)event.packet->data;
                if (header->type == PacketType::client_INPUT) {
                    PlayerInputPacket* input = (PlayerInputPacket*)event.packet->data;
                    uint32_t playerId = (uint32_t)(uintptr_t)event.peer->data;

                    if (gameScene.objects.count(playerId)) {
                        auto p = std::dynamic_pointer_cast<Player>(gameScene.objects[playerId]);
                        if (p) {
                            p->ApplyInput(input->movement);
                            p->aimTarget = input->aimTarget;
                            p->wantsToShoot = input->isShooting;
                        }
                    }
                }
                enet_packet_destroy(event.packet);
                break;
            }
            case ENET_EVENT_TYPE_DISCONNECT:
                uint32_t playerId = (uint32_t)(uintptr_t)event.peer->data;
                gameScene.objects.erase(playerId);
                std::cout << "Client disconnected.\n";
            }
        }

        // Физический апдейт
        while (accumulator >= dt) {
            gameScene.Update((float)dt);
            accumulator -= dt;
        }

        // Рассылка снапшота (раз в 2 тика, например, или каждый тик)
        static double snapshotTimer = 0;
        snapshotTimer += frameTime;
        if (snapshotTimer > 0.05) { // 20 раз в секунду
            snapshotTimer = 0;
            auto data = gameScene.SerializeSnapshot();

            ENetPacket* packet = enet_packet_create(data.data(), data.size(), ENET_PACKET_FLAG_UNSEQUENCED);
            enet_host_broadcast(server, 1, packet);
        }

        // Небольшой sleep, чтобы не грузить CPU на 100% в пустом цикле
        WaitTime(0.001);
    }
}
// engine\ServerHost.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include <enet.h>

#include <thread>
#include <atomic>
#include "Scenes/GameScene.h"

class ServerHost {
    ENetHost* server = nullptr;
    GameScene gameScene;
    std::atomic<bool> running;
    std::thread serverThread;

public:
    ServerHost();
    ~ServerHost();

    bool Start(int port);
    void Stop();

    void ServerLoop();
};
// engine\ECS\Bullet.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"

class Bullet : public GameObject {
public:
    uint32_t ownerId;
    float lifeTime = 2.0f;

    Bullet(uint32_t id, Vector2 pos, Vector2 dir, uint32_t owner, cpSpace* space)
        : GameObject(id, EntityType::BULLET), ownerId(owner)
    {
        spaceRef = space;
        color = BLACK;
        float moveSpeed = 600.0f;

        cpFloat radius = 5.0;
        cpFloat mass = 1.0;
        // Пуля - кинематический или легкий динамический объект
        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);

        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(pos));

        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetElasticity(shape, 0.8);
        cpShapeSetCollisionType(shape, COLLISION_BULLET);
        cpShapeSetUserData(shape, (void*)this);

        // Задаем скорость
        Vector2 normDir = Vector2Normalize(dir);
        cpBodySetVelocity(body, cpv(normDir.x * moveSpeed, normDir.y * moveSpeed));
    }

    void Update(float dt) override {
        lifeTime -= dt;
        if (lifeTime <= 0) destroyFlag = true;
    }
};
// engine\ECS\GameObject.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif
#include "raylib.h"
#include "chipmunk/chipmunk.h"
#include "../../common/NetworkPackets.h"

// Определяем типы коллизий для фильтрации (понадобится в будущем)
enum CollisionType {
    COLLISION_PLAYER = 1,
    COLLISION_BULLET = 2,
    COLLISION_WALL = 3
};

class GameObject {
public:
    uint32_t id;
    EntityType type;

    // Ссылки на физические объекты
    cpBody* body = nullptr;
    cpShape* shape = nullptr;
    cpSpace* spaceRef = nullptr; // Ссылка на мир для очистки

    bool destroyFlag = false;
    Color color = RED;
    float rotation = 0.0f;
    float health = 100.0f;
    float maxHealth = 100.0f;

    GameObject(uint32_t _id, EntityType _type) : id(_id), type(_type) {}

    virtual ~GameObject() {
        if (spaceRef) {
            if (shape) {
                cpSpaceRemoveShape(spaceRef, shape);
                cpShapeFree(shape);
            }
            if (body) {
                cpSpaceRemoveBody(spaceRef, body);
                cpBodyFree(body);
            }
        }
    }

    virtual void Update(float dt) = 0;
};
// engine\ECS\Player.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"

class Player : public GameObject {
public:
    float speed = 200.0f; // Сила/Скорость движения
    float shootCooldown = 0.0f;
    const float FIRE_RATE = 0.2f;

    bool wantsToShoot = false;
    Vector2 aimTarget = { 0,0 };
    bool spawnBulletSignal = false;
    Vector2 bulletDir = { 0,0 };

    Player(uint32_t id, Vector2 startPos, cpSpace* space) : GameObject(id, EntityType::PLAYER) {
        spaceRef = space;
        color = BLUE;

        // 1. Создаем тело (масса 10, инерция для круга)
        cpFloat radius = 20.0;
        cpFloat mass = 10.0;
        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);

        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(startPos));

        // Отключаем вращение от коллизий (бесконечная инерция)
        cpBodySetMoment(body, INFINITY);

        // 2. Создаем форму (коллизию)
        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetFriction(shape, 0.7);
        cpShapeSetElasticity(shape, 0.1); // Упругость
        cpShapeSetCollisionType(shape, COLLISION_PLAYER);

        // Pointer на самого себя для логики коллизий
        cpShapeSetUserData(shape, (void*)this);
    }

    void Update(float dt) override {
        if (shootCooldown > 0) shootCooldown -= dt;

        // Позиция для стрельбы и камеры
        Vector2 pos = ToRay(cpBodyGetPosition(body));

        if (wantsToShoot && shootCooldown <= 0) {
            shootCooldown = FIRE_RATE;
            spawnBulletSignal = true;
            bulletDir = Vector2Subtract(aimTarget, pos);
        }

        // Вычисляем угол поворота (визуально)
        Vector2 diff = Vector2Subtract(aimTarget, pos);
        rotation = atan2(diff.y, diff.x) * RAD2DEG;

        // Передаем угол в физику (хоть она и не вращается от ударов)
        cpBodySetAngle(body, atan2(diff.y, diff.x));

        // Линейное затухание (трение о воздух/землю)
        // В Chipmunk это делается через damping space, но можно и вручную:
        cpVect vel = cpBodyGetVelocity(body);
        cpBodySetVelocity(body, cpvmult(vel, 0.90f)); // Торможение
    }

    void ApplyInput(Vector2 move) {
        if (body) {
            // Прямая установка скорости для четкого управления
            // (или можно использовать forces для "ледяного" управления)
            cpBodySetVelocity(body, cpv(move.x * speed, move.y * speed));
        }
    }
};
// engine\Scenes\GameScene.h
﻿#pragma once
#include <vector>
#include <memory>
#include <map>
#include <algorithm>
#include "../ECS/Player.h"
#include "../ECS/Bullet.h"
#include "../PhysicsUtils.h"

class GameScene {
public:
    cpSpace* space;
    std::map<uint32_t, std::shared_ptr<GameObject>> objects;
    uint32_t nextId = 1;
    float width = 2000;
    float height = 2000;

    GameScene() {
        space = cpSpaceNew();
        // Гравитации нет
        cpSpaceSetGravity(space, cpv(0, 0));

        CreateMapBoundaries();
    }

    ~GameScene() {
        // Сначала очищаем объекты (их деструкторы удалят тела из space)
        objects.clear();
        // Потом удаляем space
        cpSpaceFree(space);
    }

    void CreateMapBoundaries() {
        // Статическое тело для стен (не добавляем его в space, только shape)
        cpBody* staticBody = cpSpaceGetStaticBody(space);

        float w = width;
        float h = height;
        float thick = 20.0f;

        // 4 Стены (Segment Shapes)
        auto addWall = [&](Vector2 a, Vector2 b) {
            cpShape* wall = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, ToCp(a), ToCp(b), thick));
            cpShapeSetElasticity(wall, 0.5f);
            cpShapeSetFriction(wall, 1.0f);
            cpShapeSetCollisionType(wall, COLLISION_WALL);
            };

        addWall({ 0,0 }, { w, 0 });      // Top
        addWall({ 0,h }, { w, h });      // Bottom
        addWall({ 0,0 }, { 0, h });      // Left
        addWall({ w,0 }, { w, h });      // Right
    }

    std::shared_ptr<Player> CreatePlayer() {
        Vector2 startPos = { width / 2, height / 2 };
        auto p = std::make_shared<Player>(nextId++, startPos, space);
        objects[p->id] = p;
        return p;
    }

    void Update(float dt) {
        // Шаг физики (фиксированный шаг для стабильности)
        cpSpaceStep(space, dt);

        // Логика объектов и спавн пуль
        std::vector<std::shared_ptr<Bullet>> newBullets;

        for (auto it = objects.begin(); it != objects.end();) {
            auto& obj = it->second;
            obj->Update(dt);

            if (obj->type == EntityType::PLAYER) {
                auto p = std::dynamic_pointer_cast<Player>(obj);
                if (p && p->spawnBulletSignal) {
                    p->spawnBulletSignal = false;
                    Vector2 spawnPos = ToRay(cpBodyGetPosition(p->body));
                    auto b = std::make_shared<Bullet>(nextId++, spawnPos, p->bulletDir, p->id, space);
                    newBullets.push_back(b);
                }
            }

            if (obj->destroyFlag) {
                it = objects.erase(it); // Деструктор GameObject очистит Chipmunk ресурсы
            }
            else {
                ++it;
            }
        }

        for (auto& b : newBullets) objects[b->id] = b;

        // Обработка урона (Manual Query)
        // Chipmunk имеет систему коллбеков, но для совместимости с вашей логикой
        // сделаем простую проверку расстояний, но физика отталкивания будет от Chipmunk.
        HandleDamageManual();
    }

    void HandleDamageManual() {
        for (auto& [bid, bObj] : objects) {
            if (bObj->type != EntityType::BULLET) continue;
            auto bullet = std::dynamic_pointer_cast<Bullet>(bObj);

            Vector2 bPos = ToRay(cpBodyGetPosition(bullet->body));

            for (auto& [pid, pObj] : objects) {
                if (pObj->type != EntityType::PLAYER) continue;
                if (pid == bullet->ownerId) continue;

                Vector2 pPos = ToRay(cpBodyGetPosition(pObj->body));

                // Простая проверка радиуса (20 танк + 5 пуля)
                if (Vector2Distance(bPos, pPos) < 25.0f) {
                    pObj->health -= 10;
                    bullet->destroyFlag = true;

                    if (pObj->health <= 0) {
                        // Respawn
                        pObj->health = 100;
                        cpVect randPos = cpv(GetRandomValue(100, (int)width - 100), GetRandomValue(100, (int)height - 100));
                        cpBodySetPosition(pObj->body, randPos);
                        cpBodySetVelocity(pObj->body, cpvzero);
                    }
                }
            }
        }
    }

    std::vector<uint8_t> SerializeSnapshot() {
        size_t size = sizeof(WorldSnapshotPacket) + (objects.size() * sizeof(EntityState));
        std::vector<uint8_t> buffer(size);

        WorldSnapshotPacket* header = (WorldSnapshotPacket*)buffer.data();
        header->type = PacketType::server_SNAPSHOT;
        header->entityCount = (uint32_t)objects.size();

        EntityState* states = (EntityState*)(buffer.data() + sizeof(WorldSnapshotPacket));
        int i = 0;
        for (auto& [id, obj] : objects) {
            states[i].id = obj->id;

            // Берем координаты из Chipmunk
            if (obj->body) {
                states[i].position = ToRay(cpBodyGetPosition(obj->body));
                states[i].rotation = (float)cpBodyGetAngle(obj->body) * RAD2DEG;
            }

            states[i].health = obj->health;
            states[i].maxHealth = obj->maxHealth;
            states[i].type = obj->type;
            states[i].radius = (obj->type == EntityType::BULLET) ? 5.0f : 20.0f;
            states[i].color = obj->color;
            i++;
        }
        return buffer;
    }
};
// engine\Scenes\Scene.h
﻿#pragma once

#include "raylib.h"
#include <vector>
#include <cstdint>

class GameClient;

class Scene {
protected:
    GameClient* game;

public:
    Scene(GameClient* _game) : game(_game) {}
    virtual ~Scene() = default;

    virtual void Enter() = 0;
    virtual void Update(float dt) = 0;
    virtual void Draw() = 0;
    virtual void DrawGUI() = 0;
    virtual void Exit() = 0;
    virtual void OnPacketReceived(const uint8_t* data, size_t size) {};
};
// engine\Utils\ConfigManager.cpp
﻿#include "ConfigManager.h"

GameConfig ConfigManager::config;
std::string ConfigManager::configPath;
Font ConfigManager::mainFont = { 0 };
std::map<std::string, std::string> ConfigManager::localizedStrings;

void ConfigManager::Initialize(const std::string& savePath) {
    if (!std::filesystem::exists(savePath)) {
        try { std::filesystem::create_directories(savePath); }
        catch (const std::exception& e) { std::cerr << e.what() << std::endl; }
    }

    configPath = savePath + "config.json";
    Load();
    LoadFonts();
    LoadLanguage(config.client.language);
}

void ConfigManager::CreateDefaultConfig() {
    std::cout << "Creating default config..." << std::endl;
    config.client.playerName = "Rookie";
    config.client.lastIp = "127.0.0.1";
    config.client.language = "ru";
    config.server.port = 7777;
    Save();
}

void ConfigManager::Save() {
    json j;
    j["client"] = {
        {"playerName", config.client.playerName},
        {"lastIp", config.client.lastIp},
        {"language", config.client.language},
        {"masterVolume", config.client.masterVolume},
        {"musicVolume", config.client.musicVolume},
        {"fullscreen", config.client.fullscreen},
        {"targetFPS", config.client.targetFPS}
    };
    j["server"] = {
        {"port", config.server.port},
        {"maxPlayers", config.server.maxPlayers}
    };

    std::ofstream file(configPath);
    if (file.is_open()) file << j.dump(4);
}

void ConfigManager::Load() {
    if (!std::filesystem::exists(configPath)) { CreateDefaultConfig(); return; }
    std::ifstream file(configPath);
    if (file.is_open()) {
        try {
            json j = json::parse(file);
            if (j.contains("client")) {
                auto& c = j["client"];
                config.client.playerName = c.value("playerName", "Player");
                config.client.lastIp = c.value("lastIp", "127.0.0.1");
                config.client.language = c.value("language", "ru");
                config.client.targetFPS = c.value("targetFPS", 60);
                config.client.fullscreen = c.value("fullscreen", false);
            }
            if (j.contains("server")) {
                auto& s = j["server"];
                config.server.port = s.value("port", 7777);
            }
        }
        catch (...) { CreateDefaultConfig(); }
    }
}

void ConfigManager::LoadFonts() {
    int codepoints[512] = { 0 };
    for (int i = 0; i < 95; i++) codepoints[i] = 32 + i;
    for (int i = 0; i < 255; i++) codepoints[96 + i] = 0x400 + i;

    const char* fontPath = "assets/fonts/Roboto-Regular.ttf";
    if (FileExists(fontPath)) {
#ifdef ANDROID
        mainFont = LoadFontEx(fontPath, 60, codepoints, 512);
#else
        mainFont = LoadFontEx(fontPath, 32, codepoints, 512);

#endif // ANDROID
    }
    else {
        mainFont = GetFontDefault();
    }
}

void ConfigManager::UnloadResources() {
    if (mainFont.texture.id != 0) UnloadFont(mainFont);
}

void ConfigManager::LoadLanguage(const std::string& langCode) {
    localizedStrings.clear();
    std::string path = "assets/lang/lang_" + langCode + ".json";

    char* text = LoadFileText(path.c_str());
    if (text) {
        try {
            json j = json::parse(text);
            for (auto& element : j.items()) {
                localizedStrings[element.key()] = element.value().get<std::string>();
            }
        }
        catch (...) { std::cerr << "Lang parse error\n"; }
        UnloadFileText(text);
    }
    else {
        std::cerr << "Lang file not found: " << path << std::endl;
    }
}

const char* ConfigManager::Text(const std::string& key) {
    if (localizedStrings.count(key)) return localizedStrings[key].c_str();
    return key.c_str();
}

ClientConfig& ConfigManager::GetClient() {
    return config.client;
}

ServerConfig& ConfigManager::GetServer() {
    return config.server;
}

Font ConfigManager::GetFont() {
    return mainFont;
}

void ConfigManager::SetFont(Font font)
{
    mainFont = font;
}
// engine\Utils\ConfigManager.h
﻿#pragma once
#include <string>
#include <fstream>
#include <filesystem>
#include <iostream>
#include <map>
#include "raylib.h"
#include "nlohmann/json.hpp"

using json = nlohmann::json;

struct ClientConfig {
    std::string playerName = "Player";
    std::string lastIp = "127.0.0.1";
    std::string language = "ru";
    float masterVolume = 1.0f;
    float musicVolume = 0.7f;
    float sfxVolume = 0.8f;
    bool fullscreen = false;
    int targetFPS = 60;
    int lastPort = 7777;
};

struct ServerConfig {
    int port = 7777;
    int maxPlayers = 8;
    int tickRate = 60;
    std::string serverName = "Void Assault Server";
    std::string password = "";
};

struct GameConfig {
    ClientConfig client;
    ServerConfig server;
};

class ConfigManager {
private:
    static GameConfig config;
    static std::string configPath;
    static Font mainFont;
    static std::map<std::string, std::string> localizedStrings;

    static void CreateDefaultConfig();

public:
    static void Initialize(const std::string& savePath);

    static void Save();
    static void Load();


    static void LoadLanguage(const std::string& langCode);
    static const char* Text(const std::string& key);


    static ClientConfig& GetClient();
    static ServerConfig& GetServer();

    static void LoadFonts();
    static Font GetFont();
    static void SetFont(Font font);
    static void UnloadResources();
};
// server\CMakeLists.txt
﻿#server module CMakeLists.txt
add_executable(GameServer
    main_server.cpp
)
target_include_directories(GameServer PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_link_libraries(GameServer PRIVATE GameEngine GameCommon enet::enet_shared)

// server\main_server.cpp
﻿#include "../engine/ServerHost.h"
#include <iostream>
#include <string>

int main() {
    if (enet_initialize() != 0) {
        std::cerr << "An error occurred while initializing ENet.\n";
        return 1;
    }
//    std::string configPath = "./";
//
//#if defined(ANDROID) || defined(PLATFORM_ANDROID)
//
//    configPath = GetApplicationDirectory();
//#endif
//
//    ConfigManager::Initialize(configPath);
    InitWindow(100, 100, "ServerHeadless");
    SetWindowState(FLAG_WINDOW_HIDDEN);

    ServerHost server;
    if (server.Start(7777)) {
        std::cout << "Dedicated Server started on port 7777. Type 'quit' to stop.\n";

        std::string cmd;
        while (std::cin >> cmd) {
            if (cmd == "quit") break;
        }

        server.Stop();
    }

    CloseWindow();
    enet_deinitialize();
    return 0;
}