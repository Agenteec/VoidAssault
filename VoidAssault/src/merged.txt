
// merged.txt

// reader.py
import os

def merge_files(root_dir, output_file, extensions=None):
    """
    Рекурсивно считывает все файлы из root_dir и записывает в один файл.
    Перед каждым файлом вставляется комментарий с его путём.
    extensions — список расширений, если нужно фильтровать (например ['.h', '.cpp'])
    Если extensions=None — берутся все файлы.
    """
    with open(output_file, "w", encoding="utf-8") as out:
        for folder, _, files in os.walk(root_dir):
            for file in files:
                file_path = os.path.join(folder, file)
                rel_path = os.path.relpath(file_path, root_dir)
                
                # Фильтр по расширениям, если нужно
                if extensions is not None:
                    _, ext = os.path.splitext(file)
                    if ext.lower() not in extensions:
                        continue

                out.write(f"\n// {rel_path}\n")

                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        out.write(f.read())
                except Exception as e:
                    out.write(f"[Ошибка при чтении файла: {e}]\n")


if __name__ == "__main__":
    merge_files(
        root_dir=".", 
        output_file="merged.txt",
        extensions=None 
    )

// client\AudioManager.h
﻿#pragma once
#include "raylib.h"
#include <map>
#include <string>
#include <iostream>

class AudioManager {
    std::map<std::string, Sound> sounds;
    std::map<std::string, Music> musics;
    float masterVolume = 1.0f;

public:
    AudioManager() {
        InitAudioDevice();
    }

    ~AudioManager() {
        for (auto& s : sounds) UnloadSound(s.second);
        for (auto& m : musics) UnloadMusicStream(m.second);
        CloseAudioDevice();
    }

    void LoadSnd(const std::string& key, const std::string& path) {
        Sound s = LoadSound(path.c_str());
        if (s.frameCount > 0) sounds[key] = s;
        else std::cout << "Failed to load sound: " << path << std::endl;
    }

    void LoadMus(const std::string& key, const std::string& path) {
        Music m = LoadMusicStream(path.c_str());
        if (m.frameCount > 0) musics[key] = m;
    }

    void PlaySnd(const std::string& key) {
        if (sounds.count(key)) {
            SetSoundVolume(sounds[key], masterVolume);
            PlaySound(sounds[key]);
        }
    }

    void PlayMus(const std::string& key) {
        if (musics.count(key)) {
            if (!IsMusicStreamPlaying(musics[key])) PlayMusicStream(musics[key]);
            SetMusicVolume(musics[key], masterVolume);
            UpdateMusicStream(musics[key]);
        }
    }

    void Update() {
        for (auto& pair : musics) {
            if (IsMusicStreamPlaying(pair.second)) UpdateMusicStream(pair.second);
        }
    }

    void SetVolume(float vol) { masterVolume = vol; }
    float GetVolume() const { return masterVolume; }
};
// client\CMakeLists.txt
﻿    file(GLOB CLIENT_SOURCES "*.cpp" "scenes/*.cpp" "vircontrols/*.cpp")
#file(GLOB_RECURSE Imgui_SFML_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/../imgui-sfml/*.*")
if(WIN32 OR CMAKE_SYSTEM_NAME STREQUAL "Linux" OR LINUX)

    add_executable(GameClient
        ${CLIENT_SOURCES}
    )

    #if(WIN32)
      #  set_target_properties(GameClient PROPERTIES WIN32_EXECUTABLE ON)
    #endif()

    target_link_libraries(GameClient PRIVATE raylib GameEngine GameCommon enet::enet_shared nlohmann_json Bitsery::bitsery)

    target_include_directories(GameClient PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
    target_include_directories(GameClient PRIVATE ${PROJECT_INCLUDE_DIR})
    target_include_directories(GameClient PRIVATE ${ENET_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PRIVATE ${RAYGUI_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PUBLIC ${BITSERY_EXTERNAL_INCLUDE_DIR})
    file(COPY ${CMAKE_SOURCE_DIR}/assets DESTINATION ${GLOBAL_OUTPUT_DIR})

elseif(ANDROID)
    add_library(gameclient SHARED ${CLIENT_SOURCES})

    target_link_libraries(gameclient  PRIVATE android log
        raylib
    GameEngine 
    GameCommon
    enet::enet_shared
    chipmunk_static
    nlohmann_json
    Bitsery::bitsery)
    target_include_directories(gameclient PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
    target_include_directories(gameclient PRIVATE ${PROJECT_INCLUDE_DIR})
    target_include_directories(gameclient PRIVATE ${ENET_EXTERNAL_INCLUDE_DIR})
    target_include_directories(gameclient PRIVATE ${RAYGUI_EXTERNAL_INCLUDE_DIR})
    target_include_directories(gameclient PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
    target_include_directories(gameclient PUBLIC ${RAYMOB_EXTERNAL_INCLUDE_DIR})
    target_include_directories(gameclient PUBLIC ${BITSERY_EXTERNAL_INCLUDE_DIR})

target_include_directories(gameclient PUBLIC "${CMAKE_SOURCE_DIR}/external")
endif()






// client\GameClient.cpp
﻿#include "GameClient.h"
#include "scenes/MainMenuScene.h"
#include "scenes/GameplayScene.h"
#include "../engine/Utils/ConfigManager.h"
#include "Theme.h"

GameClient::GameClient() {
    ClientConfig& cfg = ConfigManager::GetClient();
    screenWidth = cfg.resolutionWidth;
    screenHeight = cfg.resolutionHeight;

#if defined(PLATFORM_ANDROID) || defined(ANDROID)
    InitWindow(0, 0, "Void Assault");
    screenWidth = GetScreenWidth();
    screenHeight = GetScreenHeight();
#else
    SetConfigFlags(FLAG_WINDOW_RESIZABLE);
    InitWindow(screenWidth, screenHeight, "Void Assault");
#endif

    SetTargetFPS(cfg.targetFPS);
    SetWindowMinSize(800, 600);

    netClient = ENetClient::alloc();

    float scale = GetUIScale();
    GuiSetStyle(DEFAULT, TEXT_SIZE, (int)(20 * scale));
}

GameClient::~GameClient() {
    StopHost();
    if (currentScene) currentScene->Exit();
    if (netClient) netClient->disconnect();
    CloseWindow();
}

void GameClient::ChangeScene(std::shared_ptr<Scene> newScene) {
    nextScene = newScene;
}

void GameClient::ReturnToMenu() {
    if (netClient) netClient->disconnect();
    ChangeScene(std::make_shared<MainMenuScene>(this));
}

int GameClient::StartHost(int startPort, bool publicServer) {
    StopHost();
    localServer = std::make_unique<ServerHost>();
    for (int p = startPort; p < startPort + 10; p++) {
                if (localServer->Start(p, publicServer)) {
            TraceLog(LOG_INFO, "Local Server Started on port %d", p);
            return p;
        }
    }
    TraceLog(LOG_ERROR, "Failed to start local server. All ports busy?");
    localServer.reset();
    return -1;
}

void GameClient::StopHost() {
    if (localServer) {
        localServer->Stop();
        localServer.reset();
        TraceLog(LOG_INFO, "Local Server Stopped.");
    }
}

float GameClient::GetUIScale() const {
    int h = GetScreenHeight();
    float scale = (float)h / 720.0f;
#if defined(PLATFORM_ANDROID) || defined(ANDROID)
    scale *= 1.1f;
#endif
    if (scale < 0.8f) scale = 0.8f;
    return scale;
}

void GameClient::Run() {
    ChangeScene(std::make_shared<MainMenuScene>(this));

    float inputSendTimer = 0.0f;
    const float inputSendInterval = 1.0f / 60.0f;
    while (!WindowShouldClose()) {
        if (nextScene) {
            if (currentScene) currentScene->Exit();
            currentScene = nextScene;
            currentScene->Enter();
            nextScene = nullptr;
        }
        float dt = GetFrameTime();

        if (netClient) {
            auto msgs = netClient->poll();

            for (auto& msg : msgs) {
                if (msg->type() == MessageType::CONNECT) {
                    TraceLog(LOG_INFO, ">> CLIENT: Connected to server!");
                    if (!std::dynamic_pointer_cast<GameplayScene>(currentScene)) {
                        ChangeScene(std::make_shared<GameplayScene>(this));
                    }
                }
                else if (msg->type() == MessageType::DISCONNECT) {
                    TraceLog(LOG_INFO, ">> CLIENT: Disconnected.");
                    if (std::dynamic_pointer_cast<GameplayScene>(currentScene)) {
                        ReturnToMenu();
                    }
                }
                else if (msg->type() == MessageType::DATA) {
                    if (currentScene) {
                        currentScene->OnMessage(msg);
                    }
                }
            }
        }

        if (currentScene) {
            currentScene->Update(dt);

            BeginDrawing();
            ClearBackground(Theme::COL_BACKGROUND);
            currentScene->Draw();
            currentScene->DrawGUI();
            EndDrawing();
        }
    }
}
// client\GameClient.h
﻿#pragma once
#include "raygui_wrapper.h"
#include "enet/ENetClient.h"
#include "../engine/Scenes/Scene.h"
#include "../engine/ServerHost.h"
#include "AudioManager.h"
#include <memory>
class Scene;
class GameClient {
public:
	int screenWidth = 1280;
	int screenHeight = 720;
	ENetClient::Shared netClient;
	std::unique_ptr<ServerHost> localServer;
	AudioManager audio;

	std::shared_ptr<Scene> currentScene;
	std::shared_ptr<Scene> nextScene;
	GameClient();
	~GameClient();

	void Run();
	void ChangeScene(std::shared_ptr<Scene> newScene);
	void ReturnToMenu();

	int StartHost(int port, bool publicServer);
	void StopHost();

	int GetWidth() const { return GetScreenWidth(); }
	int GetHeight() const { return GetScreenHeight(); }

	float GetUIScale() const;
};
// client\main_client.cpp
﻿#define RAYGUI_IMPLEMENTATION
#include "raygui_wrapper.h"
#include "GameClient.h"
#include "engine/Utils/ConfigManager.h"
#include <enet.h>
int* GetCompleteCodepoints(int* count) {
	static int completeChars[] = {
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029,
	0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, 0x0030, 0x0031, 0x0032, 0x0033,
	0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D,
	0x003E, 0x003F, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, 0x0050, 0x0051,
	0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B,
	0x005C, 0x005D, 0x005E, 0x005F, 0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065,
	0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079,
	0x007A, 0x007B, 0x007C, 0x007D, 0x007E,
	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419,
	0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F, 0x0420, 0x0421, 0x0422, 0x0423,
	0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D,
	0x042E, 0x042F, 0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
	0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F, 0x0440, 0x0441,
	0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044A, 0x044B,
	0x044C, 0x044D, 0x044E, 0x044F, 0x0401, 0x0451
	};
	*count = sizeof(completeChars) / sizeof(completeChars[0]);
	int* result = (int*)malloc(*count * sizeof(int));
	memcpy(result, completeChars, *count * sizeof(int));
	return result;
}
Font LoadFont() {
	int codepointCount = 0;
	int* completeCodepoints = GetCompleteCodepoints(&codepointCount);
	Font mainFont;
	mainFont = LoadFontEx("assets/fonts/Roboto-Regular.ttf", 64, completeCodepoints, codepointCount);
	GenTextureMipmaps(&mainFont.texture);
	SetTextureFilter(mainFont.texture, TEXTURE_FILTER_BILINEAR);

	GuiSetStyle(DEFAULT, TEXT_SIZE, 20);
	free(completeCodepoints);
	GuiSetFont(mainFont);
	return mainFont;
}
int main(int argc, char** argv){
	srand(time(NULL));
	if (enet_initialize() != 0) {
		return -1;
	}
	atexit(enet_deinitialize);

	{
		std::string configPath = "./";
#if defined(ANDROID) || defined(PLATFORM_ANDROID)
		configPath = GetApplicationDirectory();
#endif

		GameClient game;

		ConfigManager::Initialize(configPath);

		auto f = LoadFont();
		ConfigManager::SetFont(f);
		GuiSetFont(f);

		SetTargetFPS(ConfigManager::GetClient().targetFPS);
		if (ConfigManager::GetClient().fullscreen) {
			ToggleFullscreen();
		}

		game.Run();
	}

	return 0;
}
// client\ParticleSystem.h
﻿#pragma once
#include "raylib.h"
#include <vector>
#include <algorithm>

struct Particle {
    Vector2 position;
    Vector2 velocity;
    float life;
    float decayRate;
    float size;
    float rotation;
    float rotSpeed;
    Color color;
    int shapeType;
};

class ParticleSystem {
    std::vector<Particle> particles;

public:
    void Spawn(Vector2 pos, Vector2 vel, Color col, float size, float lifeTime) {
        Particle p;
        p.position = pos;
        p.velocity = vel;
        p.color = col;
        p.size = size;
        p.life = 1.0f;
        p.decayRate = 1.0f / lifeTime;
        p.rotation = (float)GetRandomValue(0, 360);
        p.rotSpeed = (float)GetRandomValue(-5, 5);
        p.shapeType = GetRandomValue(0, 2);
        particles.push_back(p);
    }

    void SpawnExplosion(Vector2 pos, int count, Color col) {
        for (int i = 0; i < count; i++) {
            float angle = (float)GetRandomValue(0, 360) * DEG2RAD;
            float speed = (float)GetRandomValue(50, 300) / 10.0f;
            Vector2 vel = { cosf(angle) * speed, sinf(angle) * speed };
            Spawn(pos, vel, col, (float)GetRandomValue(5, 12), 0.6f);
        }
    }

    void Update(float dt) {
        for (auto& p : particles) {
            p.position.x += p.velocity.x * dt * 60.0f;
            p.position.y += p.velocity.y * dt * 60.0f;
            p.life -= p.decayRate * dt;
            p.size *= 0.96f;
            p.rotation += p.rotSpeed;
        }

        particles.erase(
            std::remove_if(particles.begin(), particles.end(),
                [](const Particle& p) { return p.life <= 0; }),
            particles.end());
    }

    void Draw() {
        for (const auto& p : particles) {
            Color c = p.color;
            c.a = (unsigned char)(p.life * 255);

            if (p.shapeType == 1) {
                DrawPoly(p.position, 3, p.size, p.rotation, c);
            }
            else if (p.shapeType == 2) {
                DrawPoly(p.position, 4, p.size, p.rotation, c);
            }
            else {
                DrawCircleV(p.position, p.size * 0.8f, c);
            }
        }
    }
};
// client\raygui_wrapper.h
﻿// raygui_wrapper.h
#pragma once

#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "raylib.h"
#include "raygui.h"
// client\ResourceManager.h
﻿#pragma once
#include "raylib.h"
#include <vector>
#include <string>
#include "Theme.h"
class ResourceManager {
public:
    static ResourceManager& Get() {
        static ResourceManager instance;
        return instance;
    }
    void Load() {}

    void Unload() {}

    void UpdateBackground(float dt) {}

    void DrawBackground() {
        ClearBackground(Theme::COL_BACKGROUND);

        int w = GetScreenWidth();
        int h = GetScreenHeight();
        float scale = (float)h / 720.0f;
        int gridSize = (int)(50 * (scale < 1.0f ? 1.0f : scale));

        for (int i = 0; i < w; i += gridSize) DrawLine(i, 0, i, h, Theme::COL_ACCENT_DIM);
        for (int i = 0; i < h; i += gridSize) DrawLine(0, i, w, i, Theme::COL_ACCENT_DIM);
    }

    static void DrawSciFiPanel(Rectangle rect, const char* title, Font font) {
        DrawRectangleRec(rect, Theme::COL_PANEL);
        DrawRectangleLinesEx(rect, 2, Theme::COL_ACCENT_DIM);

        float minDim = (rect.width < rect.height) ? rect.width : rect.height;
        float lineLen = minDim * 0.1f;
        if (lineLen > 30.0f) lineLen = 30.0f;

        float lineThick = 3.0f;

        DrawLineEx({ rect.x, rect.y }, { rect.x + lineLen, rect.y }, lineThick, Theme::COL_ACCENT);
        DrawLineEx({ rect.x, rect.y }, { rect.x, rect.y + lineLen }, lineThick, Theme::COL_ACCENT);
        DrawLineEx({ rect.x + rect.width, rect.y + rect.height }, { rect.x + rect.width - lineLen, rect.y + rect.height }, lineThick, Theme::COL_ACCENT);
        DrawLineEx({ rect.x + rect.width, rect.y + rect.height }, { rect.x + rect.width, rect.y + rect.height - lineLen }, lineThick, Theme::COL_ACCENT);

        if (title) {
            float fontSize = rect.height * 0.08f;
            if (fontSize < 24.0f) fontSize = 24.0f;
            if (fontSize > 48.0f) fontSize = 48.0f;

            float spacing = 1.0f;
            Vector2 textSize = MeasureTextEx(font, title, fontSize, spacing);

            float labelPad = 10.0f;
            float labelX = rect.x + 20;
            float labelY = rect.y - (textSize.y / 2);
            float labelW = textSize.x + (labelPad * 2);
            float labelH = textSize.y;

            DrawRectangle(labelX - 2, labelY, labelW + 4, labelH, Theme::COL_BACKGROUND);
            DrawRectangleLines(labelX, labelY, labelW, labelH, Theme::COL_ACCENT_DIM);
            DrawTextEx(font, title, { labelX + labelPad, labelY }, fontSize, spacing, Theme::COL_ACCENT);
        }
    }
};
// client\SnapshotManager.h
﻿#pragma once
#include "common/NetworkPackets.h"
#include "raymath.h"
#include <deque>
#include <map>
#include <algorithm>
#include <cmath>

class SnapshotManager {
public:
    std::deque<WorldSnapshotPacket> history;


    const double INTERPOLATION_DELAY = 0.050;

    float LerpAngle(float start, float end, float amount) {
        float difference = std::abs(end - start);
        if (difference > 180.0f) {
            if (end > start) start += 360.0f;
            else end += 360.0f;
        }
        float value = start + ((end - start) * amount);
        if (value >= 0 && value <= 360) return value;
        return fmodf(value, 360.0f);
    }

    void PushSnapshot(const WorldSnapshotPacket& snap) {
        if (!history.empty() && snap.serverTime <= history.back().serverTime) {
            return;
        }

        history.push_back(snap);

        while (history.size() > 2 && history[0].serverTime < history.back().serverTime - 1.0) {
            history.pop_front();
        }
    }


    bool GetInterpolatedState(uint32_t entityId, double clientRenderTime, EntityState& outState) {
        if (history.empty()) return false;

        if (clientRenderTime < history.front().serverTime) {
            return FindEntityInSnapshot(history.front(), entityId, outState);
        }

        auto it = std::lower_bound(history.begin(), history.end(), clientRenderTime,
            [](const WorldSnapshotPacket& snap, double val) {
                return snap.serverTime < val;
            });

        if (it == history.begin()) {
            return FindEntityInSnapshot(history.front(), entityId, outState);
        }

        if (it == history.end()) {
            return FindEntityInSnapshot(history.back(), entityId, outState);
        }

        const auto& snapB = *it;
        const auto& snapA = *(--it);

        EntityState entA, entB;
        bool hasA = FindEntityInSnapshot(snapA, entityId, entA);
        bool hasB = FindEntityInSnapshot(snapB, entityId, entB);

        if (hasA && hasB) {
            double totalDt = snapB.serverTime - snapA.serverTime;
            double currentDt = clientRenderTime - snapA.serverTime;

            if (totalDt <= 0.000001) totalDt = 0.000001;

            float t = (float)(currentDt / totalDt);

            if (t < 0.0f) t = 0.0f;
            if (t > 1.0f) t = 1.0f;

            outState = entB;
            outState.position = Vector2Lerp(entA.position, entB.position, t);

            if (entB.type != EntityType::BULLET) {
                outState.rotation = LerpAngle(entA.rotation, entB.rotation, t);
            }
            return true;
        }

        if (hasB) {
            outState = entB;
            return true;
        }

        return false;
    }

private:
    bool FindEntityInSnapshot(const WorldSnapshotPacket& snap, uint32_t id, EntityState& out) {
        for (const auto& e : snap.entities) {
            if (e.id == id) {
                out = e;
                return true;
            }
        }
        return false;
    }
};
// client\Theme.h
﻿#pragma once
#include "raylib.h"
#include "raygui.h"

namespace Theme {

    static const Color COL_BACKGROUND = { 240, 240, 240, 255 };

    static const Color COL_GRID = { 205, 205, 205, 255 };

    static const Color COL_PANEL = { 255, 255, 255, 245 };
    static const Color COL_ACCENT = { 0, 178, 225, 255 };
    static const Color COL_ACCENT_DIM = { 200, 200, 210, 255 };
    static const Color COL_TEXT = { 40, 40, 50, 255 };
    static const Color COL_WARNING = { 230, 80, 80, 255 };

    static const Color COLOR_BLUE = { 0, 178, 225, 255 };
    static const Color COLOR_RED = { 241, 78, 84, 255 };
    static const Color COLOR_GREEN = { 0, 225, 110, 255 };
    static const Color COLOR_PURPLE = { 191, 127, 245, 255 };

    inline void ApplyTheme() {
        GuiSetStyle(DEFAULT, BACKGROUND_COLOR, 0xF5F5F5FF);
        GuiSetStyle(DEFAULT, LINE_COLOR, 0xC8C8D2FF);
        GuiSetStyle(DEFAULT, TEXT_COLOR_NORMAL, 0x282832FF);
        GuiSetStyle(DEFAULT, TEXT_COLOR_FOCUSED, 0x0078C8FF);
        GuiSetStyle(DEFAULT, TEXT_COLOR_PRESSED, 0x005A96FF);
        GuiSetStyle(DEFAULT, BASE_COLOR_NORMAL, 0xFFFFFFFF);
        GuiSetStyle(DEFAULT, BASE_COLOR_FOCUSED, 0xEBEBEBFF);
        GuiSetStyle(DEFAULT, BASE_COLOR_PRESSED, 0xDCDCDCFF);
        GuiSetStyle(DEFAULT, BORDER_WIDTH, 2);
    }
}
// client\scenes\GameplayScene.cpp
﻿#include "GameplayScene.h"
#include "GameClient.h"
#include "../engine/Utils/ConfigManager.h"
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
#include <vector>
#include <cmath>

static const Color COL_INV_EMPTY = { 0, 0, 0, 100 };
static const Color COL_INV_BORDER = { 150, 150, 150, 200 };

GameplayScene::GameplayScene(GameClient* g) : Scene(g) {
    myInventory.resize(6, 255);
}

void GameplayScene::Enter() {
    float w = (float)game->GetWidth();
    float h = (float)game->GetHeight();
    camera.zoom = 1.0f;
    camera.offset = { w / 2, h / 2 };

    myPlayerId = 0;
    isPredictedInit = false;
    predictedPos = { 0, 0 };

    myLevel = 1; myCurrentXp = 0.0f; myMaxXp = 100.0f;
    myMaxHealth = 100.0f; myScrap = 0;
    currentWave = 1; selectedBuildType = 0;
    std::fill(myInventory.begin(), myInventory.end(), 255);
    lastFrameEntityIds.clear(); gunAnimOffset = 0.0f;

#if defined(PLATFORM_ANDROID) || defined(ANDROID)
    float joyY = h - 180.0f; float joyOffset = 220.0f;
    leftStick = std::make_unique<VirtualJoystick>(Vector2{ joyOffset, joyY }, 60.0f, 120.0f);
    rightStick = std::make_unique<VirtualJoystick>(Vector2{ w - joyOffset, joyY }, 60.0f, 120.0f);
    rightStick->SetColors({ 200, 200, 200, 100 }, { 220, 50, 50, 200 });
#endif

    if (game->netClient && game->netClient->isConnected()) {
        Buffer buffer; OutputAdapter adapter(buffer);
        bitsery::Serializer<OutputAdapter> serializer(std::move(adapter));
        serializer.value1b(GamePacket::JOIN);
        JoinPacket jp; jp.name = ConfigManager::GetClient().playerName;
        serializer.object(jp);
        serializer.adapter().flush();
        game->netClient->send(DeliveryType::RELIABLE, StreamBuffer::alloc(buffer.data(), buffer.size()));
    }
}

void GameplayScene::Exit() {
    if (game->netClient) game->netClient->disconnect();
    game->StopHost();
}

void GameplayScene::SendAction(const ActionPacket& act) {
    if (game->netClient && game->netClient->isConnected()) {
        Buffer buffer; OutputAdapter adapter(buffer);
        bitsery::Serializer<OutputAdapter> serializer(std::move(adapter));
        serializer.value1b(GamePacket::ACTION);
        serializer.object(act);
        serializer.adapter().flush();
        game->netClient->send(DeliveryType::RELIABLE, StreamBuffer::alloc(buffer.data(), buffer.size()));
    }
}

void GameplayScene::SendAdminCmd(uint8_t cmd, uint32_t val) {
    if (game->netClient && game->netClient->isConnected()) {
        Buffer buffer; OutputAdapter adapter(buffer);
        bitsery::Serializer<OutputAdapter> serializer(std::move(adapter));
        serializer.value1b(GamePacket::ADMIN_CMD);
        AdminCommandPacket pkt = { cmd, val };
        serializer.object(pkt);
        serializer.adapter().flush();
        game->netClient->send(DeliveryType::RELIABLE, StreamBuffer::alloc(buffer.data(), buffer.size()));
    }
}

void GameplayScene::OnMessage(Message::Shared msg) {
    const auto& rawData = msg->stream()->buffer();
    size_t offset = msg->stream()->tellg();
    if (rawData.empty() || offset >= rawData.size()) return;

    InputAdapter adapter(rawData.begin() + offset, rawData.end());
    bitsery::Deserializer<InputAdapter> deserializer(std::move(adapter));

    uint8_t packetTypeInt = 0; deserializer.value1b(packetTypeInt);

    if (deserializer.adapter().error() != bitsery::ReaderError::NoError) return;

    if (packetTypeInt == GamePacket::INIT) {
        InitPacket pkt; deserializer.object(pkt);
        if (deserializer.adapter().error() == bitsery::ReaderError::NoError) myPlayerId = pkt.playerId;
    }
    else if (packetTypeInt == GamePacket::SNAPSHOT) {
        WorldSnapshotPacket snap; deserializer.object(snap);
        if (deserializer.adapter().error() == bitsery::ReaderError::NoError) {
            currentWave = snap.wave;
            snapshotManager.PushSnapshot(snap);
            lastServerTime = snap.serverTime;
            for (const auto& ent : snap.entities) {
                if (ent.id == myPlayerId) {
                    if (!isPredictedInit) { predictedPos = ent.position; isPredictedInit = true; }
                    else {
                        float dist = Vector2Distance(predictedPos, ent.position);
                        if (dist > 150.0f) predictedPos = ent.position;
                        else predictedPos = Vector2Lerp(predictedPos, ent.position, 0.1f);
                    }
                    myHealth = ent.health;
                    break;
                }
            }
        }
    }
    else if (packetTypeInt == GamePacket::STATS) {
        PlayerStatsPacket stats; deserializer.object(stats);
        if (deserializer.adapter().error() == bitsery::ReaderError::NoError) {
            myLevel = stats.level; myCurrentXp = stats.currentXp; myMaxXp = stats.maxXp;
            myMaxHealth = stats.maxHealth; myDamage = stats.damage; mySpeed = stats.speed;
            myScrap = stats.scrap; myKills = stats.kills;
            if (stats.inventory.size() == 6) myInventory = stats.inventory;
            isAdmin = stats.isAdmin;
        }
    }
    else if (packetTypeInt == GamePacket::EVENT) {
        EventPacket evt; deserializer.object(evt);
        if (deserializer.adapter().error() == bitsery::ReaderError::NoError) {
            if (evt.type == 0) particles.SpawnExplosion(evt.pos, 4, evt.color);             else if (evt.type == 1) particles.SpawnExplosion(evt.pos, 20, evt.color);             else if (evt.type == 2) {
                                particles.SpawnExplosion(evt.pos, 15, evt.color);
                                for (int i = 0; i < 360; i += 20) {
                    float ang = i * DEG2RAD;
                    Vector2 vel = { cosf(ang) * 100.0f, sinf(ang) * 100.0f };
                    particles.Spawn(evt.pos, vel, evt.color, 4.0f, 0.5f);
                }
            }
        }
    }
}

void GameplayScene::Update(float dt) {
    if (gunAnimOffset > 0.0f) gunAnimOffset -= dt * 60.0f;
    particles.Update(dt);

    clientTime += dt;
    if (abs(clientTime - lastServerTime) > 2.0) clientTime = lastServerTime;
    else clientTime = Lerp((float)clientTime, (float)lastServerTime, 0.05f);

    PlayerInputPacket pkt = {};
    pkt.movement = { 0, 0 }; pkt.aimTarget = { 0, 0 }; pkt.isShooting = false;

    float currentSpeed = (mySpeed > 0) ? mySpeed : 220.0f;
    const float MAP_SIZE = 4000.0f;
    float myRadius = 20.0f + (myLevel - 1) * 2.0f;

#if defined(PLATFORM_ANDROID) || defined(ANDROID)
    if (leftStick && rightStick) {
        leftStick->Update(); rightStick->Update();
        pkt.movement = leftStick->GetAxis();

        Vector2 aimDir = rightStick->GetAxis();

        if (selectedBuildType != 0) {
            Vector2 offset = { 100, 0 };
            if (Vector2Length(aimDir) > 0.1f) offset = Vector2Scale(aimDir, 300.0f);
            pkt.aimTarget = Vector2Add(predictedPos, offset);
            pkt.isShooting = false;
        }
        else {
            if (Vector2Length(aimDir) > 0.1f) {
                pkt.isShooting = true;
                pkt.aimTarget = Vector2Add(predictedPos, Vector2Scale(aimDir, 300.0f));
                predictedRot = atan2f(aimDir.y, aimDir.x) * RAD2DEG;
            }
            else {
                pkt.aimTarget = Vector2Add(predictedPos, { 300, 0 });
            }
        }
    }
#else
    if (IsKeyDown(KEY_W)) pkt.movement.y -= 1.0f;
    if (IsKeyDown(KEY_S)) pkt.movement.y += 1.0f;
    if (IsKeyDown(KEY_A)) pkt.movement.x -= 1.0f;
    if (IsKeyDown(KEY_D)) pkt.movement.x += 1.0f;
    if (Vector2Length(pkt.movement) > 1.0f) pkt.movement = Vector2Normalize(pkt.movement);

    pkt.aimTarget = GetScreenToWorld2D(GetMousePosition(), camera);

    if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {
        if (selectedBuildType != 0) {
            ActionPacket act; act.type = selectedBuildType; act.target = pkt.aimTarget;
            SendAction(act);
            if (!IsKeyDown(KEY_LEFT_SHIFT)) selectedBuildType = 0;
        }
        else {
            ActionPacket act; act.type = ActionType::UPGRADE_BUILDING; act.target = pkt.aimTarget;
            SendAction(act);
        }
    }

    if (IsKeyPressed(KEY_F1) && isAdmin) showAdminPanel = !showAdminPanel;
    if (IsKeyPressed(KEY_TAB)) showLeaderboard = !showLeaderboard;

    if (IsMouseButtonDown(MOUSE_LEFT_BUTTON) && selectedBuildType == 0) {
        if (GetMouseX() > 300 || GetMouseY() < GetScreenHeight() - 200)
            pkt.isShooting = true;
    }
    if (IsMouseButtonPressed(MOUSE_RIGHT_BUTTON)) selectedBuildType = 0;

    Vector2 diff = Vector2Subtract(pkt.aimTarget, predictedPos);
    predictedRot = atan2f(diff.y, diff.x) * RAD2DEG;
#endif

    if (pkt.isShooting && gunAnimOffset <= 1.0f) gunAnimOffset = 12.0f;

    if (isPredictedInit) {
        Vector2 velocity = Vector2Scale(pkt.movement, currentSpeed * dt);
        Vector2 nextPos = Vector2Add(predictedPos, velocity);
        if (nextPos.x < myRadius) nextPos.x = myRadius;
        if (nextPos.y < myRadius) nextPos.y = myRadius;
        if (nextPos.x > MAP_SIZE - myRadius) nextPos.x = MAP_SIZE - myRadius;
        if (nextPos.y > MAP_SIZE - myRadius) nextPos.y = MAP_SIZE - myRadius;
        predictedPos = nextPos;
        camera.target = Vector2Lerp(camera.target, predictedPos, 0.1f);
    }

    if (game->netClient && game->netClient->isConnected()) {
        Buffer buffer; OutputAdapter adapter(buffer); bitsery::Serializer<OutputAdapter> serializer(std::move(adapter));
        serializer.value1b(GamePacket::INPUT); serializer.object(pkt); serializer.adapter().flush();
        game->netClient->send(DeliveryType::UNRELIABLE, StreamBuffer::alloc(buffer.data(), buffer.size()));
    }
}

void GameplayScene::Draw() {
    BeginMode2D(camera);
    ClearBackground(Theme::COL_BACKGROUND);
    int gridW = 4000; int gridH = 4000;
    DrawRectangleLines(0, 0, gridW, gridH, GRAY);
    for (int i = 0; i <= gridW; i += 50) DrawLine(i, 0, i, gridH, Fade(Theme::COL_GRID, 0.3f));
    for (int i = 0; i <= gridH; i += 50) DrawLine(0, i, gridW, i, Fade(Theme::COL_GRID, 0.3f));

    auto DrawDiepTank = [&](Vector2 pos, float rot, Color mainCol, float radius, float hp, float maxHp, bool isMe, const std::string& name) {
        Color outlineCol = { 85, 85, 85, 255 };
        float outlineThick = 3.0f;
        Vector2 dir = { cosf(rot * DEG2RAD), sinf(rot * DEG2RAD) };
        float currentLen = isMe ? (radius * 1.8f - gunAnimOffset) : radius * 1.8f;
        float barrelWidth = radius * 0.8f;
        Vector2 bEnd = Vector2Add(pos, Vector2Scale(dir, currentLen));
        Vector2 perp = { -dir.y, dir.x };
        Vector2 c1 = Vector2Add(pos, Vector2Scale(perp, barrelWidth * 0.5f));
        Vector2 c2 = Vector2Subtract(pos, Vector2Scale(perp, barrelWidth * 0.5f));
        Vector2 c3 = Vector2Subtract(bEnd, Vector2Scale(perp, barrelWidth * 0.5f));
        Vector2 c4 = Vector2Add(bEnd, Vector2Scale(perp, barrelWidth * 0.5f));
        DrawLineEx(c1, c4, outlineThick * 2, outlineCol); DrawLineEx(c2, c3, outlineThick * 2, outlineCol); DrawLineEx(c4, c3, outlineThick * 2, outlineCol);
        DrawTriangle(c1, c2, c4, LIGHTGRAY); DrawTriangle(c2, c3, c4, LIGHTGRAY);
        DrawCircleV(pos, radius + (outlineThick / 2.0f), outlineCol);
        DrawCircleV(pos, radius, mainCol);

        if (!name.empty()) {
            float fontSize = radius;
            int textW = MeasureText(name.c_str(), (int)fontSize);
            DrawText(name.c_str(), (int)pos.x - textW / 2, (int)pos.y - (int)radius - (int)fontSize - 5, (int)fontSize, DARKGRAY);
        }
        };

    if (!snapshotManager.history.empty()) {
        double renderTime = clientTime - snapshotManager.INTERPOLATION_DELAY;
        const auto& latestEntities = snapshotManager.history.back().entities;

        for (const auto& ent : latestEntities) {
            EntityState renderState;
            if (!snapshotManager.GetInterpolatedState(ent.id, renderTime, renderState)) renderState = ent;

            if (ent.id == myPlayerId && isPredictedInit) {
                float myRadius = 20.0f + (myLevel - 1) * 2.0f;
                DrawDiepTank(predictedPos, predictedRot, Theme::COL_ACCENT, myRadius, myHealth, myMaxHealth, true, ConfigManager::GetClient().playerName);
                continue;
            }

            if (renderState.type == EntityType::PLAYER) {
                float otherRadius = 20.0f + (renderState.level - 1) * 2.0f;
                DrawDiepTank(renderState.position, renderState.rotation, Theme::COLOR_RED, otherRadius, renderState.health, renderState.maxHealth, false, renderState.name);
            }
            else if (renderState.type == EntityType::BULLET) {
                DrawCircleV(renderState.position, renderState.radius + 1.5f, { 85, 85, 85, 255 });
                DrawCircleV(renderState.position, renderState.radius, Theme::COLOR_RED);
            }
            else if (renderState.type == EntityType::ENEMY) {
                float radius = renderState.radius; Vector2 pos = renderState.position; float rot = renderState.rotation + 90.0f;
                Color enemyColor = Theme::COLOR_RED; int sides = 3;
                switch (renderState.subtype) {
                case EnemyType::FAST: enemyColor = { 255, 105, 180, 255 }; break;
                case EnemyType::TANK: enemyColor = { 139, 0, 0, 255 }; sides = 4; break;                                                         case EnemyType::BOSS: enemyColor = { 128, 0, 128, 255 }; sides = 8; break;                 }

                                if (renderState.subtype == EnemyType::TANK) sides = 5;

                DrawPoly(pos, sides, radius + 4.0f, rot, { 85, 85, 85, 255 });
                DrawPoly(pos, sides, radius, rot, enemyColor);

                float hpPct = renderState.health / renderState.maxHealth;
                if (hpPct < 0.0f) hpPct = 0.0f;
                if (hpPct < 1.0f) {
                    DrawRectangle((int)pos.x - 20, (int)pos.y + (int)radius + 10, 40, 6, { 50,50,50,200 });
                    DrawRectangle((int)pos.x - 19, (int)pos.y + (int)radius + 11, (int)(38 * hpPct), 4, GREEN);
                }
            }
            else if (renderState.type == EntityType::WALL) {
                Rectangle r = { renderState.position.x - 25, renderState.position.y - 25, 50, 50 };

                                float hpRatio = renderState.health / renderState.maxHealth;
                Color baseColor = GRAY;
                if (hpRatio < 0.5f) baseColor = DARKGRAY;

                DrawRectangleRec(r, baseColor);
                DrawRectangleLinesEx(r, 2, DARKGRAY);

                                if (renderState.level >= 1) {
                                        DrawRectangleLinesEx({ r.x + 5, r.y + 5, r.width - 10, r.height - 10 }, 1, LIGHTGRAY);
                }
                if (renderState.level >= 2) {
                                        DrawLineEx({ r.x, r.y }, { r.x + r.width, r.y + r.height }, 2, BLACK);
                    DrawLineEx({ r.x + r.width, r.y }, { r.x, r.y + r.height }, 2, BLACK);
                }
                if (renderState.level >= 3) {
                                        DrawRectangle(r.x - 2, r.y - 2, 10, 10, GOLD);
                    DrawRectangle(r.x + r.width - 8, r.y - 2, 10, 10, GOLD);
                    DrawRectangle(r.x - 2, r.y + r.height - 8, 10, 10, GOLD);
                    DrawRectangle(r.x + r.width - 8, r.y + r.height - 8, 10, 10, GOLD);
                }
                                for (int i = 0; i < renderState.level; i++)
                    DrawRectangle(r.x + i * 8 + 3, r.y + 2, 4, 4, Theme::COL_ACCENT);


                                if (hpRatio < 1.0f) {
                    DrawRectangle(r.x, r.y - 8, 50, 4, RED);
                    DrawRectangle(r.x, r.y - 8, 50 * hpRatio, 4, GREEN);
                }
            }

            else if (renderState.type == EntityType::TURRET) {
                DrawCircleV(renderState.position, 20, PURPLE);
                DrawCircleLines(renderState.position.x, renderState.position.y, 20, BLACK);
                DrawCircleV(renderState.position, 8, DARKPURPLE);

                                if (renderState.level > 0) {
                    int orbs = renderState.level;                     float time = (float)GetTime();
                    float orbitRadius = 28.0f;

                    for (int i = 0; i < orbs; i++) {
                        float angle = (time * 3.0f) + (i * (360.0f / orbs) * DEG2RAD);
                        Vector2 orbPos = {
                            renderState.position.x + cosf(angle) * orbitRadius,
                            renderState.position.y + sinf(angle) * orbitRadius
                        };
                        DrawCircleV(orbPos, 5, GOLD);
                        DrawCircleLines(orbPos.x, orbPos.y, 5, ORANGE);
                    }
                }

                float hpPct = renderState.health / renderState.maxHealth;
                if (hpPct < 1.0f) {
                    DrawRectangle(renderState.position.x - 20, renderState.position.y - 30, 40, 4, RED);
                    DrawRectangle(renderState.position.x - 20, renderState.position.y - 30, 40 * hpPct, 4, GREEN);
                }
            }
            else if (renderState.type == EntityType::MINE) {
                                float pulse = 1.0f + sinf((float)GetTime() * 5.0f) * 0.1f;
                DrawCircleV(renderState.position, 15 * pulse, ORANGE);
                DrawCircleLines(renderState.position.x, renderState.position.y, 15 * pulse, RED);

                                DrawCircleV(renderState.position, 5, RED);

                                                float splashRad = 100.0f + (renderState.level - 1) * 50.0f;
                                DrawCircleV(renderState.position, splashRad, Fade(RED, 0.1f));
                DrawRing(renderState.position, splashRad, splashRad + 1.0f, 0, 360, 32, Fade(RED, 0.3f));
            }
            else if (renderState.type == EntityType::ARTIFACT) {
                float rot = (float)GetTime() * 100.0f;
                DrawPoly(renderState.position, 6, 16.0f, rot, { 85, 85, 85, 255 }); DrawPoly(renderState.position, 6, 13.0f, rot, ORANGE);
            }
        }
    }

    if (selectedBuildType > 0) {
#if defined(PLATFORM_ANDROID) || defined(ANDROID)
        Vector2 aimDir = rightStick->GetAxis();
        Vector2 offset = { 100, 0 };
        if (Vector2Length(aimDir) > 0.1f) offset = Vector2Scale(aimDir, 300.0f);
        Vector2 target = Vector2Add(predictedPos, offset);
#else
        Vector2 target = GetScreenToWorld2D(GetMousePosition(), camera);
#endif
        float gridX = roundf(target.x / 50.0f) * 50.0f;
        float gridY = roundf(target.y / 50.0f) * 50.0f;
        Vector2 snapPos = { gridX, gridY };

        Color ghostCol = Fade(GREEN, 0.5f);
        if (Vector2Distance(predictedPos, snapPos) > 400.0f) ghostCol = Fade(RED, 0.5f);

        if (selectedBuildType == ActionType::BUILD_WALL) DrawRectangle(snapPos.x - 25, snapPos.y - 25, 50, 50, ghostCol);
        else if (selectedBuildType == ActionType::BUILD_TURRET) DrawCircleV(snapPos, 20, ghostCol);
        else if (selectedBuildType == ActionType::BUILD_MINE) DrawCircleV(snapPos, 15, ghostCol);
    }

    particles.Draw();
    EndMode2D();
}

void GameplayScene::DrawLeaderboard(const std::vector<EntityState>& entities) {
    if (!showLeaderboard) return;
    int w = GetScreenWidth();
    float uiScale = game->GetUIScale();
    float boardW = 200.0f * uiScale;
    float startX = w - boardW - 10;

    float startY = 80 * uiScale;

    std::vector<EntityState> players;
    for (const auto& e : entities) if (e.type == EntityType::PLAYER) players.push_back(e);

    std::sort(players.begin(), players.end(), [](const EntityState& a, const EntityState& b) {
        return a.kills > b.kills;
        });

    float boardH = 30 * uiScale + (players.size() * 25.0f * uiScale);
    DrawRectangle(startX, startY, boardW, boardH, Fade(BLACK, 0.5f));
    DrawRectangleLines(startX, startY, boardW, boardH, Theme::COL_ACCENT);

    DrawText("LEADERBOARD", startX + 10 * uiScale, startY + 5 * uiScale, 20 * uiScale, Theme::COL_ACCENT);

    float y = startY + 30 * uiScale;
    for (const auto& p : players) {
        bool isMe = (p.id == myPlayerId);
        Color textColor = isMe ? YELLOW : WHITE;
        std::string displayName = p.name.empty() ? TextFormat("Player %d", p.id % 100) : p.name;

        DrawText(displayName.c_str(), startX + 10 * uiScale, y, 16 * uiScale, textColor);
        const char* score = TextFormat("%d", p.kills);
        DrawText(score, startX + boardW - MeasureText(score, 16 * uiScale) - 10 * uiScale, y, 16 * uiScale, textColor);
        y += 22 * uiScale;
    }
}

void GameplayScene::DrawGUI() {
    int w = GetScreenWidth(); int h = GetScreenHeight(); float uiScale = game->GetUIScale();
    GuiSetStyle(DEFAULT, TEXT_SIZE, (int)(20 * uiScale)); float padding = 20 * uiScale;

    if (!snapshotManager.history.empty()) {
        DrawMinimap(snapshotManager.history.back().entities);
        DrawLeaderboard(snapshotManager.history.back().entities);
    }

    DrawText(TextFormat("Scrap: %d", myScrap), padding, 170 * uiScale, 20 * uiScale, GOLD);
    char waveText[32]; sprintf(waveText, "WAVE %d", currentWave);
    DrawText(waveText, (w - MeasureText(waveText, 30 * uiScale)) / 2, padding, 30 * uiScale, Theme::COL_ACCENT);

        const char* builds[] = { "Wall (10)", "Turret (50)", "Mine (25)" };
    int costs[] = { 10, 50, 25 };
    float bY = h - 200 * uiScale; float bX = w - 130 * uiScale;
#if defined(PLATFORM_ANDROID) || defined(ANDROID)
    bY = h - 350 * uiScale; bX = w - 100 * uiScale;
#endif

        int myTurretCount = 0;
    if (!snapshotManager.history.empty()) {
        for (const auto& e : snapshotManager.history.back().entities) {
            if (e.type == EntityType::TURRET && e.ownerId == myPlayerId) myTurretCount++;
        }
    }

    for (int i = 0; i < 3; i++) {
        Rectangle bRect = { bX, bY + i * (45 * uiScale), 110 * uiScale, 40 * uiScale };
        int type = i + 1;
        bool canAfford = myScrap >= costs[i];
        bool limitReached = (type == ActionType::BUILD_TURRET && myTurretCount >= 5);

        std::string label = builds[i];
        if (type == ActionType::BUILD_TURRET) label += TextFormat(" %d/5", myTurretCount);

        if (canAfford && !limitReached) {
            if (GuiButton(bRect, label.c_str())) selectedBuildType = (selectedBuildType == type) ? 0 : type;
        }
        else {
            GuiDisable(); GuiButton(bRect, label.c_str()); GuiEnable();
        }
        if (selectedBuildType == type) DrawRectangleLinesEx(bRect, 2, GREEN);
    }

#if defined(PLATFORM_ANDROID) || defined(ANDROID)
    if (selectedBuildType != 0) {
        Rectangle btnPlace = { w - 120 * uiScale, h - 140 * uiScale, 100 * uiScale, 50 * uiScale };
        if (GuiButton(btnPlace, "PLACE")) {
            Vector2 aimDir = rightStick->GetAxis();
            Vector2 offset = { 100, 0 };
            if (Vector2Length(aimDir) > 0.1f) offset = Vector2Scale(aimDir, 300.0f);
            Vector2 target = Vector2Add(predictedPos, offset);

            ActionPacket act; act.type = selectedBuildType; act.target = target;
            SendAction(act);
            selectedBuildType = 0;
        }
    }
#else
    if (selectedBuildType != 0) {
        DrawText("LMB: Build, RMB: Cancel", w - 250 * uiScale, h - 50 * uiScale, 16 * uiScale, WHITE);
    }
#endif

    if (GuiButton(Rectangle{ w - 80 * uiScale - padding, padding, 80 * uiScale, 30 * uiScale }, "MENU")) game->ReturnToMenu();

    float barW = 500 * uiScale; if (barW > w * 0.6f) barW = w * 0.6f;
    float centerX = w / 2.0f; float bottomY = h - padding;
    float xpY = bottomY - 15 * uiScale;
    float xpPct = (myMaxXp > 0) ? (myCurrentXp / myMaxXp) : 0.0f;
    DrawRectangle(centerX - barW / 2, xpY, barW, 15 * uiScale, Fade(BLACK, 0.6f));
    DrawRectangle(centerX - barW / 2 + 2, xpY + 2, (int)((barW - 4) * xpPct), 15 * uiScale - 4, { 255, 232, 105, 255 });
    char lvlTxt[32]; sprintf(lvlTxt, "Lvl %d", myLevel); DrawText(lvlTxt, centerX - MeasureText(lvlTxt, 14 * uiScale) / 2, xpY, 14 * uiScale, BLACK);

    float hpBarH = 22 * uiScale; float hpY = xpY - hpBarH - (5 * uiScale);
    float hpPct = (myMaxHealth > 0) ? (myHealth / myMaxHealth) : 0.0f;
    DrawRectangle(centerX - barW / 2, hpY, barW, hpBarH, Fade(BLACK, 0.6f));
    DrawRectangle(centerX - barW / 2 + 2, hpY + 2, (int)((barW - 4) * hpPct), hpBarH - 4, Theme::COLOR_RED);
    char hpTxt[32]; sprintf(hpTxt, "%.0f / %.0f", myHealth, myMaxHealth); DrawText(hpTxt, centerX - MeasureText(hpTxt, 16 * uiScale) / 2, hpY + 2, 16 * uiScale, WHITE);

    float slotSize = 40 * uiScale; float invStartX = centerX - (slotSize * 6 + 25 * uiScale) / 2;
    float invY = hpY - slotSize - (15 * uiScale);
#if defined(PLATFORM_ANDROID) || defined(ANDROID)
    invY -= 40 * uiScale;
#endif
    for (int i = 0; i < 6; i++) {
        Rectangle slotRect = { invStartX + i * (slotSize + 5 * uiScale), invY, slotSize, slotSize };
        DrawRectangleRec(slotRect, COL_INV_EMPTY); DrawRectangleLinesEx(slotRect, 2, COL_INV_BORDER);
        if (i < myInventory.size() && myInventory[i] != 255) {
            Color iconColor = WHITE; const char* label = "?";
            switch (myInventory[i]) {
            case 0: iconColor = { 255, 100, 100, 255 }; label = "D"; break;
            case 1: iconColor = { 100, 100, 255, 255 }; label = "S"; break;
            case 2: iconColor = { 100, 255, 100, 255 }; label = "H"; break;
            case 3: iconColor = { 255, 255, 100, 255 }; label = "R"; break;
            }
            DrawRectangle(slotRect.x + 4, slotRect.y + 4, slotRect.width - 8, slotRect.height - 8, iconColor);
            DrawText(label, slotRect.x + 10 * uiScale, slotRect.y + 5 * uiScale, 24 * uiScale, BLACK);
        }
    }

    DrawAdminPanel();
    if (!isAdmin) {
        if (GuiButton({ 0, 0, 10, 10 }, "")) SendAdminCmd(AdminCmdType::LOGIN, 0);
    }

#if defined(PLATFORM_ANDROID) || defined(ANDROID)
    if (leftStick) leftStick->Draw(); if (rightStick) rightStick->Draw();
#endif
}

void GameplayScene::DrawAdminPanel() {
    if (!showAdminPanel || !isAdmin) return;
    float uiScale = game->GetUIScale();
    float cx = GetScreenWidth() / 2.0f;
    float cy = GetScreenHeight() / 2.0f;
    Rectangle panel = { cx - 150 * uiScale, cy - 200 * uiScale, 300 * uiScale, 400 * uiScale };

    DrawRectangleRec(panel, Theme::COL_PANEL);
    DrawRectangleLinesEx(panel, 2, RED);
    DrawText("ADMIN PANEL", panel.x + 10, panel.y + 10, 20 * uiScale, RED);

    float btnH = 30 * uiScale;
    float y = panel.y + 50 * uiScale;

    if (GuiButton({ panel.x + 10, y, 280 * uiScale, btnH }, "Give 1000 Scrap")) SendAdminCmd(AdminCmdType::GIVE_SCRAP, 1000);
    y += 40 * uiScale;
    if (GuiButton({ panel.x + 10, y, 280 * uiScale, btnH }, "Give 1 Level")) SendAdminCmd(AdminCmdType::GIVE_XP, 1000);
    y += 40 * uiScale;
    if (GuiButton({ panel.x + 10, y, 280 * uiScale, btnH }, "Kill All Enemies")) SendAdminCmd(AdminCmdType::KILL_ALL_ENEMIES, 0);
    y += 40 * uiScale;
    if (GuiButton({ panel.x + 10, y, 280 * uiScale, btnH }, "Spawn Boss")) SendAdminCmd(AdminCmdType::SPAWN_BOSS, 0);
    y += 40 * uiScale;
        if (GuiButton({ panel.x + 10, y, 280 * uiScale, btnH }, "Clear Buildings")) SendAdminCmd(AdminCmdType::CLEAR_BUILDINGS, 0);
    y += 40 * uiScale;
    if (GuiButton({ panel.x + 10, y, 280 * uiScale, btnH }, "RESET SERVER")) SendAdminCmd(AdminCmdType::RESET_SERVER, 0);
}

void GameplayScene::DrawMinimap(const std::vector<EntityState>& entities) {
    float mapSize = 150.0f * game->GetUIScale();
    float padding = 10.0f * game->GetUIScale();
    Vector2 mapOrigin = { padding, padding };

    DrawRectangleV(mapOrigin, { mapSize, mapSize }, Fade(BLACK, 0.7f));
    DrawRectangleLinesEx({ mapOrigin.x, mapOrigin.y, mapSize, mapSize }, 2, WHITE);

    float worldSize = 4000.0f;
    float scale = mapSize / worldSize;

    for (const auto& e : entities) {
        Vector2 mapPos = { mapOrigin.x + e.position.x * scale, mapOrigin.y + e.position.y * scale };
        Color dotCol = WHITE;
        if (e.id == myPlayerId) dotCol = BLUE;
        else if (e.type == EntityType::PLAYER) dotCol = SKYBLUE;
        else if (e.type == EntityType::ENEMY) dotCol = RED;
        else continue;

        DrawCircleV(mapPos, 2.0f, dotCol);
    }
}
// client\scenes\GameplayScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"
#include "../../common/NetworkPackets.h"
#include "SnapshotManager.h"
#include "../vircontrols/VirtualJoystick.h"
#include "../ParticleSystem.h"
#include <memory>
#include <vector>
#include "Theme.h"

class GameClient;
class GameplayScene : public Scene {
    Camera2D camera = { 0 };

    SnapshotManager snapshotManager;
    ParticleSystem particles;

    double clientTime = 0.0;
    double lastServerTime = 0.0;

    uint32_t myPlayerId = 0;
    Vector2 predictedPos = { 0, 0 };
    float predictedRot = 0.0f;
    bool isPredictedInit = false;
    float gunAnimOffset = 0.0f;

    // Player Stats
    uint32_t myLevel = 1;
    float myCurrentXp = 0.0f;
    float myMaxXp = 100.0f;
    float myHealth = 100.0f;
    float myMaxHealth = 100.0f;
    float myDamage = 0.0f;
    float mySpeed = 0.0f;
    uint32_t myScrap = 0;
    uint32_t myKills = 0;
    bool isAdmin = false;


    uint32_t currentWave = 1;

    int selectedBuildType = 0;
    std::vector<uint8_t> myInventory{ 255,255,255,255,255,255 };
    std::vector<uint32_t> lastFrameEntityIds;

    bool showAdminPanel = false;
    bool showLeaderboard = true;

#if defined(PLATFORM_ANDROID) || defined(ANDROID)
    std::unique_ptr<VirtualJoystick> leftStick;
    std::unique_ptr<VirtualJoystick> rightStick;
#endif

public:
    GameplayScene(GameClient* g);
    virtual ~GameplayScene() = default;

    void Enter() override;
    void Exit() override;

    void OnMessage(Message::Shared msg) override;
    void SendAction(const ActionPacket& act);
    void SendAdminCmd(uint8_t cmd, uint32_t val);

    void Update(float dt) override;
    void Draw() override;
    void DrawGUI() override;

    void DrawMinimap(const std::vector<EntityState>& entities);
    void DrawLeaderboard(const std::vector<EntityState>& entities);
    void DrawAdminPanel();
};
// client\scenes\MainMenuScene.cpp
﻿#define _CRT_SECURE_NO_WARNINGS
#include "MainMenuScene.h"
#include "raygui_wrapper.h"
#include "../GameClient.h"
#include "engine/Utils/ConfigManager.h"
#include "ResourceManager.h"
#include "Theme.h"
#include <cstring>
#include <string>
#include <thread>
#include <chrono>

MainMenuScene::MainMenuScene(GameClient* g) : Scene(g) {}

void MainMenuScene::Enter() {
    Theme::ApplyTheme();
    ResourceManager::Get().Load();
    ClientConfig& cfg = ConfigManager::GetClient();
    strcpy(ipBuffer, cfg.lastIp.c_str());
    sprintf(portBuffer, "%d", cfg.lastPort);
    strcpy(nameBuffer, cfg.playerName.c_str());

    ServerConfig& sCfg = ConfigManager::GetServer();
    strcpy(serverNameBuffer, sCfg.serverName.c_str());
    hostMaxPlayers = (float)sCfg.maxPlayers;
    hostTps = (float)sCfg.tickRate;
    isPublicServer = true; 
    currentState = MenuState::MAIN;
        activeMpTab = 0;

    virtualKeyboard.Hide();
}

void MainMenuScene::Exit() {
    ClientConfig& cfg = ConfigManager::GetClient();
    cfg.playerName = nameBuffer;
    cfg.lastIp = ipBuffer;
    cfg.lastPort = atoi(portBuffer);

    ServerConfig& sCfg = ConfigManager::GetServer();
    sCfg.serverName = serverNameBuffer;
    sCfg.maxPlayers = (int)hostMaxPlayers;
    sCfg.tickRate = (int)hostTps;

    ConfigManager::Save();
}

void MainMenuScene::Update(float dt) {
    ResourceManager::Get().UpdateBackground(dt);
}

void MainMenuScene::RefreshLobbyList() {
    if (isRefreshing) return;
    isRefreshing = true;

    {
        std::lock_guard<std::mutex> lock(lobbyMutex);
        lobbyList.clear();
    }

    std::thread([this]() {
                auto tempClient = ENetClient::alloc();
        ClientConfig& cCfg = ConfigManager::GetClient();

        if (tempClient->connect(cCfg.masterServerIp, cCfg.masterServerPort)) {
            Buffer buffer; OutputAdapter adapter(buffer);
            bitsery::Serializer<OutputAdapter> serializer(std::move(adapter));
            serializer.value1b(GamePacket::MASTER_LIST_REQ);
            serializer.adapter().flush();
            tempClient->send(DeliveryType::RELIABLE, StreamBuffer::alloc(buffer.data(), buffer.size()));

            auto start = std::chrono::steady_clock::now();
            bool gotResponse = false;

                        while (std::chrono::steady_clock::now() - start < std::chrono::seconds(2)) {
                auto msgs = tempClient->poll();
                for (auto& msg : msgs) {
                    if (msg->type() == MessageType::DATA) {
                        const auto& buf = msg->stream()->buffer();
                        size_t offset = msg->stream()->tellg();
                        if (!buf.empty() && offset < buf.size()) {
                            InputAdapter ia(buf.begin() + offset, buf.end());
                            bitsery::Deserializer<InputAdapter> des(std::move(ia));
                            uint8_t type; des.value1b(type);
                            if (type == GamePacket::MASTER_LIST_RES) {
                                MasterListResPacket res; des.object(res);

                                                                std::lock_guard<std::mutex> lock(lobbyMutex);
                                lobbyList = res.lobbies;
                                gotResponse = true;
                            }
                        }
                    }
                }
                if (gotResponse) break;
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
            }
            tempClient->disconnect();
        }
        isRefreshing = false;
        }).detach();
}

bool MainMenuScene::DrawInputField(Rectangle bounds, char* buffer, int bufferSize, bool& editMode) {
#if defined(PLATFORM_ANDROID) || defined(ANDROID)
    if (GuiTextBox(bounds, buffer, bufferSize, false)) {
        if (!virtualKeyboard.IsActive()) virtualKeyboard.Show(buffer, bufferSize);
    }
    return false;
#else
    if (GuiTextBox(bounds, buffer, bufferSize, editMode)) {
        editMode = !editMode;
        return true;
    }
    return false;
#endif
}

void MainMenuScene::Draw() {
    ResourceManager::Get().DrawBackground();
    int w = GetScreenWidth();
    int h = GetScreenHeight();
    float cx = w / 2.0f;
    float uiScale = game->GetUIScale();

    const char* title = ConfigManager::Text("title_void_assault");
    float fontSize = 60.0f * uiScale;
    Font font = ConfigManager::GetFont();
    Vector2 titleSize = MeasureTextEx(font, title, fontSize, 2);
    float titleY = h * 0.1f;

    DrawTextEx(font, title, { cx - titleSize.x / 2 + 4, titleY + 4 }, fontSize, 2, Fade(BLACK, 0.5f));
    DrawTextEx(font, title, { cx - titleSize.x / 2, titleY }, fontSize, 2, Theme::COL_ACCENT);
}

void MainMenuScene::DrawGUI() {
    int w = GetScreenWidth();
    int h = GetScreenHeight();
    float cx = w / 2.0f;
    float uiScale = game->GetUIScale();
    Font font = ConfigManager::GetFont();
    GuiSetStyle(DEFAULT, TEXT_SIZE, (int)(20 * uiScale));

    bool kbdActive = virtualKeyboard.IsActive();
    if (kbdActive) GuiDisable();

        if (currentState == MenuState::MAIN) {
        float btnW = 320 * uiScale;
        float btnH = 60 * uiScale;
        float spacing = 25 * uiScale;
        int btnCount = 4; 
        float totalHeight = (btnH * btnCount) + (spacing * (btnCount - 1));
        float panelPadding = 40 * uiScale;
        float panelW = btnW + (panelPadding * 2);
        float panelH = totalHeight + (panelPadding * 2);
        float panelY = (h - panelH) / 2.0f + (h * 0.05f);

        Rectangle menuRect = { cx - panelW / 2, panelY, panelW, panelH };
        ResourceManager::DrawSciFiPanel(menuRect, "Alpha 0.7", font);
        float currentY = panelY + panelPadding;

                if (GuiButton({ cx - btnW / 2, currentY, btnW, btnH }, ConfigManager::Text("btn_singleplayer"))) {
            std::thread([this]() {
                int realPort = game->StartHost(7777, false);
                if (realPort > 0) {
                    std::this_thread::sleep_for(std::chrono::milliseconds(200));
                    game->netClient->connect("127.0.0.1", realPort);
                }
                }).detach();
        }
        currentY += btnH + spacing;

                if (GuiButton({ cx - btnW / 2, currentY, btnW, btnH }, ConfigManager::Text("btn_multiplayer"))) {
            currentState = MenuState::MULTIPLAYER;
            if (activeMpTab == 0) RefreshLobbyList();
        }
        currentY += btnH + spacing;

                if (GuiButton({ cx - btnW / 2, currentY, btnW, btnH }, ConfigManager::Text("btn_settings"))) {
            currentState = MenuState::SETTINGS;
        }
        currentY += btnH + spacing;

                if (GuiButton({ cx - btnW / 2, currentY, btnW, btnH }, ConfigManager::Text("btn_exit"))) {
            CloseWindow();
        }
    }
        else if (currentState == MenuState::MULTIPLAYER) {
        float panelW = w * 0.9f;
        if (panelW > 900 * uiScale) panelW = 900 * uiScale;         float panelH = h * 0.8f;
        float panelY = (h - panelH) / 2.0f;

        Rectangle panelRect = { cx - panelW / 2, panelY, panelW, panelH };
        ResourceManager::DrawSciFiPanel(panelRect, ConfigManager::Text("btn_multiplayer"), font);

        float contentPad = 20 * uiScale;
        float contentX = panelRect.x + contentPad;
        float contentY = panelRect.y + contentPad * 2.0f;         float contentW = panelRect.width - (contentPad * 2);
        float fieldH = 40 * uiScale;
        float lblH = 25 * uiScale;
        float spacing = 15 * uiScale;

                GuiLabel({ contentX, contentY, contentW, lblH }, ConfigManager::Text("lbl_nickname"));
        contentY += lblH;
        DrawInputField({ contentX, contentY, contentW * 0.6f, fieldH }, nameBuffer, 32, isEditingName);
        if (!isEditingName && !kbdActive) ConfigManager::GetClient().playerName = nameBuffer;
        contentY += fieldH + spacing;

                int prevTab = activeMpTab;

                GuiToggleGroup({ contentX, contentY, contentW/3, fieldH }, ConfigManager::Text("tabs_multiplayer"), &activeMpTab);

                if (activeMpTab == 0 && prevTab != 0) RefreshLobbyList();

        contentY += fieldH + spacing;

                if (activeMpTab == 0) {
                        if (GuiButton({ contentX + contentW - 120 * uiScale, contentY, 120 * uiScale, 30 * uiScale }, isRefreshing ? "..." : ConfigManager::Text("btn_refresh"))) {
                RefreshLobbyList();
            }
            contentY += 35 * uiScale;

            DrawRectangleLines(contentX, contentY, contentW, 30 * uiScale, GRAY);
            DrawTextEx(font, ConfigManager::Text("header_browser_name"), { contentX + 10, contentY + 5 }, 20 * uiScale,1, DARKGRAY);
            DrawTextEx(font, ConfigManager::Text("header_browser_players"), { contentX + contentW * 0.5f, contentY + 5 }, 20 * uiScale, 1, DARKGRAY);
            DrawTextEx(font, ConfigManager::Text("header_browser_wave"), { contentX + contentW * 0.7f, contentY + 5 }, 20 * uiScale, 1, DARKGRAY);
            contentY += 35 * uiScale;

            float itemH = 40 * uiScale;
            float listMaxY = panelRect.y + panelRect.height - 60 * uiScale;

                        std::lock_guard<std::mutex> lock(lobbyMutex);

            if (lobbyList.empty() && !isRefreshing) {
                DrawTextEx(font, ConfigManager::Text("msg_no_servers"), { contentX + 10, contentY + 10 }, 20 * uiScale, 1, GRAY);
            }

            for (const auto& lobby : lobbyList) {
                if (contentY + itemH > listMaxY) break; 
                Rectangle itemRect = { contentX, contentY, contentW, itemH };
                if (CheckCollisionPointRec(GetMousePosition(), itemRect)) DrawRectangleRec(itemRect, Fade(Theme::COL_ACCENT, 0.2f));
                DrawRectangleLinesEx(itemRect, 1, LIGHTGRAY);

                DrawText(lobby.name.c_str(), itemRect.x + 10, itemRect.y + 10, 20 * uiScale, BLACK);
                DrawText(TextFormat("%d/%d", lobby.currentPlayers, lobby.maxPlayers), itemRect.x + contentW * 0.5f, itemRect.y + 10, 20 * uiScale, BLACK);
                DrawText(TextFormat("%d", lobby.wave), itemRect.x + contentW * 0.7f, itemRect.y + 10, 20 * uiScale, BLACK);

                if (GuiButton({ itemRect.x + contentW - 110 * uiScale, itemRect.y + 5, 100 * uiScale, 30 * uiScale }, ConfigManager::Text("btn_join"))) {
                    std::string targetIp = (lobby.ip.empty() || lobby.ip == "Unknown") ? "127.0.0.1" : lobby.ip;
                    game->netClient->connect(targetIp, lobby.port);
                }
                contentY += itemH + 5;
            }
        }
                else if (activeMpTab == 1) {
            GuiLabel({ contentX, contentY, contentW, lblH }, ConfigManager::Text("lbl_ip"));
            contentY += lblH;
            DrawInputField({ contentX, contentY, contentW, fieldH }, ipBuffer, 64, isEditingIp);
            contentY += fieldH + spacing;

            GuiLabel({ contentX, contentY, contentW, lblH }, ConfigManager::Text("lbl_port"));
            contentY += lblH;
            DrawInputField({ contentX, contentY, contentW * 0.3f, fieldH }, portBuffer, 16, isEditingPort);
            contentY += fieldH + spacing * 1.5f;

            if (GuiButton({ contentX, contentY, contentW, fieldH * 1.2f }, ConfigManager::Text("btn_join"))) {
                ConfigManager::GetClient().lastIp = ipBuffer;
                ConfigManager::GetClient().lastPort = atoi(portBuffer);
                ConfigManager::Save();
                game->netClient->connect(ipBuffer, atoi(portBuffer));
            }
        }
                else if (activeMpTab == 2) {
            GuiLabel({ contentX, contentY, contentW, lblH }, "Server Name");
            contentY += lblH;
            DrawInputField({ contentX, contentY, contentW, fieldH }, serverNameBuffer, 32, isEditingServerName);
            contentY += fieldH + spacing;

            GuiLabel({ contentX, contentY, contentW, lblH }, "Max Players");
            contentY += lblH;
            GuiSlider({ contentX, contentY, contentW, fieldH }, "1", "32", &hostMaxPlayers, 1, 32);
            contentY += fieldH + spacing;

                        if (GuiCheckBox({ contentX, contentY, 20 * uiScale, 20 * uiScale }, ConfigManager::Text("chk_public"), &isPublicServer)) {
                            }
            contentY += 30 * uiScale + spacing;

            GuiLabel({ contentX, contentY, contentW, lblH }, ConfigManager::Text("lbl_port"));
            contentY += lblH;
            DrawInputField({ contentX, contentY, contentW * 0.3f, fieldH }, portBuffer, 16, isEditingPort);
            contentY += fieldH + spacing * 2.0f;

            if (GuiButton({ contentX, contentY, contentW, fieldH * 1.2f }, ConfigManager::Text("btn_create_lobby"))) {
                ConfigManager::GetServer().serverName = serverNameBuffer;
                ConfigManager::GetServer().maxPlayers = (int)hostMaxPlayers;
                ConfigManager::GetServer().tickRate = (int)hostTps;

                int port = atoi(portBuffer);
                bool publicSrv = isPublicServer;

                std::thread([this, port, publicSrv]() {
                    int p = game->StartHost(port, publicSrv);
                    if (p > 0) {
                        int delay = publicSrv ? 1000 : 200;
                        std::this_thread::sleep_for(std::chrono::milliseconds(delay));
                        game->netClient->connect("127.0.0.1", p);
                    }
                    }).detach();
            }
        }

                float backBtnH = 50 * uiScale;
        float backBtnY = panelRect.y + panelRect.height + spacing;
        if (GuiButton({ cx - (150 * uiScale), backBtnY, 300 * uiScale, backBtnH }, ConfigManager::Text("btn_back"))) {
            currentState = MenuState::MAIN;
        }
    }
        else if (currentState == MenuState::SETTINGS) {
        float panelW = w * 0.7f;
        if (panelW > 500 * uiScale) panelW = 500 * uiScale;
        float panelH = 400 * uiScale;
        float panelY = (h - panelH) / 2.0f;

        Rectangle panelRect = { cx - panelW / 2, panelY, panelW, panelH };
        ResourceManager::DrawSciFiPanel(panelRect, ConfigManager::Text("btn_settings"), font);

        float contentX = panelRect.x + 30 * uiScale;
        float contentY = panelRect.y + 45 * uiScale;
        float contentW = panelRect.width - 60 * uiScale;
        float elemH = 40 * uiScale;
        float spacing = 25 * uiScale;

        GuiLabel({ contentX, contentY, contentW, 25 * uiScale }, ConfigManager::Text("lbl_master_vol"));
        contentY += 30 * uiScale;
        float vol = game->audio.GetVolume();
        if (GuiSlider({ contentX, contentY, contentW, elemH }, "0%", "100%", &vol, 0.0f, 1.0f)) game->audio.SetVolume(vol);
        contentY += elemH + spacing;

        GuiLabel({ contentX, contentY, contentW, 25 * uiScale }, ConfigManager::Text("lbl_language"));
        contentY += 30 * uiScale;
        std::string langBtnText = "< " + ConfigManager::GetCurrentLangName() + " >";
        if (GuiButton({ contentX, contentY, contentW, elemH }, langBtnText.c_str())) ConfigManager::CycleLanguage();

        float backBtnH = 50 * uiScale;
        float backBtnY = panelRect.y + panelRect.height + spacing;
        if (GuiButton({ cx - (150 * uiScale), backBtnY, 300 * uiScale, backBtnH }, ConfigManager::Text("btn_back"))) currentState = MenuState::MAIN;
    }

    if (kbdActive) {
        GuiEnable();
        DrawRectangle(0, 0, w, h, Fade(BLACK, 0.7f));
        virtualKeyboard.Draw();
        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON) && GetMouseY() < h * 0.4f) virtualKeyboard.Hide();
    }
}
// client\scenes\MainMenuScene.h
﻿#pragma once
#include "raylib_compatibility.h"
#include "engine/Scenes/Scene.h"
#include "../vircontrols/InGameKeyboard.h"
#include "common/NetworkPackets.h"
#include "common/enet/ENetClient.h"
#include <string>
#include <vector>
#include <mutex> 
class GameClient;

enum class MenuState {
    MAIN,
    MULTIPLAYER,
    SETTINGS
};

class MainMenuScene : public Scene {
private:
    char ipBuffer[64] = "";
    char portBuffer[16] = "";
    char nameBuffer[32] = "";

        char serverNameBuffer[32] = "";
    float hostMaxPlayers = 8;
    float hostTps = 60;
    bool isPublicServer = true; 
    bool isEditingIp = false;
    bool isEditingPort = false;
    bool isEditingName = false;
    bool isEditingServerName = false;

    MenuState currentState = MenuState::MAIN;
    int activeMpTab = 0; 
    InGameKeyboard virtualKeyboard;

        std::vector<LobbyInfo> lobbyList;
    std::mutex lobbyMutex;     bool isRefreshing = false;

    
    bool DrawInputField(Rectangle bounds, char* buffer, int bufferSize, bool& editMode);
    void RefreshLobbyList();

public:
    MainMenuScene(GameClient* g);
    virtual ~MainMenuScene() = default;

    void Enter() override;
    void Exit() override;
    void Update(float dt) override;
    void Draw() override;
    void DrawGUI() override;
};
// client\scenes\SettingsScene.cpp
﻿// client\scenes\SettingsScene.cpp
#include "SettingsScene.h"
#include "engine/Utils/ConfigManager.h"
#include "ResourceManager.h"
#include <string>

void SettingsScene::Enter() {
#if !defined(PLATFORM_ANDROID) && !defined(ANDROID)
	currentResIndex = 0;
	int w = ConfigManager::GetClient().resolutionWidth;
	int h = ConfigManager::GetClient().resolutionHeight;
	for (size_t i = 0; i < resolutions.size(); i++) {
		if (resolutions[i].x == w && resolutions[i].y == h) {
			currentResIndex = (int)i;
			break;
		}
	}
#endif
}

void SettingsScene::Exit() {}
void SettingsScene::Update(float dt) {}

void SettingsScene::Draw() {
	ResourceManager::Get().UpdateBackground(GetFrameTime());
	ResourceManager::Get().DrawBackground();
}

void SettingsScene::DrawGUI() {
	int w = game->GetWidth();
	int h = game->GetHeight();
	float cx = w / 2.0f;
	float uiScale = game->GetUIScale();
	GuiSetStyle(DEFAULT, TEXT_SIZE, (int)(20 * uiScale));

	float panelW = w * 0.8f;
	if (panelW > 600 * uiScale) panelW = 600 * uiScale;

	int items = 2;
#if !defined(PLATFORM_ANDROID) && !defined(ANDROID)
	items++;
#endif
	float elemH = 40 * uiScale;
	float spacing = 30 * uiScale;
	float padding = 40 * uiScale;
	float panelH = (padding * 2) + (items * (elemH + spacing + 30 * uiScale));
	float panelY = (h - panelH) / 2.0f;

	Rectangle panelRect = { cx - panelW / 2, panelY, panelW, panelH };
	ResourceManager::DrawSciFiPanel(panelRect, ConfigManager::Text("btn_settings"), ConfigManager::GetFont());

	float contentX = panelRect.x + padding;
	float currentY = panelRect.y + padding + 10 * uiScale;
	float contentW = panelRect.width - (padding * 2);

	GuiLabel({ contentX, currentY, contentW, 25 * uiScale }, ConfigManager::Text("lbl_master_vol"));
	currentY += 30 * uiScale;
	float vol = game->audio.GetVolume();
	if (GuiSlider({ contentX, currentY, contentW, elemH }, "0%", "100%", &vol, 0.0f, 1.0f)) {
		game->audio.SetVolume(vol);
	}
	currentY += elemH + spacing;

	GuiLabel({ contentX, currentY, contentW, 25 * uiScale }, ConfigManager::Text("lbl_language"));
	currentY += 30 * uiScale;
	std::string langBtnText = "< " + ConfigManager::GetCurrentLangName() + " >";
	if (GuiButton({ contentX, currentY, contentW, elemH }, langBtnText.c_str())) {
		ConfigManager::CycleLanguage();
	}
	currentY += elemH + spacing;
#if !defined(PLATFORM_ANDROID) && !defined(ANDROID)
	GuiLabel({ contentX, currentY, contentW, 25 * uiScale }, "Resolution");
	currentY += 30 * uiScale;
	std::string resText = std::to_string((int)resolutions[currentResIndex].x) + "x" + std::to_string((int)resolutions[currentResIndex].y);
	if (GuiButton({ contentX, currentY, contentW, elemH }, resText.c_str())) {
		currentResIndex = (currentResIndex + 1) % resolutions.size();
		ConfigManager::GetClient().resolutionWidth = (int)resolutions[currentResIndex].x;
		ConfigManager::GetClient().resolutionHeight = (int)resolutions[currentResIndex].y;
		ConfigManager::Save();
		SetWindowSize((int)resolutions[currentResIndex].x, (int)resolutions[currentResIndex].y);
	}
	currentY += elemH + spacing;
#endif
	float backBtnH = 50 * uiScale;
	float backBtnY = panelRect.y + panelRect.height + spacing;

	if (GuiButton({ cx - (150 * uiScale), backBtnY, 300 * uiScale, backBtnH }, ConfigManager::Text("btn_back"))) {
		game->ReturnToMenu();
	}
}
// client\scenes\SettingsScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"
#include "../../client/GameClient.h"
#include <vector>
class SettingsScene : public Scene {
	std::vector<Vector2> resolutions = {
	{1280, 720},
	{1366, 768},
	{1600, 900},
	{1920, 1080}
	};
	int currentResIndex = 0;
public:
	SettingsScene(GameClient* g) : Scene(g) {}
	void Enter() override;
	void Exit() override;
	void Update(float dt) override;

	void Draw() override;

	void DrawGUI() override;
};
// client\vircontrols\InGameKeyboard.h
﻿#pragma once
#include "raylib.h"
#include "raygui.h"
#include <string>
#include <vector>
#include <cstring>
#include <cmath>
#if defined(ANDROID) || defined(PLATFORM_ANDROID) || defined(ANDROID)
#define IS_MOBILE_PLATFORM
#endif
class InGameKeyboard {
private:
#ifdef IS_MOBILE_PLATFORM
	bool active = false;
	char* targetBuffer = nullptr;
	int maxLen = 0;
    bool isCaps = false;
    bool isSymbols = false;
    int cursorIndex = 0;
    int frameCounter = 0;

    const std::string rowNumbers = "1234567890";

    const std::vector<std::string> rowsAlphaLower = {
        "qwertyuiop",
        "asdfghjkl",
        "zxcvbnm."
    };

    const std::vector<std::string> rowsAlphaUpper = {
        "QWERTYUIOP",
        "ASDFGHJKL",
        "ZXCVBNM."
    };

    const std::vector<std::string> rowsSymbols = {
        "1234567890",
        "!@#$%^&*()",
        "-=_+[]{}\\|",
        ";:'\",.<>/?"
    };
#endif
public:
    void Show(char* buffer, int bufferSize) {
#ifdef IS_MOBILE_PLATFORM
        targetBuffer = buffer;
        maxLen = bufferSize;
        active = true;
        isCaps = false;
        isSymbols = false;
        cursorIndex = (targetBuffer) ? (int)strlen(targetBuffer) : 0;
#endif
    }
    void Hide() {
#ifdef IS_MOBILE_PLATFORM
        active = false;
        targetBuffer = nullptr;
#endif
    }
    bool IsActive() const {
#ifdef IS_MOBILE_PLATFORM
        return active;
#else
        return false;
#endif
    }
    void Draw() {
#ifdef IS_MOBILE_PLATFORM
        if (!active) return;
        int screenW = GetScreenWidth();
        int screenH = GetScreenHeight();

        float kbdH = screenH * 0.45f;
        float startY = screenH - kbdH;

        float previewH = 60.0f;
        float previewY = startY - previewH;

        DrawRectangle(0, (int)previewY, screenW, (int)(kbdH + previewH), Fade(GetColor(0xF0F0F0FF), 0.98f));
        DrawLine(0, (int)previewY, screenW, (int)previewY, GRAY);

        Rectangle previewRect = { 0, previewY, (float)screenW, previewH };

        int oldAlign = GuiGetStyle(TEXTBOX, TEXT_ALIGNMENT);
        GuiSetStyle(TEXTBOX, TEXT_ALIGNMENT, TEXT_ALIGN_LEFT);

        GuiTextBox(previewRect, targetBuffer, maxLen, false);

        GuiSetStyle(TEXTBOX, TEXT_ALIGNMENT, oldAlign);

        if (targetBuffer) {
            Font font = GuiGetFont();
            int fontSize = GuiGetStyle(DEFAULT, TEXT_SIZE);
            int fontSpacing = GuiGetStyle(DEFAULT, TEXT_SPACING);
            int textPadding = GuiGetStyle(TEXTBOX, TEXT_PADDING);

            char tempC = targetBuffer[cursorIndex];
            targetBuffer[cursorIndex] = '\0';
            Vector2 size = MeasureTextEx(font, targetBuffer, (float)fontSize, (float)fontSpacing);
            targetBuffer[cursorIndex] = tempC;

            int cursorX = (int)previewRect.x + textPadding + (int)size.x + 2;
            int cursorY = (int)previewRect.y + (int)previewH / 2 - fontSize / 2;

            frameCounter++;
            if ((frameCounter / 30) % 2 == 0) {
                DrawRectangle(cursorX, cursorY, 2, fontSize, RED);
            }

            if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON) && CheckCollisionPointRec(GetMousePosition(), previewRect)) {
                float clickLocalX = GetMousePosition().x - (previewRect.x + textPadding);

                int bestIndex = 0;
                float minDiff = 9999.0f;
                int len = (int)strlen(targetBuffer);

                for (int i = 0; i <= len; i++) {
                    char tmp = targetBuffer[i];
                    targetBuffer[i] = '\0';
                    Vector2 width = MeasureTextEx(font, targetBuffer, (float)fontSize, (float)fontSpacing);
                    targetBuffer[i] = tmp;

                    float diff = std::abs(width.x - clickLocalX);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestIndex = i;
                    }
                }
                cursorIndex = bestIndex;
            }
        }

        float padding = 4.0f;
        int totalRows = 4;

        float rowHeight = (kbdH - (padding * (totalRows + 2))) / (totalRows + 1);

        for (int r = 0; r < totalRows; r++) {
            std::string rowStr;

            if (isSymbols) {
                rowStr = rowsSymbols[r];
            }
            else {
                if (r == 0) rowStr = rowNumbers;
                else rowStr = (isCaps ? rowsAlphaUpper : rowsAlphaLower)[r - 1];
            }

            int numKeys = (int)rowStr.length();
            float availableWidth = screenW;
            if (r == 0 && !isSymbols) availableWidth -= (rowHeight * 1.6f + padding * 2);

            float keyWidth = (availableWidth - (padding * (numKeys + 1))) / (float)numKeys;
            float maxKeyW = rowHeight * 1.5f;
            if (keyWidth > maxKeyW) keyWidth = maxKeyW;

            float rowTotalWidth = numKeys * keyWidth + (numKeys - 1) * padding;
            float startX = (screenW - rowTotalWidth) / 2.0f;

            if (r == 0 && !isSymbols) {
                startX = (availableWidth - rowTotalWidth) / 2.0f;
                if (startX < padding) startX = padding;
            }

            for (int i = 0; i < numKeys; i++) {
                Rectangle btnRect = {
                    startX + i * (keyWidth + padding),
                    startY + padding + r * (rowHeight + padding),
                    keyWidth,
                    rowHeight
                };

                char keyLabel[2] = { rowStr[i], '\0' };
                if (GuiButton(btnRect, keyLabel)) {
                    InsertChar(rowStr[i]);
                }
            }
        }

        if (!isSymbols) {
            float bsWidth = rowHeight * 1.6f;
            float bsX = screenW - bsWidth - padding;
            Rectangle bsRect = { bsX, startY + padding, bsWidth, rowHeight };
            if (GuiButton(bsRect, "#118#")) {
                DeleteChar();
            }
        }
        else {
            float bsWidth = rowHeight * 1.6f;
            float bsX = screenW - bsWidth - padding;
            Rectangle bsRect = { bsX, startY + padding, bsWidth, rowHeight };
            if (GuiButton(bsRect, "#118#")) {
                DeleteChar();
            }
        }

        float bottomY = startY + padding + totalRows * (rowHeight + padding);
        float btnSmallW = screenW * 0.15f;
        float btnSpaceW = screenW - (btnSmallW * 3 + padding * 5);

        float currentX = padding;

        if (GuiButton({ currentX, bottomY, btnSmallW, rowHeight }, isSymbols ? "ABC" : "?123")) {
            isSymbols = !isSymbols;
            if (isSymbols) isCaps = false;
        }
        currentX += btnSmallW + padding;

        if (!isSymbols) {
            if (GuiButton({ currentX, bottomY, btnSmallW, rowHeight }, isCaps ? "#113#" : "#112#")) {
                isCaps = !isCaps;
            }
        }
        else {
            GuiLabel({ currentX, bottomY, btnSmallW, rowHeight }, "");
        }
        currentX += btnSmallW + padding;

        if (GuiButton({ currentX, bottomY, btnSpaceW, rowHeight }, "SPACE")) {
            InsertChar(' ');
        }
        currentX += btnSpaceW + padding;

        if (GuiButton({ currentX, bottomY, btnSmallW, rowHeight }, "OK")) {
            Hide();
        }
#endif
}
private:
#ifdef IS_MOBILE_PLATFORM
    void InsertChar(char c) {
        if (!targetBuffer) return;
        int len = (int)strlen(targetBuffer);
        if (len >= maxLen - 1) return;
        memmove(targetBuffer + cursorIndex + 1, targetBuffer + cursorIndex, len - cursorIndex + 1);
        targetBuffer[cursorIndex] = c;
        cursorIndex++;
    }
    void DeleteChar() {
        if (!targetBuffer || cursorIndex <= 0) return;
        int len = (int)strlen(targetBuffer);
        memmove(targetBuffer + cursorIndex - 1, targetBuffer + cursorIndex, len - cursorIndex + 1);
        cursorIndex--;
    }
#endif
};
// client\vircontrols\VirtualJoystick.cpp
﻿#include "VirtualJoystick.h"
#include "raymath.h"

#ifndef MAX_TOUCH_POINTS
#define MAX_TOUCH_POINTS 10
#endif

VirtualJoystick::VirtualJoystick() {

}

VirtualJoystick::VirtualJoystick(Vector2 pos, float rStick, float rBody) {
    position = pos;
    stickPosition = pos;
    radiusStick = rStick;
    radiusBody = rBody;
    radiusInteraction = rBody * 1.5f;
}

void VirtualJoystick::SetPosition(Vector2 pos) {
    position = pos;
    if (!dragging) {
        stickPosition = pos;
    }
}

void VirtualJoystick::SetPosition(float x, float y) {
    SetPosition({ x, y });
}

bool VirtualJoystick::IsTouchInBounds(Vector2 touchPos) const {
    return Vector2Distance(touchPos, position) <= radiusInteraction;
}

void VirtualJoystick::Update() {
    bool inputFound = false;
    Vector2 inputPos = { 0, 0 };


    if (dragging) {
        if (touchId == -2) {
            if (IsMouseButtonDown(MOUSE_LEFT_BUTTON)) {
                inputPos = GetMousePosition();
                inputFound = true;
            }
        }
        else {
            if (touchId < GetTouchPointCount()) {
                inputPos = GetTouchPosition(touchId);
                inputFound = true;
            }
        }

        if (!inputFound) {
            Reset();
            return;
        }
    }
    else {
        int count = GetTouchPointCount();
        for (int i = 0; i < count && i < MAX_TOUCH_POINTS; i++) {
            Vector2 touchPos = GetTouchPosition(i);
            if (IsTouchInBounds(touchPos)) {
                dragging = true;
                touchId = i;
                inputPos = touchPos;
                inputFound = true;
                break;
            }
        }

        if (!inputFound && IsMouseButtonDown(MOUSE_LEFT_BUTTON)) {
            Vector2 mousePos = GetMousePosition();
            if (IsTouchInBounds(mousePos)) {
                dragging = true;
                touchId = -2;
                inputPos = mousePos;
                inputFound = true;
            }
        }
    }

    if (dragging) {
        Vector2 direction = Vector2Subtract(inputPos, position);
        float distance = Vector2Length(direction);

        if (distance > radiusBody) {
            direction = Vector2Scale(Vector2Normalize(direction), radiusBody);
            stickPosition = Vector2Add(position, direction);
        }
        else {
            stickPosition = inputPos;
        }

        if (radiusBody > 0) {
            axis = Vector2Scale(direction, 1.0f / radiusBody);
        }

        if (Vector2Length(axis) > 1.0f) {
            axis = Vector2Normalize(axis);
        }
    }
    else {
        Reset();
    }
}

void VirtualJoystick::Reset() {
    stickPosition = position;
    dragging = false;
    touchId = -1;
    axis = { 0, 0 };
}

void VirtualJoystick::Draw() {

    DrawCircleV(position, radiusBody, colorBody);
    DrawRing(position, radiusBody, radiusBody + 2, 0, 360, 24, Fade(colorBody, 0.8f));

    DrawCircleV(stickPosition, radiusStick, colorStick);

    if (dragging) {
        DrawCircleV(stickPosition, radiusStick * 0.8f, Fade(WHITE, 0.3f));
    }
}
// client\vircontrols\VirtualJoystick.h
﻿#pragma once
#include <raylib.h>

class VirtualJoystick {
public:
    VirtualJoystick();
    VirtualJoystick(Vector2 pos, float radiusStick, float radiusBody);

    void Update();
    void Draw();
    void Reset();


    Vector2 GetAxis() const { return axis; }

    const Vector2& GetPosition() const { return position; }
    void SetPosition(Vector2 pos);
    void SetPosition(float x, float y);

    bool IsDragging() const { return dragging; }


    void SetColors(Color body, Color stick) {
        colorBody = body;
        colorStick = stick;
    }

    void SetRadii(float body, float stick, float interaction) {
        radiusBody = body;
        radiusStick = stick;
        radiusInteraction = interaction;
    }

private:
    int touchId = -1;
    bool dragging = false;

    Vector2 position = { 0, 0 };
    Vector2 stickPosition = { 0, 0 };
    Vector2 axis = { 0, 0 };


    float radiusStick = 20.0f;
    float radiusBody = 50.0f;
    float radiusInteraction = 60.0f;


    Color colorStick = { 200, 200, 200, 255 };
    Color colorBody = { 50, 50, 50, 150 };


    bool IsTouchInBounds(Vector2 touchPos) const;
};
// common\CMakeLists.txt
﻿file(GLOB COMMON_SOURCES "*.cpp" "net/*.cpp" "serial/*.cpp" "enet/*.cpp" "time/*.cpp")

add_library(GameCommon SHARED ${COMMON_SOURCES})

target_link_libraries(GameCommon PUBLIC enet::enet_shared raylib Bitsery::bitsery)
target_include_directories(GameCommon PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameCommon PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
target_include_directories(GameCommon PUBLIC ${BITSERY_EXTERNAL_INCLUDE_DIR})
// common\Common.cpp
﻿

// common\Common.h
﻿#pragma once
#include "fix_win32_compatibility.h"
#include <ctime>
#include <string>
#include <sstream>
#include "raylib.h"

/**
 * Precision explicit typedefs
 */
typedef float float32_t;
typedef double float64_t;

/**
 * Fixed width integer types
 */
#include <cstdint>

 /**
  * Define PI
  */
#ifndef M_PI
#define M_PI 3.14159265358979f
#endif

  /**
   * Define EPSILON
   */
#ifndef M_EPSILON
#define M_EPSILON 0.000001f
#endif



#define LOG_INFO(stream_input)  do { std::ostringstream s; s << stream_input; TraceLog(3, "[NET] %s", s.str().c_str()); } while(0)
#define LOG_WARN(stream_input)  do { std::ostringstream s; s << stream_input; TraceLog(4, "[NET WARN] %s", s.str().c_str()); } while(0)
#define LOG_ERROR(stream_input) do { std::ostringstream s; s << stream_input; TraceLog(5, "[NET ERROR] %s", s.str().c_str()); } while(0)
#define LOG_DEBUG(stream_input) do { std::ostringstream s; s << stream_input; TraceLog(2, "[NET DEBUG] %s", s.str().c_str()); } while(0)

// ------------------------------------------

/**
 * Utility lookup for const map types.
 */
template <typename T>
typename T::mapped_type get(T const& map, typename T::key_type const& key)
{
    typename T::const_iterator iter(map.find(key));
    return iter != map.end() ? iter->second : typename T::mapped_type();
}
// common\NetworkPackets.h
﻿// common\NetworkPackets.h
#pragma once
#include "PacketSerialization.h"
#include "raylib.h"
#include <cstdint>
#include <vector>
#include <string>

namespace GamePacket {
    enum Type : uint8_t {
        JOIN = 0,
        INPUT,
        INIT,
        SNAPSHOT,
        EVENT,
        STATS,
        ACTION,
        ADMIN_CMD,
        // Master Server Packets
        MASTER_REGISTER,
        MASTER_HEARTBEAT,
        MASTER_LIST_REQ,
        MASTER_LIST_RES
    };
}

namespace ActionType {
    enum : uint8_t {
        BUILD_WALL = 1,
        BUILD_TURRET,
        BUILD_MINE,
        UPGRADE_BUILDING
    };
}

namespace AdminCmdType {
    enum : uint8_t {
        LOGIN = 0,
        GIVE_SCRAP,
        GIVE_XP,
        KILL_ALL_ENEMIES,
        SPAWN_BOSS,
        CLEAR_BUILDINGS,
        RESET_SERVER
    };
}

enum class EntityType : uint8_t {
    PLAYER,
    BULLET,
    ENEMY,
    ARTIFACT,
    WALL,
    TURRET,
    MINE
};

namespace EnemyType {
    enum : uint8_t {
        BASIC = 0,
        FAST,
        TANK,
        BOSS,
        HOMING,
        LASER
    };
}

namespace ArtifactType {
    enum : uint8_t {
        DAMAGE = 0,
        SPEED,
        HEALTH,
        RELOAD,
        EMPTY = 255
    };
}


struct LobbyInfo {
    uint32_t id;
    std::string name;
    std::string ip;
    uint16_t port;
    uint8_t currentPlayers;
    uint8_t maxPlayers;
    uint8_t wave;

    template <typename S>
    void serialize(S& s) {
        s.value4b(id);
        s.text1b(name, 32);
        s.text1b(ip, 64);
        s.value2b(port);
        s.value1b(currentPlayers);
        s.value1b(maxPlayers);
        s.value1b(wave);
    }
};

struct MasterRegisterPacket {
    uint16_t gamePort;
    std::string serverName;
    uint8_t maxPlayers;

    template <typename S>
    void serialize(S& s) {
        s.value2b(gamePort);
        s.text1b(serverName, 32);
        s.value1b(maxPlayers);
    }
};

struct MasterHeartbeatPacket {
    uint8_t currentPlayers;
    uint8_t wave;

    template <typename S>
    void serialize(S& s) {
        s.value1b(currentPlayers);
        s.value1b(wave);
    }
};

struct MasterListResPacket {
    std::vector<LobbyInfo> lobbies;

    template <typename S>
    void serialize(S& s) {
        s.container(lobbies, 100);
    }
};


struct JoinPacket {
    std::string name;

    template <typename S>
    void serialize(S& s) {
        s.text1b(name, 32);
    }
};

struct EventPacket {
    uint8_t type;
    Vector2 pos;
    Color color;

    template <typename S>
    void serialize(S& s) {
        s.value1b(type);
        s.object(pos);
        s.object(color);
    }
};

struct ActionPacket {
    uint8_t type;
    Vector2 target;
    template <typename S>
    void serialize(S& s) {
        s.value1b(type);
        s.object(target);
    }
};

struct AdminCommandPacket {
    uint8_t cmdType;
    uint32_t value;
    template <typename S>
    void serialize(S& s) {
        s.value1b(cmdType);
        s.value4b(value);
    }
};

struct PlayerStatsPacket {
    uint32_t level;
    float currentXp;
    float maxXp;
    float maxHealth;
    float damage;
    float speed;
    uint32_t scrap;
    uint32_t kills;
    std::vector<uint8_t> inventory;
    bool isAdmin;

    template <typename S>
    void serialize(S& s) {
        s.value4b(level);
        s.value4b(currentXp);
        s.value4b(maxXp);
        s.value4b(maxHealth);
        s.value4b(damage);
        s.value4b(speed);
        s.value4b(scrap);
        s.value4b(kills);
        s.container1b(inventory, 6);
        s.boolValue(isAdmin);
    }
};

struct PlayerInputPacket {
    Vector2 movement;
    Vector2 aimTarget;
    bool isShooting;

    template <typename S>
    void serialize(S& s) {
        s.object(movement);
        s.object(aimTarget);
        s.boolValue(isShooting);
    }
};

struct EntityState {
    uint32_t id = 0;
    Vector2 position = { 0,0 };
    float rotation = 0;
    float health = 100.0f;
    float maxHealth = 100.0f;
    EntityType type = EntityType::PLAYER;
    uint8_t subtype = 0;
    float radius = 10.0f;
    Color color = WHITE;
    uint32_t level = 1;
    uint32_t kills = 0;
    std::string name = "";
    uint32_t ownerId = 0;
    template <typename S>
    void serialize(S& s) {
        s.value4b(id);
        s.object(position);
        s.value4b(rotation);
        s.value4b(health);
        s.value4b(maxHealth);

        uint8_t typeInt = static_cast<uint8_t>(type);
        s.value1b(typeInt);
        type = static_cast<EntityType>(typeInt);

        s.value1b(subtype);
        s.value4b(radius);
        s.object(color);
        s.value4b(level);
        s.value4b(kills);
        s.text1b(name, 16);
        s.value4b(ownerId);
    }
};

struct WorldSnapshotPacket {
    double serverTime;
    uint32_t wave;
    std::vector<EntityState> entities;

    template <typename S>
    void serialize(S& s) {
        s.value8b(serverTime);
        s.value4b(wave);
        s.container(entities, 10000);
    }
};

struct InitPacket {
    uint32_t playerId;

    template <typename S>
    void serialize(S& s) {
        s.value4b(playerId);
    }
};
// common\PacketSerialization.h
﻿#pragma once
#include "raylib.h"
#include <vector>
#include <cstdint>


#include <bitsery/bitsery.h>
#include <bitsery/adapter/buffer.h>
#include <bitsery/traits/vector.h>
#include <bitsery/traits/string.h>

using Buffer = std::vector<uint8_t>;

using OutputAdapter = bitsery::OutputBufferAdapter<Buffer>;
using InputAdapter = bitsery::InputBufferAdapter<Buffer>;


template <typename S>
void serialize(S& s, Vector2& v) {
    s.value4b(v.x);
    s.value4b(v.y);
}

template <typename S>
void serialize(S& s, Color& c) {
    s.value1b(c.r);
    s.value1b(c.g);
    s.value1b(c.b);
    s.value1b(c.a);
}
// common\enet\ENetClient.cpp
﻿#include "enet/ENetClient.h"

#include "Common.h"
#include "time/Time.h"

const uint8_t SERVER_ID = 0;
const std::time_t TIMEOUT_MS = 5000;
const std::time_t REQUEST_INTERVAL = Time::fromSeconds(1.0 / 60.0);
const uint8_t RELIABLE_CHANNEL = 0;
const uint8_t UNRELIABLE_CHANNEL = 1;
const uint8_t NUM_CHANNELS = 2;

ENetClient::Shared ENetClient::alloc()
{
    return std::make_shared<ENetClient>();
}

ENetClient::ENetClient()
    : host_(nullptr)
    , server_(nullptr)
    , currentMsgId_(0)
{
}

ENetClient::~ENetClient()
{
    disconnect();
    if (host_) {
        enet_host_destroy(host_);
        host_ = nullptr;
    }
}

bool ENetClient::connect(const std::string& host, uint32_t port)
{
    if (!host_) {
        host_ = enet_host_create(nullptr, 1, NUM_CHANNELS, 0, 0);
        if (!host_) {
            LOG_ERROR("FATAL: Cannot connect. Failed to create ENet client host.");
            return false;
        }
    }

    if (isConnected()) {
        return true;
    }

    ENetAddress address = { 0 };
    enet_address_set_host(&address, host.c_str());
    address.port = (enet_uint16)port;

    server_ = enet_host_connect(host_, &address, NUM_CHANNELS, 0);
    if (server_ == nullptr) {
        LOG_ERROR("No available peers for initiating an ENet connection");
        return false;
    }

    ENetEvent event;
    if (enet_host_service(host_, &event, TIMEOUT_MS) > 0 && event.type == ENET_EVENT_TYPE_CONNECT) {
        LOG_DEBUG("Connection to `" << host << ":" << port << "` succeeded");
        auto msg = Message::alloc(SERVER_ID, MessageType::CONNECT);
        queue_.push_back(msg);
        return true;
    }

    LOG_ERROR("Connection to `" << host << ":" << port << "` failed");
    enet_peer_reset(server_);
    server_ = nullptr;
    return false;
}

bool ENetClient::disconnect()
{
    if (!host_ || !server_) return false;
    if (!isConnected()) return false;

    LOG_DEBUG("Disconnecting from server...");
    enet_peer_disconnect(server_, 0);

    ENetEvent event;
    auto timestamp = Time::timestamp();
    bool success = false;

    while (true) {
        int32_t res = enet_host_service(host_, &event, 0);
        if (res > 0) {
            if (event.type == ENET_EVENT_TYPE_RECEIVE) {
                enet_packet_destroy(event.packet);
            }
            else if (event.type == ENET_EVENT_TYPE_DISCONNECT) {
                success = true;
                break;
            }
        }
        else if (res < 0) {
            break;
        }

        if (Time::timestamp() - timestamp > Time::fromMilliseconds(TIMEOUT_MS)) break;
    }

    if (!success) {
        enet_peer_reset(server_);
    }
    server_ = nullptr;
    return !success;
}

bool ENetClient::isConnected() const
{
    return host_ != nullptr && server_ != nullptr && server_->state == ENET_PEER_STATE_CONNECTED;
}

void ENetClient::on(uint32_t id, RequestHandler handler)
{
    handlers_[id] = handler;
}

void ENetClient::handleRequest(uint32_t requestId, StreamBuffer::Shared stream) const
{
    auto iter = handlers_.find(requestId);
    if (iter != handlers_.end()) {
        auto handler = iter->second;
        auto res = handler(SERVER_ID, stream);
        sendResponse(requestId, res);
    }
}

void ENetClient::sendResponse(uint32_t requestId, StreamBuffer::Shared stream) const
{
    if (!isConnected()) return;
    auto msg = Message::alloc(++currentMsgId_, requestId, MessageType::DATA_RESPONSE, stream);
    sendMessage(DeliveryType::RELIABLE, msg);
}

void ENetClient::sendMessage(DeliveryType type, Message::Shared msg) const
{
    if (!host_ || !server_) return;

    uint32_t channel = (type == DeliveryType::RELIABLE) ? RELIABLE_CHANNEL : UNRELIABLE_CHANNEL;
    uint32_t flags = (type == DeliveryType::RELIABLE) ? ENET_PACKET_FLAG_RELIABLE : ENET_PACKET_FLAG_UNSEQUENCED;

    auto data = msg->serialize();
    ENetPacket* p = enet_packet_create(&data[0], data.size(), flags);

    enet_peer_send(server_, channel, p);

    // enet_host_flush(host_); 
}

void ENetClient::send(DeliveryType type, StreamBuffer::Shared stream) const
{
    if (!isConnected()) return;
    auto msg = Message::alloc(++currentMsgId_, MessageType::DATA, stream);
    sendMessage(type, msg);
}

void ENetClient::sendRequest(uint32_t requestId, StreamBuffer::Shared stream) const
{
    auto msg = Message::alloc(++currentMsgId_, requestId, MessageType::DATA_REQUEST, stream);
    sendMessage(DeliveryType::RELIABLE, msg);
}

Message::Shared ENetClient::request(uint32_t requestId, StreamBuffer::Shared stream)
{
    if (!isConnected()) return nullptr;
    sendRequest(requestId, stream);

    auto timestamp = Time::timestamp();
    while (true) {
        auto msgs = poll();
        for (auto msg : msgs) {
            if (msg->type() == MessageType::DATA_RESPONSE && msg->requestId() == requestId) {
                return msg;
            }
            queue_.push_back(msg);
        }
        if (Time::timestamp() - timestamp > Time::fromMilliseconds(TIMEOUT_MS)) break;
        Time::sleep(REQUEST_INTERVAL);
    }
    return nullptr;
}

std::vector<Message::Shared> ENetClient::poll()
{
    std::vector<Message::Shared> msgs;

    if (!host_) return msgs;

    ENetEvent event;
    int packetsProcessed = 0;
    const int MAX_PACKETS_PER_FRAME = 100;

    while (packetsProcessed < MAX_PACKETS_PER_FRAME) {
        int32_t res = enet_host_service(host_, &event, 0);
        if (res > 0) {
            packetsProcessed++;
            if (event.type == ENET_EVENT_TYPE_RECEIVE) {
                auto stream = StreamBuffer::alloc(event.packet->data, event.packet->dataLength);
                auto msg = Message::alloc(SERVER_ID);
                msg->deserialize(stream);
                msgs.push_back(msg);

                if (msg->type() == MessageType::DATA_REQUEST) {
                    handleRequest(msg->requestId(), msg->stream());
                }
                enet_packet_destroy(event.packet);
            }
            else if (event.type == ENET_EVENT_TYPE_DISCONNECT) {
                auto msg = Message::alloc(SERVER_ID, MessageType::DISCONNECT);
                msgs.push_back(msg);
                server_ = nullptr;
            }
        }
        else {
            break;
        }
    }
    if (!queue_.empty()) {
        msgs.insert(msgs.end(), queue_.begin(), queue_.end());
        queue_.clear();
    }
    return msgs;
}
// common\enet\ENetClient.h
﻿#pragma once

#include "net/Client.h"
#include "net/DeliveryType.h"
#include "net/Message.h"

#include <enet.h>

#include <iostream>
#include <map>
#include <memory>
#include <vector>

class ENetClient : public Client {

public:
    typedef std::shared_ptr<ENetClient> Shared;
    static Shared alloc();

    ENetClient();
    ~ENetClient();

    bool connect(const std::string&, uint32_t);
    bool disconnect();
    bool isConnected() const;

    void send(DeliveryType, StreamBuffer::Shared) const;
    Message::Shared request(uint32_t, StreamBuffer::Shared);
    std::vector<Message::Shared> poll();

    void on(uint32_t, RequestHandler);

private:
    void sendMessage(DeliveryType type, Message::Shared msg) const;
    void sendRequest(uint32_t responseId, StreamBuffer::Shared stream) const;
    void sendResponse(uint32_t requestId, StreamBuffer::Shared stream) const;
    void handleRequest(uint32_t, StreamBuffer::Shared stream) const;

    // prevent copy-construction
    ENetClient(const ENetClient&);
    // prevent assignment
    ENetClient& operator=(const ENetClient&);

    ENetHost* host_;
    ENetPeer* server_;
    std::vector<Message::Shared> queue_;
    std::map<uint32_t, RequestHandler> handlers_;
    mutable uint32_t currentMsgId_;
};

// common\enet\ENetServer.cpp
﻿#include "enet/ENetServer.h"

#include "Common.h"
#include "time/Time.h"

const std::time_t TIMEOUT_MS = 5000;
const uint8_t RELIABLE_CHANNEL = 0;
const uint8_t UNRELIABLE_CHANNEL = 1;
const uint8_t NUM_CHANNELS = 2;

std::string addressAndPortToString(const ENetAddress* address)
{
    char ip_address_str[256];
    enet_address_get_host_ip(address, ip_address_str, sizeof(ip_address_str));
    return std::string(ip_address_str) + ":" + std::to_string(address->port);
}
std::string addressToString(const ENetAddress* address)
{
    char ip_address_str[256];
    enet_address_get_host_ip(address, ip_address_str, sizeof(ip_address_str));
    return std::string(ip_address_str);
}
ENetServer::Shared ENetServer::alloc()
{
    return std::make_shared<ENetServer>();
}
std::string ENetServer::getPeerIP(uint32_t id) const {
    ENetPeer* peer = getClient(id);
    if (peer) {
        return addressToString(&peer->address);
    }
    return "Unknown";
}
ENetServer::ENetServer()
    : host_(nullptr)
    , currentMsgId_(0)
{
}

ENetServer::~ENetServer()
{
    stop();
}

bool ENetServer::start(uint32_t port, uint32_t maxClients)
{
    if (host_) return true;

    ENetAddress address = { 0 };
    address.host = ENET_HOST_ANY;
    address.port = (enet_uint16)port;

    host_ = enet_host_create(&address, (size_t)maxClients, NUM_CHANNELS, 0, 0);

    if (host_ == nullptr) {
        LOG_ERROR("Failed to create ENet server host (Port might be busy)");
        return false;
    }
    return true;
}

bool ENetServer::stop()
{
    if (!host_) return false;

    if (!isRunning()) return false;

    for (auto iter : clients_) {
        enet_peer_disconnect(iter.second, 0);
    }

    auto timestamp = Time::timestamp();
    bool success = false;
    ENetEvent event;

    while (true) {
        int32_t res = enet_host_service(host_, &event, 0);
        if (res > 0) {
            if (event.type == ENET_EVENT_TYPE_RECEIVE) {
                enet_packet_destroy(event.packet);
            }
            else if (event.type == ENET_EVENT_TYPE_DISCONNECT) {
                clients_.erase(event.peer->incomingPeerID);
            }
            else if (event.type == ENET_EVENT_TYPE_CONNECT) {
                enet_peer_disconnect(event.peer, 0);
            }
        }
        else if (res < 0) {
            break;
        }
        else {
            if (clients_.empty()) {
                success = true;
                break;
            }
        }
        if (Time::timestamp() - timestamp > Time::fromMilliseconds(TIMEOUT_MS)) break;
    }

    for (auto iter : clients_) {
        enet_peer_reset(iter.second);
    }
    clients_.clear();

    enet_host_destroy(host_);
    host_ = nullptr;
    return !success;
}

bool ENetServer::isRunning() const
{
    return host_ != nullptr;
}

uint32_t ENetServer::numClients() const
{
    if (!host_) return 0;
    return host_->connectedPeers;
}

void ENetServer::on(uint32_t id, RequestHandler handler)
{
    handlers_[id] = handler;
}

void ENetServer::handleRequest(uint32_t id, uint32_t requestId, StreamBuffer::Shared stream) const
{
    auto iter = handlers_.find(requestId);
    if (iter != handlers_.end()) {
        auto handler = iter->second;
        auto res = handler(id, stream);
        sendResponse(id, requestId, res);
    }
}

ENetPeer* ENetServer::getClient(uint32_t id) const
{
    auto iter = clients_.find(id);
    if (iter == clients_.end()) return nullptr;
    return iter->second;
}

void ENetServer::sendResponse(uint32_t id, uint32_t requestId, StreamBuffer::Shared stream) const
{
    if (!host_) return;
    auto client = getClient(id);
    if (!client) return;

    auto msg = Message::alloc(++currentMsgId_, requestId, MessageType::DATA_RESPONSE, stream);
    sendMessage(id, DeliveryType::RELIABLE, msg);
}

void ENetServer::sendMessage(uint32_t id, DeliveryType type, Message::Shared msg) const
{
    if (!host_) return;
    auto client = getClient(id);
    if (!client) return;

    uint32_t channel = (type == DeliveryType::RELIABLE) ? RELIABLE_CHANNEL : UNRELIABLE_CHANNEL;
    uint32_t flags = (type == DeliveryType::RELIABLE) ? ENET_PACKET_FLAG_RELIABLE : ENET_PACKET_FLAG_UNSEQUENCED;

    auto data = msg->serialize();
    ENetPacket* p = enet_packet_create(&data[0], data.size(), flags);

    enet_peer_send(client, channel, p);
    //enet_host_flush(host_);
}

void ENetServer::send(uint32_t id, DeliveryType type, StreamBuffer::Shared stream) const
{
    auto msg = Message::alloc(++currentMsgId_, MessageType::DATA, stream);
    sendMessage(id, type, msg);
}

void ENetServer::broadcastMessage(DeliveryType type, Message::Shared msg) const
{
    if (!host_) return;
    if (numClients() == 0) return;

    uint32_t channel = (type == DeliveryType::RELIABLE) ? RELIABLE_CHANNEL : UNRELIABLE_CHANNEL;
    uint32_t flags = (type == DeliveryType::RELIABLE) ? ENET_PACKET_FLAG_RELIABLE : ENET_PACKET_FLAG_UNSEQUENCED;

    auto data = msg->serialize();
    ENetPacket* p = enet_packet_create(&data[0], data.size(), flags);

    enet_host_broadcast(host_, channel, p);
    //enet_host_flush(host_);
}

void ENetServer::broadcast(DeliveryType type, StreamBuffer::Shared stream) const
{
    auto msg = Message::alloc(++currentMsgId_, MessageType::DATA, stream);
    broadcastMessage(type, msg);
}

std::vector<Message::Shared> ENetServer::poll()
{
    std::vector<Message::Shared> msgs;
    if (!host_) return msgs;

    ENetEvent event;
    while (true) {
        int32_t res = enet_host_service(host_, &event, 0);
        if (res > 0) {
            if (event.type == ENET_EVENT_TYPE_RECEIVE) {
                auto stream = StreamBuffer::alloc(event.packet->data, event.packet->dataLength);
                auto msg = Message::alloc(event.peer->incomingPeerID);
                msg->deserialize(stream);
                msgs.push_back(msg);

                if (msg->type() == MessageType::DATA_REQUEST) {
                    handleRequest(event.peer->incomingPeerID, msg->requestId(), msg->stream());
                }
                enet_packet_destroy(event.packet);

            }
            else if (event.type == ENET_EVENT_TYPE_CONNECT) {
                auto msg = Message::alloc(event.peer->incomingPeerID, MessageType::CONNECT);
                msgs.push_back(msg);
                clients_[event.peer->incomingPeerID] = event.peer;

            }
            else if (event.type == ENET_EVENT_TYPE_DISCONNECT) {
                auto msg = Message::alloc(event.peer->incomingPeerID, MessageType::DISCONNECT);
                msgs.push_back(msg);
                clients_.erase(event.peer->incomingPeerID);
            }
        }
        else {
            break;
        }
    }
    return msgs;
}
// common\enet\ENetServer.h
﻿#pragma once
#include "fix_win32_compatibility.h"
#include "net/DeliveryType.h"
#include "net/Message.h"
#include "net/Server.h"

#include <enet.h>

#include <iostream>
#include <map>
#include <memory>
#include <vector>

class ENetServer : public Server {

public:
    typedef std::shared_ptr<ENetServer> Shared;
    static Shared alloc();

    ENetServer();
    ~ENetServer();

    bool start(uint32_t port, uint32_t maxClients);
    bool stop();
    bool isRunning() const;

    uint32_t numClients() const;

    void send(uint32_t, DeliveryType, StreamBuffer::Shared) const;
    void broadcast(DeliveryType, StreamBuffer::Shared) const;
    std::vector<Message::Shared> poll();

    void on(uint32_t, RequestHandler);
    std::string getPeerIP(uint32_t id) const;
private:
    ENetPeer* getClient(uint32_t) const;
    void sendMessage(uint32_t id, DeliveryType type, Message::Shared msg) const;
    void broadcastMessage(DeliveryType type, Message::Shared msg) const;
    void sendResponse(uint32_t, uint32_t requestId, StreamBuffer::Shared stream) const;
    void handleRequest(uint32_t, uint32_t, StreamBuffer::Shared stream) const;

    // prevent copy-construction
    ENetServer(const ENetServer&);
    // prevent assignment
    ENetServer& operator=(const ENetServer&);

    ENetHost* host_;
    // NOTE: ENet allocates all peers at once and doesn't shuffle them,
    // which leads to non-contiguous connected peers. This map
    // will make it easier to manage them by id
    std::map<uint32_t, ENetPeer*> clients_;
    std::vector<Message::Shared> queue_;
    std::map<uint32_t, RequestHandler> handlers_;
    mutable uint32_t currentMsgId_;
};

std::string addressAndPortToString(const ENetAddress* address);

// common\net\Client.cpp
#include "net/Client.h"

Client::Client()
{
}

Client::~Client()
{
}

// common\net\Client.h
﻿#pragma once

#include "Common.h"
#include "net/DeliveryType.h"
#include "net/Message.h"
#include "serial/StreamBuffer.h"

#include <memory>
#include <vector>

class Client {

public:
    typedef std::shared_ptr<Client> Shared;

    Client();
    virtual ~Client();

    virtual bool connect(const std::string&, uint32_t) = 0;
    virtual bool disconnect() = 0;
    virtual bool isConnected() const = 0;

    virtual void send(DeliveryType, StreamBuffer::Shared) const = 0;
    virtual Message::Shared request(uint32_t, StreamBuffer::Shared) = 0;
    virtual std::vector<Message::Shared> poll() = 0;

    virtual void on(uint32_t, RequestHandler) = 0;

private:
    // prevent copy-construction
    Client(const Client&);
    // prevent assignment
    Client& operator=(const Client&);
};

// common\net\DeliveryType.h
#pragma once

enum class DeliveryType {
    RELIABLE,
    UNRELIABLE
};

// common\net\Message.cpp
﻿#include "net/Message.h"

Message::Shared Message::alloc(uint32_t id, uint8_t type, StreamBuffer::Shared stream)
{
    return std::make_shared<Message>(id, type, stream);
}

Message::Shared Message::alloc(uint32_t id, uint32_t requestId, uint8_t type, StreamBuffer::Shared stream)
{
    return std::make_shared<Message>(id, requestId, type, stream);
}

Message::Shared Message::alloc(uint32_t peerId, uint8_t type)
{
    return std::make_shared<Message>(peerId, type);
}

Message::Shared Message::alloc(uint32_t peerId)
{
    return std::make_shared<Message>(peerId);
}

Message::Message(uint32_t id, uint8_t type, StreamBuffer::Shared stream)
    : id_(id)
    , peerId_(0)
    , requestId_(0)
    , type_(type)
    , stream_(stream)
{
}

Message::Message(uint32_t id, uint32_t requestId, uint8_t type, StreamBuffer::Shared stream)
    : id_(id)
    , peerId_(0)
    , requestId_(requestId)
    , type_(type)
    , stream_(stream)
{
}

Message::Message(uint32_t peerId, uint8_t type)
    : id_(0)
    , peerId_(peerId)
    , requestId_(0)
    , type_(type)
{
}

Message::Message(uint32_t peerId)
    : id_(0)
    , peerId_(peerId)
    , requestId_(0)
    , type_(0)
{
}

uint32_t Message::id() const
{
    return id_;
}

uint32_t Message::requestId() const
{
    return requestId_;
}

uint32_t Message::peerId() const
{
    return peerId_;
}

uint8_t Message::type() const
{
    return type_;
}

StreamBuffer::Shared Message::stream() const
{
    return stream_;
}

std::vector<uint8_t> Message::serialize() const
{
    auto header = StreamBuffer::alloc();
    header << id_;
    header << requestId_;
    header << type_;
    return merge(header, stream_)->buffer();
}

void Message::deserialize(StreamBuffer::Shared stream)
{
    stream >> id_;
    stream >> requestId_;
    stream >> type_;
    stream_ = stream;
}

// common\net\Message.h
﻿#pragma once

#include "serial/StreamBuffer.h"

#include <memory>
#include <string>
#include <vector>
#include <functional>

typedef std::function<StreamBuffer::Shared(uint32_t, StreamBuffer::Shared)> RequestHandler;

namespace MessageType {
enum Types {
    CONNECT,
    DISCONNECT,
    DATA,
    DATA_REQUEST,
    DATA_RESPONSE
};
}

class Message {

public:
    typedef std::shared_ptr<Message> Shared;
    static Shared alloc(uint32_t id, uint8_t, StreamBuffer::Shared); // data
    static Shared alloc(uint32_t id, uint32_t requestId, uint8_t, StreamBuffer::Shared); // request / response
    static Shared alloc(uint32_t peerId, uint8_t); // connect / disconnect
    static Shared alloc(uint32_t peerId); // deserialize from

    Message(uint32_t id, uint8_t, StreamBuffer::Shared); // data
    Message(uint32_t id, uint32_t requestId, uint8_t, StreamBuffer::Shared); // request / response
    Message(uint32_t peerId, uint8_t); // connect / disconnect
    Message(uint32_t peerId); // deserialize from

    uint32_t peerId() const;
    uint32_t id() const;
    uint32_t requestId() const;
    uint8_t type() const;
    StreamBuffer::Shared stream() const;

    std::vector<uint8_t> serialize() const;
    void deserialize(StreamBuffer::Shared);

private:
    // prevent copy-construction
    Message(const Message&);
    // prevent assignment
    Message& operator=(const Message&);

    uint32_t id_;
    uint32_t peerId_;
    uint32_t requestId_;
    uint8_t type_;
    StreamBuffer::Shared stream_;
};

// common\net\Server.cpp
#include "net/Server.h"

Server::Server()
{
}

Server::~Server()
{
}

// common\net\Server.h
﻿#pragma once

#include "../Common.h"
#include "net/DeliveryType.h"
#include "net/Message.h"
#include "serial/StreamBuffer.h"

#include <memory>
#include <vector>

class Server {

public:
    typedef std::shared_ptr<Server> Shared;

    Server();
    virtual ~Server();

    virtual bool start(uint32_t port, uint32_t maxClients) = 0;

    virtual bool stop() = 0;
    virtual bool isRunning() const = 0;

    virtual uint32_t numClients() const = 0;

    virtual void send(uint32_t, DeliveryType, StreamBuffer::Shared) const = 0;
    virtual void broadcast(DeliveryType, StreamBuffer::Shared) const = 0;
    virtual std::vector<Message::Shared> poll() = 0;

    virtual void on(uint32_t, RequestHandler) = 0;

private:
    Server(const Server&);
    Server& operator=(const Server&);
};
// common\serial\Serialization.cpp
﻿#include "serial/Serialization.h"

#include <cstring>

uint64_t pack754(float64_t f, uint32_t bits, uint32_t expbits)
{
    float64_t fnorm;
    int32_t shift;
    int64_t sign, expo, significand;
    uint32_t significandbits = bits - expbits - 1; // -1 for sign bit
    if (f == 0.0) {
        // get this special case out of the way
        return 0;
    }
    // check sign and begin normalization
    if (f < 0) {
        sign = 1;
        fnorm = -f;
    } else {
        sign = 0;
        fnorm = f;
    }
    // get the normalized form of f and track the exponent
    shift = 0;
    while (fnorm >= 2.0) {
        fnorm /= 2.0;
        shift++;
    }
    while (fnorm < 1.0) {
        fnorm *= 2.0;
        shift--;
    }
    fnorm = fnorm - 1.0;
    // calculate the binary form (non-float) of the significand data
    significand = fnorm * ((1LL << significandbits) + 0.5f);
    // get the biased exponent
    expo = shift + ((1 << (expbits - 1)) - 1); // shift + bias
    // return the final answer
    return (sign << (bits - 1)) | (expo << (bits - expbits - 1)) | significand;
}

float64_t unpack754(uint64_t i, uint32_t bits, uint32_t expbits)
{
    float64_t result;
    int64_t shift;
    uint32_t bias;
    uint32_t significandbits = bits - expbits - 1; // -1 for sign bit
    if (i == 0) {
        // get this special case out of the way
        return 0.0;
    }
    // pull the significand
    result = (i & ((1LL << significandbits) - 1)); // mask
    result /= (1LL << significandbits); // convert back to float
    result += 1.0f; // add the one back on
    // deal with the exponent
    bias = (1 << (expbits - 1)) - 1;
    shift = ((i >> significandbits) & ((1LL << expbits) - 1)) - bias;
    while (shift > 0) {
        result *= 2.0;
        shift--;
    }
    while (shift < 0) {
        result /= 2.0;
        shift++;
    }
    // sign it
    result *= (i >> (bits - 1)) & 1 ? -1.0 : 1.0;
    return result;
}

// common\serial\Serialization.h
﻿#pragma once

#include "Common.h"

/**
 * Bit packing macros
 * Brian "Beej Jorgensen" Hall
 * http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#serialization
 */
#define pack754_32(f) (static_cast<uint32_t>(pack754((f), 32, 8)))
#define pack754_64(f) (pack754((f), 64, 11))
#define unpack754_32(i) (static_cast<float32_t>(unpack754((i), 32, 8)))
#define unpack754_64(i) (unpack754((i), 64, 11))

uint64_t pack754(float64_t f, uint32_t bits, uint32_t expbits);
float64_t unpack754(uint64_t i, uint32_t bits, uint32_t expbits);

// common\serial\StreamBuffer.cpp
﻿#include "StreamBuffer.h"
#include "Serialization.h"

#include <fstream>
#include <cstring>

StreamBuffer::Shared StreamBuffer::alloc(size_t numBytes)
{
    return std::make_shared<StreamBuffer>(numBytes);
}

StreamBuffer::Shared StreamBuffer::alloc(const uint8_t* data, size_t numBytes)
{
    return std::make_shared<StreamBuffer>(data, numBytes);
}

StreamBuffer::StreamBuffer(size_t numBytes)
    : gpos_(0)
    , ppos_(0)
{
    buffer_.reserve(numBytes);
}

StreamBuffer::StreamBuffer(const uint8_t* data, size_t numBytes)
    : gpos_(0)
    , ppos_(0)
{
    buffer_.reserve(numBytes);
    buffer_.assign(data, data + numBytes);
}

const std::vector<uint8_t>& StreamBuffer::buffer() const
{
    return buffer_;
}

void StreamBuffer::seekg(size_t pos)
{
    gpos_ = pos;
}

void StreamBuffer::seekp(size_t pos)
{
    ppos_ = pos;
}

size_t StreamBuffer::tellg() const
{
    return gpos_;
}

size_t StreamBuffer::tellp() const
{
    return ppos_;
}

size_t StreamBuffer::size() const
{
    return buffer_.size();
}

bool StreamBuffer::eof() const
{
    return gpos_ >= buffer_.size();
}

// --- WRITE IMPLEMENTATIONS ---

void StreamBuffer::write(bool data)
{
    buffer_.push_back(data ? 1 : 0);
    ppos_++;
}

void StreamBuffer::write(uint8_t data)
{
    buffer_.push_back(data);
    ppos_++;
}

void StreamBuffer::write(uint16_t data)
{
    uint8_t buff[2];
    buff[0] = (uint8_t)(data >> 8);
    buff[1] = (uint8_t)(data);
    buffer_.insert(buffer_.end(), buff, buff + 2);
    ppos_ += 2;
}

void StreamBuffer::write(uint32_t data)
{
    uint8_t buff[4];
    buff[0] = (uint8_t)(data >> 24);
    buff[1] = (uint8_t)(data >> 16);
    buff[2] = (uint8_t)(data >> 8);
    buff[3] = (uint8_t)(data);
    buffer_.insert(buffer_.end(), buff, buff + 4);
    ppos_ += 4;
}

void StreamBuffer::write(uint64_t data)
{
    uint8_t buff[8];
    buff[0] = (uint8_t)(data >> 56);
    buff[1] = (uint8_t)(data >> 48);
    buff[2] = (uint8_t)(data >> 40);
    buff[3] = (uint8_t)(data >> 32);
    buff[4] = (uint8_t)(data >> 24);
    buff[5] = (uint8_t)(data >> 16);
    buff[6] = (uint8_t)(data >> 8);
    buff[7] = (uint8_t)(data);
    buffer_.insert(buffer_.end(), buff, buff + 8);
    ppos_ += 8;
}

void StreamBuffer::write(float32_t data)
{
    write(pack754_32(data));
}

void StreamBuffer::write(float64_t data)
{
    write(pack754_64(data));
}

void StreamBuffer::write(const std::string& data)
{
    auto len = data.size();
    write(uint32_t(len));
    const char* bytes = data.c_str();
    for (uint32_t i = 0; i < len; i++) {
        write(uint8_t(bytes[i]));
    }
}

void StreamBuffer::write(std::time_t data)
{
    write(uint64_t(data));
}

// --- RAYLIB TYPES WRITE ---

void StreamBuffer::write(const Vector2& data)
{
    write((float32_t)data.x);
    write((float32_t)data.y);
}

void StreamBuffer::write(const Vector3& data)
{
    write((float32_t)data.x);
    write((float32_t)data.y);
    write((float32_t)data.z);
}

void StreamBuffer::write(const Quaternion& data)
{
    write((float32_t)data.x);
    write((float32_t)data.y);
    write((float32_t)data.z);
    write((float32_t)data.w);
}

void StreamBuffer::write(const Color& data)
{
    write((uint8_t)data.r);
    write((uint8_t)data.g);
    write((uint8_t)data.b);
    write((uint8_t)data.a);
}

// --- READ IMPLEMENTATIONS ---

void StreamBuffer::read(bool& data)
{
    if (eof()) { data = false; return; }
    data = buffer_[gpos_++] ? true : false;
}

void StreamBuffer::read(uint8_t& data)
{
    if (eof()) { data = 0; return; }
    data = buffer_[gpos_++];
}

void StreamBuffer::read(int8_t& data)
{
    if (eof()) { data = 0; return; }
    data = (int8_t)buffer_[gpos_++];
}

void StreamBuffer::read(uint16_t& data)
{
    if (gpos_ + 2 > buffer_.size()) { data = 0; return; }
    data = ((uint16_t)buffer_[gpos_] << 8) | buffer_[gpos_ + 1];
    gpos_ += 2;
}

void StreamBuffer::read(int16_t& data)
{
    uint16_t ui = 0;
    read(ui);
    if (ui <= 0x7fffu) {
        data = ui;
    }
    else {
        data = -1 - (int16_t)(0xffffu - ui);
    }
}

void StreamBuffer::read(uint32_t& data)
{
    if (gpos_ + 4 > buffer_.size()) { data = 0; return; }
    data = ((uint32_t)buffer_[gpos_] << 24) |
        ((uint32_t)buffer_[gpos_ + 1] << 16) |
        ((uint32_t)buffer_[gpos_ + 2] << 8) |
        buffer_[gpos_ + 3];
    gpos_ += 4;
}

void StreamBuffer::read(int32_t& data)
{
    uint32_t ui = 0;
    read(ui);
    if (ui <= 0x7fffffffu) {
        data = ui;
    }
    else {
        data = -1 - (int32_t)(0xffffffffu - ui);
    }
}

void StreamBuffer::read(uint64_t& data)
{
    if (gpos_ + 8 > buffer_.size()) { data = 0; return; }
    data = ((uint64_t)buffer_[gpos_] << 56) |
        ((uint64_t)buffer_[gpos_ + 1] << 48) |
        ((uint64_t)buffer_[gpos_ + 2] << 40) |
        ((uint64_t)buffer_[gpos_ + 3] << 32) |
        ((uint64_t)buffer_[gpos_ + 4] << 24) |
        ((uint64_t)buffer_[gpos_ + 5] << 16) |
        ((uint64_t)buffer_[gpos_ + 6] << 8) |
        buffer_[gpos_ + 7];
    gpos_ += 8;
}

void StreamBuffer::read(int64_t& data)
{
    uint64_t ui = 0;
    read(ui);
    if (ui <= 0x7fffffffffffffffu) {
        data = ui;
    }
    else {
        data = -1 - (int64_t)(0xffffffffffffffffu - ui);
    }
}

void StreamBuffer::read(float32_t& data)
{
    uint32_t packed = 0;
    read(packed);
    data = unpack754_32(packed);
}

void StreamBuffer::read(float64_t& data)
{
    uint64_t packed = 0;
    read(packed);
    data = unpack754_64(packed);
}

#ifdef __APPLE__
void StreamBuffer::read(std::time_t& data)
{
    uint64_t val = 0;
    read(val);
    data = val;
}
#endif

void StreamBuffer::read(std::string& data)
{
    uint32_t len = 0;
    read(len);
    if (len > 0 && gpos_ + len <= buffer_.size()) {
        data.assign((const char*)&buffer_[gpos_], len);
        gpos_ += len;
    }
    else {
        data = "";
    }
}

// --- RAYLIB TYPES READ ---

void StreamBuffer::read(Vector2& data)
{
    read((float32_t&)data.x);
    read((float32_t&)data.y);
}

void StreamBuffer::read(Vector3& data)
{
    read((float32_t&)data.x);
    read((float32_t&)data.y);
    read((float32_t&)data.z);
}

void StreamBuffer::read(Quaternion& data)
{
    read((float32_t&)data.x);
    read((float32_t&)data.y);
    read((float32_t&)data.z);
    read((float32_t&)data.w);
}

void StreamBuffer::read(Color& data)
{
    read((uint8_t&)data.r);
    read((uint8_t&)data.g);
    read((uint8_t&)data.b);
    read((uint8_t&)data.a);
}

void StreamBuffer::writeToFile(const std::string& path) const
{
    std::ofstream file(path, std::ios::binary);
    if (file.is_open()) {
        file.write((const char*)buffer_.data(), buffer_.size());
        file.close();
    }
}

StreamBuffer::Shared merge(const StreamBuffer::Shared& a, const StreamBuffer::Shared& b)
{
    std::vector<uint8_t> abuff;
    std::vector<uint8_t> bbuff;
    size_t size = 0;
    if (a) {
        abuff = a->buffer();
        size += abuff.size();
    }
    if (b) {
        bbuff = b->buffer();
        size += bbuff.size();
    }
    auto bytes = std::vector<uint8_t>();
    bytes.reserve(size);
    if (a) {
        bytes.insert(bytes.end(), abuff.begin(), abuff.end());
    }
    if (b) {
        bytes.insert(bytes.end(), bbuff.begin(), bbuff.end());
    }
    return StreamBuffer::alloc(bytes.data(), bytes.size());
}
// common\serial\StreamBuffer.h
﻿#pragma once

#include "../Common.h"
#include "raylib.h"

#include <memory>
#include <vector>
#include <string>
#include <ctime>

class StreamBuffer {

public:
    typedef std::shared_ptr<StreamBuffer> Shared;
    static Shared alloc(size_t = 1024);
    static Shared alloc(const uint8_t*, size_t);

    explicit StreamBuffer(size_t = 1024);
    StreamBuffer(const uint8_t*, size_t);

    const std::vector<uint8_t>& buffer() const;
    void seekg(size_t);
    void seekp(size_t);
    size_t tellg() const;
    size_t tellp() const;
    size_t size() const;
    bool eof() const;

    void write(bool);
    void write(uint8_t);
    void write(uint16_t);
    void write(uint32_t);
    void write(uint64_t);
    void write(float32_t);
    void write(float64_t);
    void write(std::time_t);
    void write(const std::string&);

    void write(const Vector2&);
    void write(const Vector3&);
    void write(const Quaternion&);
    void write(const Color&);

    void read(bool&);
    void read(uint8_t&);
    void read(int8_t&);
    void read(uint16_t&);
    void read(int16_t&);
    void read(uint32_t&);
    void read(int32_t&);
    void read(uint64_t&);
    void read(int64_t&);
    void read(float32_t&);
    void read(float64_t&);
    void read(std::string&);
#ifdef __APPLE__
    void read(std::time_t&);
#endif

    void read(Vector2&);
    void read(Vector3&);
    void read(Quaternion&);
    void read(Color&);

    void writeToFile(const std::string&) const;

private:
    StreamBuffer(const StreamBuffer&);

    StreamBuffer& operator=(const StreamBuffer&);

    size_t gpos_;
    size_t ppos_;
    std::vector<uint8_t> buffer_;
};

StreamBuffer::Shared merge(const StreamBuffer::Shared&, const StreamBuffer::Shared&);


template <typename T>
StreamBuffer::Shared& operator<<(StreamBuffer::Shared& stream, const std::vector<T>& data)
{
    stream->write(uint32_t(data.size()));
    for (auto& d : data) {
        stream->write(d);
    }
    return stream;
}

template <typename T>
StreamBuffer::Shared& operator>>(StreamBuffer::Shared& stream, std::vector<T>& data)
{
    uint32_t size = 0;
    stream->read(size);
    data.resize(size);
    for (auto i = uint32_t(0); i < size; i++) {
        stream->read(data[i]);
    }
    return stream;
}

template <typename T>
StreamBuffer::Shared& operator<<(StreamBuffer::Shared& stream, const T& data)
{
    stream->write(data);
    return stream;
}

template <typename T>
StreamBuffer::Shared& operator>>(StreamBuffer::Shared& stream, T& data)
{
    stream->read(data);
    return stream;
}
// common\time\Time.cpp
﻿#include "time/Time.h"

#include <iomanip>
#include <sstream>

std::string to_string_fixed(float64_t val, uint8_t n = 2)
{
    std::ostringstream out;
    out << std::setprecision(n) << std::fixed << val;
    return out.str();
}

namespace Time {

std::time_t timestamp()
{
    return std::chrono::duration_cast<std::chrono::microseconds>(
        std::chrono::system_clock::now().time_since_epoch())
        .count();
}

void sleep(std::time_t duration)
{
    std::this_thread::sleep_for(std::chrono::microseconds(duration));
}

std::time_t fromMinutes(float64_t minutes)
{
    return minutes * 1000000 * 60;
}

std::time_t fromSeconds(float64_t seconds)
{
    return seconds * 1000000;
}

std::time_t fromMilliseconds(float64_t milliseconds)
{
    return milliseconds * 1000;
}

float64_t toMinutes(std::time_t t)
{
    return t / (1000000.0 * 60.0);
}

float64_t toSeconds(std::time_t t)
{
    return t / 1000000.0;
}

float64_t toMilliseconds(std::time_t t)
{
    return t / 1000.0;
}

std::string format(std::time_t microseconds)
{
    auto milliseconds = microseconds / 1000.0;
    if (milliseconds < 1) {
        return to_string_fixed(microseconds) + "μs";
    }
    auto seconds = milliseconds / 1000.0;
    if (seconds < 1) {
        return to_string_fixed(milliseconds) + "ms";
    }
    auto minutes = seconds / 60.0;
    if (minutes < 1) {
        return to_string_fixed(seconds) + "s";
    }
    auto hours = minutes / 60.0;
    if (hours < 1) {
        return to_string_fixed(minutes) + "m";
    }
    return to_string_fixed(hours) + "h";
}
}

// common\time\Time.h
#pragma once

#include "Common.h"

#include <chrono>
#include <ctime>
#include <string>
#include <thread>

namespace Time {

/**
 * Get timestamp in microseconds.
 */
std::time_t timestamp();

/**
 * Sleep thread for N microseconds.
 */
void sleep(std::time_t);

/**
 * Converts the arguments to microseconds.
 */
std::time_t fromMinutes(float64_t);
std::time_t fromSeconds(float64_t);
std::time_t fromMilliseconds(float64_t);

/**
 * Converts the arguments from microseconds to the specified type.
 */
float64_t toMinutes(std::time_t);
float64_t toSeconds(std::time_t);
float64_t toMilliseconds(std::time_t);

/**
 * Format microsecond into a pretty string.
 */
std::string format(std::time_t);
}

// engine\CMakeLists.txt
﻿add_library(GameEngine SHARED
    Utils/ConfigManager.h
    Utils/ConfigManager.cpp
    ECS/GameObject.h
    ECS/Player.h
    ECS/Bullet.h
    Scenes/GameScene.h
    ServerHost.h
 "ServerHost.h"
 ServerHost.cpp
 "Utils/ConfigManager.h" "ECS/PhysicsUtils.h" "ECS/Enemy.h" "ECS/Artifact.h" "ECS/Construct.h" "Utils/MasterServerIP.h")
target_include_directories(GameEngine PUBLIC ${CHIPMUNK2D_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameEngine PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameEngine PUBLIC ${BITSTERY_EXTERNAL_INCLUDE_DIR})

target_link_libraries(GameEngine PUBLIC chipmunk_static GameCommon enet::enet_shared raylib nlohmann_json Bitsery::bitsery)
target_include_directories(GameEngine PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

if(ANDROID)
    target_link_libraries(GameEngine PRIVATE log)
endif()
// engine\PhysicsUtils.h
﻿#pragma once
#include "raylib_compatibility.h"
#include "chipmunk/chipmunk.h"


inline cpVect ToCp(Vector2 v) {
    return cpv(v.x, v.y);
}

inline Vector2 ToRay(cpVect v) {
    return Vector2{ (float)v.x, (float)v.y };
}
// engine\raylib_compatibility.h
﻿// raylib_compatibility.h
#pragma once

#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "raylib.h"
// engine\ServerHost.cpp
﻿#define _CRT_SECURE_NO_WARNINGS
#include "ServerHost.h"
#include "../common/NetworkPackets.h"
#include <iostream>
#include <chrono>
#include <cmath>
#include "Utils/ConfigManager.h"
#if defined(__linux__) || defined(__APPLE__)
#include <signal.h>
#endif

double GetSystemTime() {
    static auto start = std::chrono::high_resolution_clock::now();
    auto now = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> diff = now - start;
    return diff.count();
}

ServerHost::ServerHost() : running(false) {
    netServer = ENetServer::alloc();
    masterClient = ENetClient::alloc();
}

ServerHost::~ServerHost() {
    Stop();
}

bool ServerHost::Start(int port, bool registerOnMaster = true) {
    if (running) return false;

#if defined(__linux__) || defined(__APPLE__)
    signal(SIGPIPE, SIG_IGN);
#endif

    ServerConfig& cfg = ConfigManager::GetServer();
    gameScene.pvpFactor = cfg.pvpDamageFactor;
    useMasterServer = registerOnMaster; 
    if (!netServer->start(port, cfg.maxPlayers)) return false;

    std::cout << "SERVER: Started on port " << port << (useMasterServer ? " (Public)" : " (Offline/LAN)") << std::endl;
    std::cout << "SERVER: Name '" << cfg.serverName << "', Max Players: " << cfg.maxPlayers << "\n";

    running = true;
    serverThread = std::thread(&ServerHost::ServerLoop, this);
    return true;
}

void ServerHost::Stop() {
    running = false;
    if (serverThread.joinable()) serverThread.join();
    netServer->stop();
    if (masterClient) masterClient->disconnect();
}

void ServerHost::RegisterWithMaster() {
    if (!useMasterServer) return; 
    ClientConfig& cCfg = ConfigManager::GetClient();
    ServerConfig& sCfg = ConfigManager::GetServer();

        if (masterClient->connect(cCfg.masterServerIp, cCfg.masterServerPort)) {
        std::cout << "SERVER: Connected to Master Server at " << cCfg.masterServerIp << ":" << cCfg.masterServerPort << "\n";
        connectedToMaster = true;

        Buffer buffer; OutputAdapter adapter(buffer);
        bitsery::Serializer<OutputAdapter> serializer(std::move(adapter));
        serializer.value1b(GamePacket::MASTER_REGISTER);

        MasterRegisterPacket pkt;
        pkt.gamePort = (uint16_t)ConfigManager::GetServer().port;
        pkt.serverName = sCfg.serverName;
        pkt.maxPlayers = (uint8_t)sCfg.maxPlayers;

        serializer.object(pkt);
        serializer.adapter().flush();
        masterClient->send(DeliveryType::RELIABLE, StreamBuffer::alloc(buffer.data(), buffer.size()));
    }
    else {
        std::cout << "SERVER: Failed to connect to Master Server (Will run in Offline mode).\n";
        connectedToMaster = false;
    }
}

void ServerHost::UpdateMasterHeartbeat(float dt) {
    if (!useMasterServer || !connectedToMaster) return;

    masterClient->poll();

    masterHeartbeatTimer += dt;
    if (masterHeartbeatTimer >= 5.0f) {
        masterHeartbeatTimer = 0.0f;

        int playerCount = 0;
        for (const auto& p : gameScene.objects) {
            if (p.second->type == EntityType::PLAYER) playerCount++;
        }

        Buffer buffer; OutputAdapter adapter(buffer);
        bitsery::Serializer<OutputAdapter> serializer(std::move(adapter));
        serializer.value1b(GamePacket::MASTER_HEARTBEAT);

        MasterHeartbeatPacket pkt;
        pkt.currentPlayers = (uint8_t)playerCount;
        pkt.wave = (uint8_t)waveCount;

        serializer.object(pkt);
        serializer.adapter().flush();
        masterClient->send(DeliveryType::UNRELIABLE, StreamBuffer::alloc(buffer.data(), buffer.size()));
    }
}

void ServerHost::ServerLoop() {
    using clock = std::chrono::high_resolution_clock;
    auto lastTime = clock::now();
    double accumulator = 0.0;

    int tickRate = ConfigManager::GetServer().tickRate;
    if (tickRate <= 0) tickRate = 60;
    double dt = 1.0 / (double)tickRate;

    double snapshotTimer = 0.0;
    double statsTimer = 0.0;

    waveCount = 1;
    waveTimer = 0.0;
    timeToNextWave = 5.0;

        RegisterWithMaster();

    while (running && netServer->isRunning()) {
        auto currentTime = clock::now();
        double frameTime = std::chrono::duration<double>(currentTime - lastTime).count();
        lastTime = currentTime;

        if (frameTime > 0.25) frameTime = 0.25;

                UpdateMasterHeartbeat((float)frameTime);

        if (netServer->numClients() == 0) {
            bool hasEntities = false;
            for (auto& pair : gameScene.objects) {
                if (pair.second->type != EntityType::PLAYER && pair.second->type != EntityType::WALL) {
                    hasEntities = true; break;
                }
            }

            if (waveCount > 1 || hasEntities) {
                auto it = gameScene.objects.begin();
                while (it != gameScene.objects.end()) {
                    if (it->second->type == EntityType::ENEMY ||
                        it->second->type == EntityType::BULLET ||
                        it->second->type == EntityType::ARTIFACT) {
                        it = gameScene.objects.erase(it);
                    }
                    else {
                        ++it;
                    }
                }
                waveCount = 1;
                waveTimer = 0;
                timeToNextWave = 5.0;
            }
        }

        accumulator += frameTime;
        snapshotTimer += frameTime;
        statsTimer += frameTime;
        waveTimer += frameTime;

        if (waveTimer >= timeToNextWave && netServer->numClients() > 0) {
            waveTimer = 0.0;
            timeToNextWave = 20.0 + (waveCount * 2.0);

            int currentEnemies = 0;
            for (auto& [id, obj] : gameScene.objects) { if (obj->type == EntityType::ENEMY) currentEnemies++; }

            if (currentEnemies < 120) {
                int enemiesToSpawn = 5 + (waveCount * 2);
                if (enemiesToSpawn > 60) enemiesToSpawn = 60;
                for (int i = 0; i < enemiesToSpawn; i++) gameScene.SpawnEnemy();
                if (waveCount % 5 == 0) gameScene.SpawnEnemy(EnemyType::BOSS);
                waveCount++;
            }
        }

        auto msgs = netServer->poll();
        for (auto& msg : msgs) {
            uint32_t peerId = msg->peerId();

            if (msg->type() == MessageType::CONNECT) {
                std::cout << "Client " << peerId << " connected.\n";
                auto player = gameScene.CreatePlayerWithId(peerId);

                InitPacket initPkt; initPkt.playerId = player->id;
                Buffer buf; OutputAdapter ad(buf); bitsery::Serializer<OutputAdapter> ser(std::move(ad));
                ser.value1b(GamePacket::INIT); ser.object(initPkt); ser.adapter().flush();
                netServer->send(peerId, DeliveryType::RELIABLE, StreamBuffer::alloc(buf.data(), buf.size()));
            }
            else if (msg->type() == MessageType::DISCONNECT) {
                std::cout << "Client " << peerId << " disconnected.\n";
                gameScene.objects.erase(peerId);
            }
            else if (msg->type() == MessageType::DATA) {
                const auto& buf = msg->stream()->buffer();
                size_t offset = msg->stream()->tellg();
                if (!buf.empty() && offset < buf.size()) {
                    InputAdapter ia(buf.begin() + offset, buf.end());
                    bitsery::Deserializer<InputAdapter> des(std::move(ia));
                    uint8_t type; des.value1b(type);

                    if (type == GamePacket::JOIN) {
                        JoinPacket pkt; des.object(pkt);
                        if (des.adapter().error() == bitsery::ReaderError::NoError) {
                            if (gameScene.objects.count(peerId)) {
                                auto p = std::dynamic_pointer_cast<Player>(gameScene.objects[peerId]);
                                if (p) p->name = pkt.name;
                            }
                        }
                    }
                    else if (type == GamePacket::INPUT) {
                        PlayerInputPacket inp; des.object(inp);
                        if (des.adapter().error() == bitsery::ReaderError::NoError) {
                            if (gameScene.objects.count(peerId)) {
                                auto p = std::dynamic_pointer_cast<Player>(gameScene.objects[peerId]);
                                if (p) {
                                    p->ApplyInput(inp.movement);
                                    p->aimTarget = inp.aimTarget;
                                    p->wantsToShoot = inp.isShooting;
                                }
                            }
                        }
                    }
                    else if (type == GamePacket::ACTION) {
                        ActionPacket act; des.object(act);
                        if (des.adapter().error() == bitsery::ReaderError::NoError) {
                            if (gameScene.objects.count(peerId)) {
                                if (act.type == ActionType::UPGRADE_BUILDING) gameScene.TryUpgrade(peerId, act.target);
                                else gameScene.TryBuild(peerId, act.type, act.target);
                            }
                        }
                    }
                    else if (type == GamePacket::ADMIN_CMD) {
                        AdminCommandPacket pkt; des.object(pkt);
                        if (des.adapter().error() == bitsery::ReaderError::NoError) gameScene.HandleAdminCommand(peerId, pkt);
                    }
                }
            }
        }

        int maxPhysicsSteps = 5;
        int steps = 0;
        while (accumulator >= dt && steps < maxPhysicsSteps) {
            gameScene.Update((float)dt);
            accumulator -= dt;
            steps++;
        }
        if (accumulator > dt) accumulator = 0.0;

        if (!gameScene.pendingEvents.empty()) {
            for (const auto& evt : gameScene.pendingEvents) {
                Buffer buf; OutputAdapter ad(buf); bitsery::Serializer<OutputAdapter> ser(std::move(ad));
                ser.value1b(GamePacket::EVENT);
                ser.object(evt);
                ser.adapter().flush();
                netServer->broadcast(DeliveryType::UNRELIABLE, StreamBuffer::alloc(buf.data(), buf.size()));
            }
            gameScene.pendingEvents.clear();
        }

        if (snapshotTimer >= 0.033) {
            BroadcastSnapshot();
            snapshotTimer = 0;
        }

        if (statsTimer >= 0.2) {
            for (auto& [id, obj] : gameScene.objects) {
                if (obj->type == EntityType::PLAYER) {
                    auto p = std::dynamic_pointer_cast<Player>(obj);
                    PlayerStatsPacket stats;
                    stats.level = p->level; stats.currentXp = p->currentXp; stats.maxXp = p->maxXp;
                    stats.maxHealth = p->maxHealth; stats.damage = p->curDamage; stats.speed = p->curSpeed;
                    stats.scrap = p->scrap; stats.kills = p->kills; stats.inventory.assign(std::begin(p->inventory), std::end(p->inventory));
                    stats.isAdmin = p->isAdmin;
                    Buffer buf; OutputAdapter ad(buf); bitsery::Serializer<OutputAdapter> ser(std::move(ad));
                    ser.value1b(GamePacket::STATS); ser.object(stats); ser.adapter().flush();
                    netServer->send(id, DeliveryType::UNRELIABLE, StreamBuffer::alloc(buf.data(), buf.size()));
                }
            }
            statsTimer = 0;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}

void ServerHost::BroadcastSnapshot() {
    if (netServer->numClients() == 0) return;
    WorldSnapshotPacket snap;
    snap.serverTime = GetSystemTime();
    snap.wave = waveCount;
    for (auto& [id, obj] : gameScene.objects) {
        EntityState state; state.id = obj->id;
        if (obj->body) { cpVect pos = cpBodyGetPosition(obj->body); state.position = ToRay(pos); state.rotation = obj->rotation; }
        else { state.position = { 0,0 }; state.rotation = 0; }
        state.health = obj->health; state.maxHealth = obj->maxHealth; state.type = obj->type; state.color = obj->color;
        state.level = 1; state.kills = 0; state.radius = 20.0f; state.subtype = 0; state.ownerId = 0;
        if (obj->type == EntityType::PLAYER) {
            auto p = std::dynamic_pointer_cast<Player>(obj);
            if (p) { state.level = p->level; state.kills = p->kills; state.name = p->name; }
        }
        else if (obj->type == EntityType::BULLET) state.radius = 5.0f;
        else if (obj->type == EntityType::ENEMY) {
            auto e = std::dynamic_pointer_cast<Enemy>(obj); if (e) state.subtype = e->enemyType;
        }
        else if (obj->type == EntityType::WALL || obj->type == EntityType::TURRET || obj->type == EntityType::MINE) {
            auto c = std::dynamic_pointer_cast<Construct>(obj); if (c) { state.ownerId = c->ownerId; state.level = c->level; }
            if (obj->type == EntityType::WALL) state.radius = 25.0f; else if (obj->type == EntityType::TURRET) state.radius = 20.0f; else state.radius = 15.0f;
        }
        snap.entities.push_back(state);
    }
    Buffer buf; OutputAdapter ad(buf); bitsery::Serializer<OutputAdapter> ser(std::move(ad));
    ser.value1b(GamePacket::SNAPSHOT); ser.object(snap); ser.adapter().flush();
    netServer->broadcast(DeliveryType::UNRELIABLE, StreamBuffer::alloc(buf.data(), buf.size()));
}
// engine\ServerHost.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "enet/ENetServer.h"
#include "enet/ENetClient.h"
#include "Scenes/GameScene.h"
#include <thread>
#include <atomic>

class ServerHost {
    ENetServer::Shared netServer;
    GameScene gameScene;

    ENetClient::Shared masterClient;
    double masterHeartbeatTimer = 0.0;
    bool connectedToMaster = false;
    bool useMasterServer = false;

    std::atomic<bool> running{ false };
    std::thread serverThread;

    double waveTimer = 0.0;
    double timeToNextWave = 5.0;
    int waveCount = 1;

public:
    ServerHost();
    ~ServerHost();
    bool Start(int port, bool registerOnMaster);
    void Stop();

    void ServerLoop();
    void BroadcastSnapshot();

private:
    void RegisterWithMaster();
    void UpdateMasterHeartbeat(float dt);
};
// engine\ECS\Artifact.h
﻿#include "GameObject.h"

class Artifact : public GameObject {
public:
    uint8_t bonusType = 0;
    Artifact(uint32_t id, Vector2 pos, cpSpace* space) : GameObject(id, EntityType::ARTIFACT) {
        spaceRef = space;
        bonusType = rand() % 4;
        cpFloat radius = 15.0f;
        body = cpSpaceAddBody(space, cpBodyNew(1.0f, cpMomentForCircle(1.0f, 0, radius, cpvzero)));
        cpBodySetPosition(body, ToCp(pos));
        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetSensor(shape, true);
        cpShapeSetUserData(shape, (void*)this);
    }
    void Update(float dt) override {}
};
// engine\ECS\Bullet.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"

class Bullet : public GameObject {
public:
    uint32_t ownerId;
    float lifeTime = 2.0f;

    Bullet(uint32_t id, Vector2 pos, Vector2 dir, uint32_t owner, cpSpace* space)
        : GameObject(id, EntityType::BULLET), ownerId(owner)
    {
        spaceRef = space;
        color = BLACK;
        float moveSpeed = 600.0f;

        if (dir.x == 0 && dir.y == 0) {
            dir = { 1.0f, 0.0f };
        }

        Vector2 normDir = Vector2Normalize(dir);
        if (isnan(normDir.x) || isnan(normDir.y)) {
            normDir = { 1.0f, 0.0f };
        }

        cpFloat radius = 5.0;
        cpFloat mass = 1.0;
        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);

        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(pos));

        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetElasticity(shape, 0.8);
        cpShapeSetCollisionType(shape, COLLISION_BULLET);
        cpShapeSetUserData(shape, (void*)this);

        cpBodySetVelocity(body, cpv(normDir.x * moveSpeed, normDir.y * moveSpeed));
    }

    void Update(float dt) override {
        lifeTime -= dt;
        if (lifeTime <= 0) destroyFlag = true;
    }
};
// engine\ECS\Construct.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"

class Construct : public GameObject {
public:
    float lifetime = -1.0f;
    uint32_t level = 1;
    uint32_t ownerId;

    Construct(uint32_t id, EntityType type, Vector2 pos, uint32_t owner, cpSpace* space)
        : GameObject(id, type), ownerId(owner) {
        spaceRef = space;
    }

    virtual void Upgrade() {
        level++;
        maxHealth *= 1.4f;         health = maxHealth;     }

    virtual void Update(float dt) override {
        if (lifetime > 0) {
            lifetime -= dt;
            if (lifetime <= 0) destroyFlag = true;
        }
    }
};

class Wall : public Construct {
public:
    Wall(uint32_t id, Vector2 pos, uint32_t owner, cpSpace* space)
        : Construct(id, EntityType::WALL, pos, owner, space) {
        maxHealth = 400.0f;
        health = maxHealth;
        color = GRAY; 
        body = cpSpaceAddBody(space, cpBodyNewStatic());
        cpBodySetPosition(body, ToCp(pos));

        shape = cpSpaceAddShape(space, cpBoxShapeNew(body, 50, 50, 0));
        cpShapeSetElasticity(shape, 0.5f);
        cpShapeSetFriction(shape, 0.5f);
        cpShapeSetCollisionType(shape, COLLISION_WALL);
        cpShapeSetUserData(shape, (void*)this);
    }

        };
class Turret : public Construct {
public:
    float range = 400.0f;
    float reloadTime = 1.0f;     float cooldown = 0.0f;
    float damage = 15.0f;    
    Turret(uint32_t id, Vector2 pos, uint32_t owner, cpSpace* space)
        : Construct(id, EntityType::TURRET, pos, owner, space) {
        maxHealth = 200.0f;         health = maxHealth;
        color = PURPLE;

        body = cpSpaceAddBody(space, cpBodyNewStatic());
        cpBodySetPosition(body, ToCp(pos));

        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, 25.0f, cpvzero));         cpShapeSetCollisionType(shape, COLLISION_WALL);
        cpShapeSetUserData(shape, (void*)this);
    }

    void Upgrade() override {
        Construct::Upgrade();         damage *= 1.3f;               reloadTime *= 0.85f;          range += 20.0f;
    }

    void Update(float dt) override {
        Construct::Update(dt);
        if (cooldown > 0) cooldown -= dt;
    }
};
class Mine : public Construct {
public:
    float damage = 200.0f;
    float triggerRadius = 35.0f;
    float splashRadius = 100.0f;

    Mine(uint32_t id, Vector2 pos, uint32_t owner, cpSpace* space)
        : Construct(id, EntityType::MINE, pos, owner, space) {
        maxHealth = 50.0f;
        health = maxHealth;
        color = ORANGE;

        body = cpSpaceAddBody(space, cpBodyNewStatic());
        cpBodySetPosition(body, ToCp(pos));

                shape = cpSpaceAddShape(space, cpCircleShapeNew(body, 15.0f, cpvzero));
        cpShapeSetSensor(shape, true);
        cpShapeSetCollisionType(shape, COLLISION_BULLET);
        cpShapeSetUserData(shape, (void*)this);
    }

    void Upgrade() override {
        Construct::Upgrade();
        damage += 100.0f;              splashRadius += 10.0f;     }
};
// engine\ECS\Enemy.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"
#include "../../common/NetworkPackets.h"

class Enemy : public GameObject {
public:
    float speed = 100.0f;
    float damage = 10.0f;
    float xpReward = 20.0f;
    int scrapReward = 1;
    uint8_t enemyType = EnemyType::BASIC;

    Enemy(uint32_t id, Vector2 pos, uint8_t type, cpSpace* space) : GameObject(id, EntityType::ENEMY) {
        spaceRef = space;
        enemyType = type;
        cpFloat radius = 20.0;
        cpFloat mass = 20.0;

        switch (type) {
        case EnemyType::BASIC:             
            speed = 100.0f; 
            maxHealth = 30.0f;
            damage = 50.0f;             
            xpReward = 20.0f; 
            scrapReward = 1;
            radius = 20.0f;
            mass = 20.0f; 
            break;
        case EnemyType::FAST:            
            speed = 190.0f; 
            maxHealth = 20.0f;
            damage = 40.0f;             
            xpReward = 30.0f; 
            scrapReward = 2; 
            radius = 15.0f; 
            mass = 10.0f;
            break;
        case EnemyType::TANK:   
            speed = 60.0f; 
            maxHealth = 250.0f;             
            damage = 100.0f;           
            xpReward = 100.0f; 
            scrapReward = 10; 
            radius = 35.0f; 
            mass = 100.0f;
            break;
        case EnemyType::BOSS:
            speed = 45.0f;
            maxHealth = 5000.0f;
            damage = 300.0f;        
            xpReward = 1000.0f;
            scrapReward = 100;
            radius = 70.0f;
            mass = 1000.0f;
            break;
        }
        health = maxHealth;

        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);
        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(pos));
        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));

        cpShapeSetElasticity(shape, 0.0f);
        cpShapeSetFriction(shape, 1.0f);
        cpShapeSetCollisionType(shape, COLLISION_PLAYER);
        cpShapeSetUserData(shape, (void*)this);
    }

    void Update(float dt) override {
        if (health < maxHealth) health += maxHealth * 0.005f * dt;

        cpVect currentVel = cpBodyGetVelocity(body);
        cpBodySetVelocity(body, cpvmult(currentVel, 0.90f));

        float currentSpeed = cpvlength(currentVel);
        if (currentSpeed > speed * 3.0f) {
            cpBodySetVelocity(body, cpvmult(cpvnormalize(currentVel), speed * 3.0f));
        }
    }

    void MoveTowards(Vector2 targetPos) {
        if (!body) return;
        Vector2 pos = ToRay(cpBodyGetPosition(body));
        Vector2 dir = Vector2Subtract(targetPos, pos);
        float angle = atan2(dir.y, dir.x);
        cpBodySetAngle(body, angle);
        rotation = angle * RAD2DEG;

        if (Vector2Length(dir) < 5.0f) return;
        Vector2 moveDir = Vector2Normalize(dir);
        cpVect desiredVel = cpv(moveDir.x * speed, moveDir.y * speed);
        cpVect currentVel = cpBodyGetVelocity(body);
        cpBodySetVelocity(body, cpvlerp(currentVel, desiredVel, 0.1f));
    }
};
// engine\ECS\GameObject.h
﻿#pragma once
#include "fix_win32_compatibility.h"
#include "raylib.h"
#include "chipmunk/chipmunk.h"
#include "../../common/NetworkPackets.h"

enum CollisionType {
    COLLISION_PLAYER = 1,
    COLLISION_BULLET = 2,
    COLLISION_WALL = 3
};

class GameObject {
public:
    uint32_t id;
    EntityType type;

    cpBody* body = nullptr;
    cpShape* shape = nullptr;
    cpSpace* spaceRef = nullptr;

    bool destroyFlag = false;
    Color color = RED;
    float rotation = 0.0f;
    float health = 100.0f;
    float maxHealth = 100.0f;

    double lastDamageTime = 0.0;

    GameObject(uint32_t _id, EntityType _type) : id(_id), type(_type) {}

    virtual ~GameObject() {
        if (spaceRef) {
            if (shape) { cpSpaceRemoveShape(spaceRef, shape); cpShapeFree(shape); }
            if (body) { cpSpaceRemoveBody(spaceRef, body); cpBodyFree(body); }
        }
    }

    virtual void Update(float dt) = 0;

    void TakeDamage(float amount, double currentTime) {
        health -= amount;
        if (health < 0.0f) health = 0.0f;
        lastDamageTime = currentTime;
    }
};
// engine\ECS\PhysicsUtils.h
﻿#pragma once
#include "raylib_compatibility.h"
#include "chipmunk/chipmunk.h"
#include <cmath>

inline float SanitizeFloat(float val) {
    if (!std::isfinite(val)) return 0.0f;
    return val;
}

inline double SanitizeDouble(double val) {
    if (!std::isfinite(val)) return 0.0;
    return val;
}

inline cpVect ToCp(Vector2 v) {
    return cpv(SanitizeFloat(v.x), SanitizeFloat(v.y));
}

inline Vector2 ToRay(cpVect v) {
    return Vector2{ (float)SanitizeDouble(v.x), (float)SanitizeDouble(v.y) };
}
// engine\ECS\Player.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"
#include <vector>
#include <string>

struct ArtifactStats {
    float damageMult = 0.0f; float speedMult = 0.0f;
    float healthFlat = 0.0f; float reloadMult = 0.0f;
};

class Player : public GameObject {
public:
    const float BASE_HP = 100.0f;
    const float BASE_DMG = 25.0f;
    const float BASE_SPEED = 220.0f;
    const float BASE_RELOAD = 0.5f;

    std::string name = "Player"; 
    uint32_t level = 1;
    float currentXp = 0.0f; float maxXp = 100.0f;
    uint32_t scrap = 0; uint32_t kills = 0;
    bool isAdmin = false;

    uint8_t inventory[6];
    ArtifactStats artifacts;

    float shootCooldown = 0.0f;
    bool wantsToShoot = false;
    Vector2 aimTarget = { 0,0 };
    bool spawnBulletSignal = false;
    Vector2 bulletDir = { 0,0 };
    Vector2 knockback = { 0, 0 };

    float curSpeed = 0; float curReload = 0; float curDamage = 0;
    float curRegen = 0; float curBulletSpeed = 0; float curBulletPen = 0; float curBodyDmg = 0;

    Player(uint32_t id, Vector2 startPos, cpSpace* space) : GameObject(id, EntityType::PLAYER) {
        spaceRef = space;
        color = { 0, 120, 215, 255 };
        for (int i = 0; i < 6; ++i) inventory[i] = ArtifactType::EMPTY;

        cpFloat radius = 20.0;
        cpFloat mass = 5.0;
        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);
        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(startPos));
        cpBodySetMoment(body, INFINITY);
        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetFriction(shape, 0.5f);
        cpShapeSetElasticity(shape, 0.1f);
        cpShapeSetCollisionType(shape, COLLISION_PLAYER);
        cpShapeSetUserData(shape, (void*)this);

        RecalculateStats();
        health = maxHealth;
    }

    void Reset() {
        level = 1; currentXp = 0; maxXp = 100.0f; scrap = 0; kills = 0;
        health = maxHealth;
        for (int i = 0; i < 6; ++i) inventory[i] = ArtifactType::EMPTY;
        RecalculateStats();
    }

    void RecalculateStats() {
        artifacts = { 0,0,0,0 };
        for (int i = 0; i < 6; i++) {
            if (inventory[i] == ArtifactType::EMPTY) continue;
            switch (inventory[i]) {
            case ArtifactType::DAMAGE: artifacts.damageMult += 0.15f; break;
            case ArtifactType::SPEED: artifacts.speedMult += 0.10f; break;
            case ArtifactType::HEALTH: artifacts.healthFlat += 50.0f; break;
            case ArtifactType::RELOAD: artifacts.reloadMult += 0.10f; break;
            }
        }

        float lvl = (float)(level - 1);
        maxHealth = (BASE_HP + artifacts.healthFlat) + (lvl * 20.0f);
        curRegen = maxHealth * (0.01f + (lvl * 0.001f));
        curBodyDmg = 20.0f + (lvl * 5.0f);
        curDamage = (BASE_DMG + (lvl * 3.0f)) * (1.0f + artifacts.damageMult);
        curSpeed = (BASE_SPEED + (lvl * 1.5f)) * (1.0f + artifacts.speedMult);
        curReload = BASE_RELOAD * (1.0f - (lvl * 0.01f) - artifacts.reloadMult);
        if (curReload < 0.1f) curReload = 0.1f;

        curBulletSpeed = 600.0f + (lvl * 10.0f);
                curBulletPen = 1.5f + (lvl * 0.05f);

        if (health > maxHealth) health = maxHealth;
    }

    bool AddItemToInventory(uint8_t type) {
        for (int i = 0; i < 6; i++) {
            if (inventory[i] == ArtifactType::EMPTY) {
                inventory[i] = type; RecalculateStats(); return true;
            }
        }
        return false;
    }

    void AddXp(float amount) {
        currentXp += amount;
        while (currentXp >= maxXp) {
            currentXp -= maxXp; level++; maxXp *= 1.2f; RecalculateStats(); health = maxHealth;
        }
    }

    void Update(float dt) override {
        double currentTime = GetTime();
        float regen = curRegen;
        if (currentTime - lastDamageTime > 10.0) regen *= 4.0f;
        health += regen * dt;
        if (health > maxHealth) health = maxHealth;

        if (shootCooldown > 0) shootCooldown -= dt;
        knockback = Vector2Lerp(knockback, { 0,0 }, dt * 5.0f);

        Vector2 pos = ToRay(cpBodyGetPosition(body));
        if (wantsToShoot && shootCooldown <= 0) {
            shootCooldown = curReload;
            spawnBulletSignal = true;
            bulletDir = Vector2Subtract(aimTarget, pos);
            Vector2 recoilDir = Vector2Normalize(bulletDir);
            knockback = Vector2Subtract(knockback, Vector2Scale(recoilDir, 100.0f));
        }

        Vector2 diff = Vector2Subtract(aimTarget, pos);
        rotation = atan2(diff.y, diff.x) * RAD2DEG;
        cpBodySetAngle(body, atan2(diff.y, diff.x));
    }

    void ApplyInput(Vector2 move) {
        if (!body) return;
        if (!std::isfinite(move.x) || !std::isfinite(move.y)) move = { 0, 0 };
        float len = Vector2Length(move);
        if (len > 1.0f) move = Vector2Normalize(move);
        Vector2 targetVel = Vector2Scale(move, curSpeed);
        Vector2 finalVel = Vector2Add(targetVel, knockback);
        cpBodySetVelocity(body, cpv(finalVel.x, finalVel.y));
        cpBodySetAngularVelocity(body, 0.0f);
    }
};
// engine\Scenes\GameScene.h
﻿#pragma once
#include <vector>
#include <memory>
#include <map>
#include <algorithm>
#include <cmath>
#include "../ECS/Player.h"
#include "../ECS/Bullet.h"
#include "../ECS/Enemy.h"
#include "../ECS/Construct.h"
#include "../ECS/Artifact.h"
#include "../PhysicsUtils.h"
#include "../../common/NetworkPackets.h"

class GameScene {
public:
    cpSpace* space;
    std::map<uint32_t, std::shared_ptr<GameObject>> objects;
    std::vector<EventPacket> pendingEvents;
    float pvpFactor = 1.0f;
    uint32_t nextId = 1000;
    float width = 4000;
    float height = 4000;
    const float GRID_SIZE = 50.0f;

    GameScene() {
        space = cpSpaceNew();
        cpSpaceSetGravity(space, cpv(0, 0));
        CreateMapBoundaries();
    }

    ~GameScene() {
        objects.clear();
        cpSpaceFree(space);
    }

    void CreateMapBoundaries() {
        cpBody* staticBody = cpSpaceGetStaticBody(space);
        float thickness = 2000.0f;
        auto addWall = [&](float x, float y, float w, float h) {
            cpVect verts[] = { cpv(x, y), cpv(x, y + h), cpv(x + w, y + h), cpv(x + w, y) };
            cpShape* s = cpSpaceAddShape(space, cpPolyShapeNew(staticBody, 4, verts, cpTransformIdentity, 0.0));
            cpShapeSetElasticity(s, 0.0f);
            cpShapeSetFriction(s, 0.5f);
            cpShapeSetCollisionType(s, COLLISION_WALL);
            };
        addWall(-thickness, -thickness, thickness, height + thickness * 2);
        addWall(width, -thickness, thickness, height + thickness * 2);
        addWall(-thickness, -thickness, width + thickness * 2, thickness);
        addWall(-thickness, height, width + thickness * 2, thickness);
    }

    Vector2 SnapToGrid(Vector2 pos) {
        float x = roundf(pos.x / GRID_SIZE) * GRID_SIZE;
        float y = roundf(pos.y / GRID_SIZE) * GRID_SIZE;
        return { x, y };
    }

    void HandleAdminCommand(uint32_t playerId, const AdminCommandPacket& cmd) {
        if (!objects.count(playerId)) return;
        auto p = std::dynamic_pointer_cast<Player>(objects[playerId]);
        if (!p) return;

        if (cmd.cmdType == AdminCmdType::LOGIN) p->isAdmin = true;
        if (!p->isAdmin) return;

        switch (cmd.cmdType) {
        case AdminCmdType::GIVE_SCRAP:
            p->scrap += cmd.value;
            break;
        case AdminCmdType::GIVE_XP:
            p->AddXp((float)cmd.value);
            break;
        case AdminCmdType::KILL_ALL_ENEMIES: {
            for (auto& [id, obj] : objects) {
                if (obj->type == EntityType::ENEMY) {
                    obj->TakeDamage(999999.0f, 0);                 }
            }
        } break;
        case AdminCmdType::SPAWN_BOSS:
            SpawnEnemy(EnemyType::BOSS);
            break;

                    case AdminCmdType::CLEAR_BUILDINGS: {
            for (auto& [id, obj] : objects) {
                if (obj->type == EntityType::WALL ||
                    obj->type == EntityType::TURRET ||
                    obj->type == EntityType::MINE) {
                    obj->destroyFlag = true;
                                        if (obj->body) {
                        Vector2 pos = ToRay(cpBodyGetPosition(obj->body));
                        pendingEvents.push_back({ 1, pos, GRAY });
                    }
                }
            }
        } break;

                                                  case AdminCmdType::RESET_SERVER: {
                        auto it = objects.begin();
            while (it != objects.end()) {
                if (it->second->type != EntityType::PLAYER) {
                                        if (it->second->body) {
                                            }
                    it = objects.erase(it);
                }
                else {
                                        auto pl = std::dynamic_pointer_cast<Player>(it->second);
                    if (pl) {
                        pl->Reset();
                                                float rx = (width / 2.0f) + (float)(rand() % 400 - 200);
                        float ry = (height / 2.0f) + (float)(rand() % 400 - 200);
                        cpBodySetPosition(pl->body, cpv(rx, ry));
                        cpBodySetVelocity(pl->body, cpvzero);
                    }
                    ++it;
                }
            }
                                } break;
        }
    }

    void TryBuild(uint32_t playerId, uint8_t buildType, Vector2 rawPos) {
        if (!objects.count(playerId)) return;
        auto p = std::dynamic_pointer_cast<Player>(objects[playerId]);
        if (!p) return;

        Vector2 pos = SnapToGrid(rawPos);
                if (pos.x < GRID_SIZE || pos.x > width - GRID_SIZE || pos.y < GRID_SIZE || pos.y > height - GRID_SIZE) return;
                if (Vector2Distance(ToRay(cpBodyGetPosition(p->body)), pos) > 400.0f) return;

                for (auto& [id, obj] : objects) {
            if (obj->type == EntityType::WALL || obj->type == EntityType::TURRET || obj->type == EntityType::MINE) {
                if (Vector2Distance(ToRay(cpBodyGetPosition(obj->body)), pos) < (GRID_SIZE / 2.0f)) return;
            }
        }

                if (buildType == ActionType::BUILD_TURRET) {
            int myTurrets = 0;
            for (auto& [id, obj] : objects) {
                if (obj->type == EntityType::TURRET) {
                    auto t = std::dynamic_pointer_cast<Turret>(obj);
                    if (t && t->ownerId == playerId) myTurrets++;
                }
            }
            if (myTurrets >= 5) return;
        }

        int cost = 0;
        if (buildType == ActionType::BUILD_WALL) cost = 10;
        else if (buildType == ActionType::BUILD_TURRET) cost = 50;
        else if (buildType == ActionType::BUILD_MINE) cost = 25;

        if (p->scrap >= cost) {
            p->scrap -= cost;
            std::shared_ptr<GameObject> obj = nullptr;
            if (buildType == ActionType::BUILD_WALL) obj = std::make_shared<Wall>(nextId++, pos, p->id, space);
            else if (buildType == ActionType::BUILD_TURRET) obj = std::make_shared<Turret>(nextId++, pos, p->id, space);
            else if (buildType == ActionType::BUILD_MINE) obj = std::make_shared<Mine>(nextId++, pos, p->id, space);

            if (obj) {
                objects[obj->id] = obj;
                pendingEvents.push_back({ 1, pos, WHITE });
            }
        }
    }

    void TryUpgrade(uint32_t playerId, Vector2 rawPos) {
        if (!objects.count(playerId)) return;
        auto p = std::dynamic_pointer_cast<Player>(objects[playerId]);

        for (auto& [id, obj] : objects) {
            if (obj->type == EntityType::WALL || obj->type == EntityType::TURRET || obj->type == EntityType::MINE) {
                Vector2 objPos = ToRay(cpBodyGetPosition(obj->body));
                                if (Vector2Distance(rawPos, objPos) < 30.0f) {
                    auto c = std::dynamic_pointer_cast<Construct>(obj);
                    int cost = 20 * c->level;
                    if (p->scrap >= cost) {
                        p->scrap -= cost;
                        c->Upgrade();
                        pendingEvents.push_back({ 2, objPos, GREEN });
                    }
                    return;
                }
            }
        }
    }

    std::shared_ptr<Player> CreatePlayerWithId(uint32_t id) {
        Vector2 startPos = { width / 2.0f, height / 2.0f };
        if (objects.count(id)) objects.erase(id);
        auto p = std::make_shared<Player>(id, startPos, space);
        p->Reset();
        if (objects.size() == 0) p->isAdmin = true;         objects[id] = p;
        return p;
    }

    std::shared_ptr<Enemy> SpawnEnemy(uint8_t forcedType = 255) {
        float spawnX, spawnY;
        int side = rand() % 4;
        float offset = 50.0f;

                if (side == 0) { spawnX = -offset; spawnY = (float)(rand() % (int)height); }
        else if (side == 1) { spawnX = width + offset; spawnY = (float)(rand() % (int)height); }
        else if (side == 2) { spawnX = (float)(rand() % (int)width); spawnY = -offset; }
        else { spawnX = (float)(rand() % (int)width); spawnY = height + offset; }

        uint8_t type = EnemyType::BASIC;
        if (forcedType != 255) {
            type = forcedType;
        }
        else {
            int chance = rand() % 100;
            if (chance < 60) type = EnemyType::BASIC;
            else if (chance < 85) type = EnemyType::FAST;
            else if (chance < 98) type = EnemyType::TANK;
            else type = EnemyType::BOSS;
        }

        auto enemy = std::make_shared<Enemy>(nextId++, Vector2{ spawnX, spawnY }, type, space);
        objects[enemy->id] = enemy;
        return enemy;
    }

    void Update(float dt) {
        cpSpaceSetIterations(space, 10);
        cpSpaceStep(space, dt);
        EnforceMapBoundaries();

        std::vector<std::shared_ptr<Bullet>> newBullets;

        for (auto it = objects.begin(); it != objects.end();) {
            auto& obj = it->second;
            obj->Update(dt);

                        if (obj->type == EntityType::PLAYER) {
                auto p = std::dynamic_pointer_cast<Player>(obj);
                if (p && p->spawnBulletSignal) {
                    p->spawnBulletSignal = false;
                    Vector2 playerPos = ToRay(cpBodyGetPosition(p->body));
                    Vector2 dir = Vector2Normalize(p->bulletDir);
                    auto b = std::make_shared<Bullet>(nextId++, Vector2Add(playerPos, Vector2Scale(dir, 35.0f)), dir, p->id, space);

                    b->lifeTime = p->curBulletPen;
                    float spd = p->curBulletSpeed;

                                        cpBodySetVelocity(b->body, cpvadd(cpvmult(ToCp(dir), spd), cpvmult(cpBodyGetVelocity(p->body), 0.2f)));
                    newBullets.push_back(b);
                }
            }

                        if (obj->type == EntityType::TURRET) {
                auto t = std::dynamic_pointer_cast<Turret>(obj);
                if (t->cooldown <= 0) {
                    float minDist = t->range;
                    std::shared_ptr<GameObject> target = nullptr;
                    Vector2 tPos = ToRay(cpBodyGetPosition(t->body));

                                        for (auto& [eid, eObj] : objects) {
                        if (eObj->type == EntityType::ENEMY) {
                            float d = Vector2Distance(tPos, ToRay(cpBodyGetPosition(eObj->body)));
                            if (d < minDist) { minDist = d; target = eObj; }
                        }
                    }

                    if (target) {
                        t->cooldown = t->reloadTime;
                        Vector2 ePos = ToRay(cpBodyGetPosition(target->body));
                        Vector2 dir = Vector2Normalize(Vector2Subtract(ePos, tPos));
                        auto b = std::make_shared<Bullet>(nextId++, Vector2Add(tPos, Vector2Scale(dir, 35.0f)), dir, t->ownerId, space);
                        newBullets.push_back(b);
                    }
                }
            }

                        if (obj->type == EntityType::MINE) {
                auto m = std::dynamic_pointer_cast<Mine>(obj);
                Vector2 mPos = ToRay(cpBodyGetPosition(m->body));
                for (auto& [eid, eObj] : objects) {
                    if (eObj->type == EntityType::ENEMY) {
                        if (Vector2Distance(mPos, ToRay(cpBodyGetPosition(eObj->body))) < 35.0f) {
                            pendingEvents.push_back({ 1, mPos, ORANGE });
                            eObj->TakeDamage(m->damage, GetTime());
                            m->destroyFlag = true;
                            break;
                        }
                    }
                }
            }

                        if (obj->type == EntityType::ENEMY) {
                auto enemy = std::dynamic_pointer_cast<Enemy>(obj);
                float minDist = 999999.0f;
                Vector2 targetPos = { width / 2, height / 2 };
                Vector2 myPos = ToRay(cpBodyGetPosition(obj->body));

                for (const auto& [pid, pObj] : objects) {
                    if (pObj->type == EntityType::PLAYER || pObj->type == EntityType::TURRET) {
                        float dist = Vector2Distance(myPos, ToRay(cpBodyGetPosition(pObj->body)));
                        if (dist < minDist) { minDist = dist; targetPos = ToRay(cpBodyGetPosition(pObj->body)); }
                    }
                }
                enemy->MoveTowards(targetPos);
            }

            if (obj->destroyFlag) it = objects.erase(it);
            else ++it;
        }
        for (auto& b : newBullets) objects[b->id] = b;

        HandleCollisionsAndDamage();
    }

    void EnforceMapBoundaries() {
        for (auto& [id, obj] : objects) {
                        if (obj->type == EntityType::BULLET || !obj->body || cpBodyGetType(obj->body) == CP_BODY_TYPE_STATIC) continue;

            cpVect pos = cpBodyGetPosition(obj->body);
            cpVect vel = cpBodyGetVelocity(obj->body);
            float r = 20.0f;
            bool clamped = false;

            if (pos.x < r) { pos.x = r; if (vel.x < 0) vel.x = 0; clamped = true; }
            if (pos.x > width - r) { pos.x = width - r; if (vel.x > 0) vel.x = 0; clamped = true; }
            if (pos.y < r) { pos.y = r; if (vel.y < 0) vel.y = 0; clamped = true; }
            if (pos.y > height - r) { pos.y = height - r; if (vel.y > 0) vel.y = 0; clamped = true; }

            if (clamped) { cpBodySetPosition(obj->body, pos); cpBodySetVelocity(obj->body, vel); }
        }
    }
    void HandleCollisionsAndDamage() {
        std::vector<std::shared_ptr<GameObject>> newArtifacts;
        double currentTime = GetTime();

                std::vector<std::shared_ptr<Enemy>> enemies;
        std::vector<std::shared_ptr<Player>> players;
        std::vector<std::shared_ptr<Bullet>> bullets;
        std::vector<std::shared_ptr<Construct>> structures;
        std::vector<std::shared_ptr<Mine>> mines;
        std::vector<std::shared_ptr<Artifact>> artifacts;

        enemies.reserve(objects.size());
        bullets.reserve(objects.size());

        for (auto& [id, obj] : objects) {
            if (obj->destroyFlag) continue;
            switch (obj->type) {
            case EntityType::ENEMY: enemies.push_back(std::dynamic_pointer_cast<Enemy>(obj)); break;
            case EntityType::PLAYER: players.push_back(std::dynamic_pointer_cast<Player>(obj)); break;
            case EntityType::BULLET: bullets.push_back(std::dynamic_pointer_cast<Bullet>(obj)); break;
            case EntityType::WALL:
            case EntityType::TURRET: structures.push_back(std::dynamic_pointer_cast<Construct>(obj)); break;
            case EntityType::MINE: mines.push_back(std::dynamic_pointer_cast<Mine>(obj)); break;
            case EntityType::ARTIFACT: artifacts.push_back(std::dynamic_pointer_cast<Artifact>(obj)); break;
            }
        }

                for (auto& enemy : enemies) {
            if (enemy->destroyFlag || enemy->health <= 0) continue;
            Vector2 ePos = ToRay(cpBodyGetPosition(enemy->body));
            float eRad = (enemy->enemyType == EnemyType::BOSS) ? 70.0f : ((enemy->enemyType == EnemyType::TANK) ? 35.0f : 20.0f);

            for (auto& pObj : players) {
                if (pObj->destroyFlag || pObj->health <= 0) continue;
                Vector2 pPos = ToRay(cpBodyGetPosition(pObj->body));

                if (Vector2Distance(ePos, pPos) < (eRad + 25.0f + 8.0f)) {
                    float enemyDpsMult = 2.0f;
                    pObj->TakeDamage(enemy->damage * enemyDpsMult * 0.016f, currentTime);

                    if (pObj->health <= 0) {
                        pObj->Reset();
                        cpBodySetPosition(pObj->body, cpv(rand() % (int)width, rand() % (int)height));
                        pendingEvents.push_back({ 1, pPos, RED });
                    }
                    enemy->TakeDamage(pObj->curBodyDmg * 0.2f * 0.016f, currentTime);
                    Vector2 knockDir = Vector2Normalize(Vector2Subtract(pPos, ePos));
                    cpBodyApplyImpulseAtLocalPoint(pObj->body, ToCp(Vector2Scale(knockDir, 150.0f)), cpvzero);
                }
            }

            for (auto& str : structures) {
                if (str->destroyFlag || str->health <= 0) continue;
                Vector2 sPos = ToRay(cpBodyGetPosition(str->body));
                float sRad = (str->type == EntityType::WALL) ? 35.0f : 25.0f;
                if (Vector2Distance(ePos, sPos) < (eRad + sRad + 8.0f)) {
                    str->TakeDamage(enemy->damage * 2.0f * 0.016f, currentTime);
                    if (str->health <= 0) {
                        str->destroyFlag = true;
                        pendingEvents.push_back({ 1, sPos, GRAY });
                    }
                    enemy->TakeDamage(5.0f * 0.016f, currentTime);
                }
            }
        }

                for (auto& mine : mines) {
            if (mine->destroyFlag) continue;
            Vector2 mPos = ToRay(cpBodyGetPosition(mine->body));
            bool triggered = false;
            for (auto& enemy : enemies) {
                float eRad = (enemy->enemyType == EnemyType::TANK) ? 35.0f : 20.0f;
                if (Vector2Distance(mPos, ToRay(cpBodyGetPosition(enemy->body))) < (mine->triggerRadius + eRad)) {
                    triggered = true; break;
                }
            }
            if (triggered) {
                mine->destroyFlag = true;
                pendingEvents.push_back({ 1, mPos, ORANGE });
                pendingEvents.push_back({ 2, mPos, RED });
                for (auto& enemy : enemies) {
                    if (enemy->destroyFlag) continue;
                    if (Vector2Distance(mPos, ToRay(cpBodyGetPosition(enemy->body))) <= mine->splashRadius) {
                        enemy->TakeDamage(mine->damage, currentTime);
                        if (enemy->health <= 0) {
                            enemy->destroyFlag = true;
                            pendingEvents.push_back({ 1, ToRay(cpBodyGetPosition(enemy->body)), RED });
                            if (objects.count(mine->ownerId) && objects[mine->ownerId]->type == EntityType::PLAYER) {
                                auto p = std::dynamic_pointer_cast<Player>(objects[mine->ownerId]);
                                p->AddXp(enemy->xpReward); p->scrap += enemy->scrapReward; p->kills++;
                            }
                        }
                    }
                }
            }
        }

                for (auto& art : artifacts) {
            if (art->destroyFlag) continue;
            Vector2 aPos = ToRay(cpBodyGetPosition(art->body));
            for (auto& p : players) {
                if (Vector2Distance(aPos, ToRay(cpBodyGetPosition(p->body))) < 40.0f) {
                    if (p->AddItemToInventory(art->bonusType)) {
                        art->destroyFlag = true;
                        pendingEvents.push_back({ 2, aPos, GOLD });
                    }
                }
            }
        }

                for (auto& bullet : bullets) {
            if (bullet->destroyFlag) continue;
            Vector2 bPos = ToRay(cpBodyGetPosition(bullet->body));

            if (bPos.x <= -50 || bPos.x >= width + 50 || bPos.y <= -50 || bPos.y >= height + 50) {
                bullet->destroyFlag = true; continue;
            }

            bool hit = false;
            float dmg = 10.0f;

                        if (objects.count(bullet->ownerId)) {
                auto owner = objects[bullet->ownerId];
                if (owner->type == EntityType::PLAYER) dmg = std::dynamic_pointer_cast<Player>(owner)->curDamage;
                else if (owner->type == EntityType::TURRET) dmg = std::dynamic_pointer_cast<Turret>(owner)->damage;
            }

                        for (auto& enemy : enemies) {
                if (enemy->destroyFlag || enemy->health <= 0) continue;
                float targetRadius = (enemy->enemyType == EnemyType::BOSS) ? 75.0f : ((enemy->enemyType == EnemyType::TANK) ? 40.0f : 30.0f);

                if (Vector2Distance(bPos, ToRay(cpBodyGetPosition(enemy->body))) <= targetRadius) {
                    hit = true;
                    enemy->TakeDamage(dmg, currentTime);
                    if (enemy->health <= 0) {
                        enemy->destroyFlag = true;
                        pendingEvents.push_back({ 1, ToRay(cpBodyGetPosition(enemy->body)), RED });
                        if (objects.count(bullet->ownerId) && objects[bullet->ownerId]->type == EntityType::PLAYER) {
                            auto p = std::dynamic_pointer_cast<Player>(objects[bullet->ownerId]);
                            p->AddXp(enemy->xpReward); p->scrap += enemy->scrapReward; p->kills++;
                        }
                        int dropChance = (enemy->enemyType == EnemyType::BOSS) ? 100 : (enemy->enemyType == EnemyType::TANK ? 25 : 5);
                        if (rand() % 100 < dropChance) newArtifacts.push_back(std::make_shared<Artifact>(nextId++, ToRay(cpBodyGetPosition(enemy->body)), space));
                    }
                    break;
                }
            }
            if (hit) { bullet->destroyFlag = true; pendingEvents.push_back({ 0, bPos, WHITE }); continue; }

                        if (pvpFactor > 0.001f) {                 for (auto& p : players) {
                                        if (p->id == bullet->ownerId) continue;
                    if (p->destroyFlag || p->health <= 0) continue;

                                                            if (objects.count(bullet->ownerId) && objects[bullet->ownerId]->type != EntityType::PLAYER) continue;

                    float pRad = 25.0f;
                    if (Vector2Distance(bPos, ToRay(cpBodyGetPosition(p->body))) <= pRad) {
                        hit = true;

                                                float pvpDmg = dmg * pvpFactor;

                        p->TakeDamage(pvpDmg, currentTime);
                        pendingEvents.push_back({ 0, bPos, RED }); 
                        if (p->health <= 0) {
                            p->Reset();
                            cpBodySetPosition(p->body, cpv(rand() % (int)width, rand() % (int)height));
                            pendingEvents.push_back({ 1, ToRay(cpBodyGetPosition(p->body)), RED });

                                                        if (objects.count(bullet->ownerId) && objects[bullet->ownerId]->type == EntityType::PLAYER) {
                                auto killer = std::dynamic_pointer_cast<Player>(objects[bullet->ownerId]);
                                killer->kills++;
                                killer->scrap += p->level * 10;                             }
                        }
                        break;
                    }
                }
            }
            if (hit) { bullet->destroyFlag = true; continue; }

                                    for (auto& str : structures) {
                if (str->destroyFlag) continue;
                if (str->ownerId == bullet->ownerId) continue; 
                                if (pvpFactor <= 0.001f && objects.count(bullet->ownerId) && objects[bullet->ownerId]->type == EntityType::PLAYER) continue;

                float sRad = (str->type == EntityType::WALL) ? 35.0f : 25.0f;
                if (Vector2Distance(bPos, ToRay(cpBodyGetPosition(str->body))) <= sRad) {
                    hit = true;
                                        str->TakeDamage(dmg, currentTime);
                    if (str->health <= 0) {
                        str->destroyFlag = true;
                        pendingEvents.push_back({ 1, ToRay(cpBodyGetPosition(str->body)), GRAY });
                    }
                    break;
                }
            }
            if (hit) { bullet->destroyFlag = true; pendingEvents.push_back({ 0, bPos, WHITE }); continue; }
        }

        for (auto& a : newArtifacts) objects[a->id] = a;
    }

};
// engine\Scenes\Scene.h
﻿#pragma once
#include <vector>
#include <memory>
#include "net/Message.h"

class GameClient;

class Scene {
protected:
    GameClient* game;

public:
    Scene(GameClient* _game) : game(_game) {}
    virtual ~Scene() = default;

    virtual void Enter() = 0;
    virtual void Update(float dt) = 0;
    virtual void Draw() = 0;
    virtual void DrawGUI() = 0;
    virtual void Exit() = 0;

    virtual void OnMessage(Message::Shared msg) {};
};
// engine\Utils\.gitignore
﻿MasterServerIP.h
// engine\Utils\ConfigManager.cpp
﻿// engine\Utils\ConfigManager.cpp
#include "ConfigManager.h"

GameConfig ConfigManager::config;
std::string ConfigManager::configPath;
Font ConfigManager::mainFont = { 0 };
std::map<std::string, std::string> ConfigManager::localizedStrings;

void ConfigManager::Initialize(const std::string& savePath) {
	if (!std::filesystem::exists(savePath)) {
		try { std::filesystem::create_directories(savePath); }
		catch (const std::exception& e) { std::cerr << e.what() << std::endl; }
	}
	configPath = savePath + "config.json";
	Load();
	LoadFonts();
	LoadLanguage(config.client.language);
}

void ConfigManager::CreateDefaultConfig() {
	config.client.playerName = "Player";
	config.client.lastIp = "127.0.0.1";
	config.server.port = 7777;
	config.client.favoriteServers.push_back({ "Localhost", "127.0.0.1", 7777 });
	config.client.resolutionWidth = 1280;
	config.client.resolutionHeight = 720;
	config.client.masterServerIp = "127.0.0.1";
	config.client.masterServerPort = 8080;
	config.server.serverName = "My Void Server";
	Save();
}

void ConfigManager::Save() {
	json j;
	json jFav = json::array();
	for (const auto& s : config.client.favoriteServers) {
		jFav.push_back({ {"name", s.name}, {"ip", s.ip}, {"port", s.port} });
	}
	j["client"] = {
	{"playerName", config.client.playerName},
	{"lastIp", config.client.lastIp},
	{"lastPort", config.client.lastPort},
	{"language", config.client.language},
	{"fullscreen", config.client.fullscreen},
	{"targetFPS", config.client.targetFPS},
	{"resW", config.client.resolutionWidth},
	{"resH", config.client.resolutionHeight},
	{"masterIp", config.client.masterServerIp},
	{"masterPort", config.client.masterServerPort},
	{"favorites", jFav}
	};
	j["server"] = {
		{"port", config.server.port},
		{"pvpDamageFactor", config.server.pvpDamageFactor},
		{"maxPlayers", config.server.maxPlayers},
		{"tickRate", config.server.tickRate},
		{"serverName", config.server.serverName}
	};

	std::ofstream file(configPath);
	if (file.is_open()) file << j.dump(4);
}

void ConfigManager::Load() {
	if (!std::filesystem::exists(configPath)) { CreateDefaultConfig(); return; }
	std::ifstream file(configPath);
	if (file.is_open()) {
		try {
			json j = json::parse(file);
			if (j.contains("client")) {
				auto& c = j["client"];
				config.client.playerName = c.value("playerName", "Player");
				config.client.lastIp = c.value("lastIp", "127.0.0.1");
				config.client.lastPort = c.value("lastPort", 7777);
				config.client.targetFPS = c.value("targetFPS", 60);
				config.client.resolutionWidth = c.value("resW", 1280);
				config.client.resolutionHeight = c.value("resH", 720);
				config.client.masterServerIp = c.value("masterIp", "127.0.0.1");
				config.client.masterServerPort = c.value("masterPort", 8080);

				if (c.contains("favorites")) {
					config.client.favoriteServers.clear();
					for (auto& elem : c["favorites"]) {
						SavedServer s;
						s.name = elem.value("name", "Server");
						s.ip = elem.value("ip", "127.0.0.1");
						s.port = elem.value("port", 7777);
						config.client.favoriteServers.push_back(s);
					}
				}
			}
			if (j.contains("server")) {
				config.server.port = j["server"].value("port", 7777);
				config.server.pvpDamageFactor = j["server"].value("pvpDamageFactor", 1.0f);
				config.server.maxPlayers = j["server"].value("maxPlayers", 8);
				config.server.tickRate = j["server"].value("tickRate", 60);
				config.server.serverName = j["server"].value("serverName", "Void Server");
			}
		}
		catch (...) { CreateDefaultConfig(); }
	}
}

void ConfigManager::LoadFonts() {
	int codepoints[512] = { 0 };
	for (int i = 0; i < 95; i++) codepoints[i] = 32 + i;
	for (int i = 0; i < 255; i++) codepoints[96 + i] = 0x400 + i;
	const char* fontPath = "assets/fonts/Roboto-Regular.ttf";
	if (FileExists(fontPath)) {
		mainFont = LoadFontEx(fontPath, 64, codepoints, 512);
		GenTextureMipmaps(&mainFont.texture);
		SetTextureFilter(mainFont.texture, TEXTURE_FILTER_BILINEAR);
	}
	else { mainFont = GetFontDefault(); }
}

void ConfigManager::UnloadResources() { if (mainFont.texture.id != 0) UnloadFont(mainFont); }

void ConfigManager::LoadLanguage(const std::string& langCode) {
	localizedStrings.clear();
	std::string path = "assets/lang/lang_" + langCode + ".json";
	char* text = LoadFileText(path.c_str());
	if (text) {
		try {
			json j = json::parse(text);
			for (auto& element : j.items()) localizedStrings[element.key()] = element.value().get<std::string>();
		}
		catch (...) {}
		UnloadFileText(text);
	}
}

const char* ConfigManager::Text(const std::string& key) {
	if (localizedStrings.count(key)) return localizedStrings[key].c_str();
	return key.c_str();
}

std::string ConfigManager::GetCurrentLangName()
{
	if (localizedStrings.count("lang_name")) return localizedStrings["lang_name"];
	return config.client.language;
}

void ConfigManager::CycleLanguage()
{
	if (config.client.language == "en") {
		config.client.language = "ru";
	}
	else {
		config.client.language = "en";
	}
	LoadLanguage(config.client.language);
	Save();
}

ClientConfig& ConfigManager::GetClient() { return config.client; }
ServerConfig& ConfigManager::GetServer() { return config.server; }
Font ConfigManager::GetFont() { return mainFont; }
void ConfigManager::SetFont(Font font) { mainFont = font; }
// engine\Utils\ConfigManager.h
﻿#pragma once
#include <string>
#include <fstream>
#include <filesystem>
#include <iostream>
#include <map>
#include <vector>
#include "raylib.h"
#include "nlohmann/json.hpp"
using json = nlohmann::json;
#include "MasterServerIP.h"

#ifndef MASTER_IP
#define MASTER_IP "127.0.0.1"
#endif
struct SavedServer {
	std::string name;
	std::string ip;
	int port;
};

struct ClientConfig {
	std::string playerName = "Player";
	std::string lastIp = "127.0.0.1";
	int lastPort = 7777;
	std::string language = "ru";
	float masterVolume = 1.0f;
	float musicVolume = 0.7f;
	bool fullscreen = false;
	int targetFPS = 60;

	std::string masterServerIp = MASTER_IP;
	int masterServerPort = 8080;

	int resolutionWidth = 1280;
	int resolutionHeight = 720;

	std::vector<SavedServer> favoriteServers;
};

struct ServerConfig {
	int port = 7777;
	int maxPlayers = 8;
	int tickRate = 60;
	float pvpDamageFactor = 1.0f;
	std::string serverName = "Void Lobby";
};

struct GameConfig {
	ClientConfig client;
	ServerConfig server;
};

class ConfigManager {
private:
	static GameConfig config;
	static std::string configPath;
	static Font mainFont;
	static std::map<std::string, std::string> localizedStrings;
	static void CreateDefaultConfig();
public:
	static void CycleLanguage();
	static std::string GetCurrentLangName();
	static void Initialize(const std::string& savePath);
	static void Save();
	static void Load();
	static void LoadLanguage(const std::string& langCode);
	static const char* Text(const std::string& key);

	static ClientConfig& GetClient();
	static ServerConfig& GetServer();

	static void LoadFonts();
	static Font GetFont();
	static void SetFont(Font font);
	static void UnloadResources();
};
// engine\Utils\MasterServerIP.h
﻿#define MASTER_IP "89.125.3.170"
// server\CMakeLists.txt
﻿#server module CMakeLists.txt
add_executable(GameServer
    main_server.cpp)
target_include_directories(GameServer PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_link_libraries(GameServer PRIVATE GameEngine GameCommon enet::enet_shared)

add_executable(MasterServer
    main_master.cpp
)
target_include_directories(MasterServer PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_link_libraries(MasterServer PRIVATE GameCommon enet::enet_shared)

// server\main_master.cpp
﻿#include "../common/enet/ENetServer.h"
#include "../common/NetworkPackets.h"
#include <iostream>
#include <map>
#include <string>
#include <thread>
#include <chrono>
#include <mutex>

struct ActiveLobby {
    uint32_t id;
    std::string ip;
    uint16_t port;
    std::string name;
    uint8_t currentPlayers;
    uint8_t maxPlayers;
    uint8_t wave;
    double lastHeartbeatTime;
    uint32_t peerId;
};

std::map<uint32_t, ActiveLobby> lobbies;
std::mutex lobbyMutex;
uint32_t nextLobbyId = 1;

double GetTime() {
    return std::chrono::duration<double>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
}

int main(int argc, char** argv) {
    if (enet_initialize() != 0) {
        std::cerr << "Failed to initialize ENet.\n";
        return 1;
    }

    ENetServer::Shared server = ENetServer::alloc();
    int port = 8080;
    if (server->start(port, 1024)) {
        std::cout << "MASTER SERVER: Started on port " << port << std::endl;
    }
    else {
        std::cerr << "MASTER SERVER: Failed to start on port " << port << std::endl;
        return -1;
    }

    while (server->isRunning()) {
        auto msgs = server->poll();

        double now = GetTime();

        for (auto& msg : msgs) {
            uint32_t peerId = msg->peerId();

            if (msg->type() == MessageType::DISCONNECT) {
                std::lock_guard<std::mutex> lock(lobbyMutex);
                for (auto it = lobbies.begin(); it != lobbies.end(); ) {
                    if (it->second.peerId == peerId) {
                        std::cout << "Lobby removed (Disconnect): " << it->second.name << "\n";
                        it = lobbies.erase(it);
                    }
                    else {
                        ++it;
                    }
                }
            }
            else if (msg->type() == MessageType::DATA) {
                const auto& buf = msg->stream()->buffer();
                size_t offset = msg->stream()->tellg();
                if (!buf.empty() && offset < buf.size()) {
                    InputAdapter ia(buf.begin() + offset, buf.end());
                    bitsery::Deserializer<InputAdapter> des(std::move(ia));
                    uint8_t type; des.value1b(type);

                    if (type == GamePacket::MASTER_REGISTER) {
                        MasterRegisterPacket pkt; des.object(pkt);
                        if (des.adapter().error() == bitsery::ReaderError::NoError) {
                            std::lock_guard<std::mutex> lock(lobbyMutex);


                            ActiveLobby lobby;
                            lobby.id = nextLobbyId++;
                            lobby.peerId = peerId;
                            lobby.port = pkt.gamePort;
                            lobby.name = pkt.serverName;
                            lobby.maxPlayers = pkt.maxPlayers;
                            lobby.currentPlayers = 0;
                            lobby.wave = 1;
                            lobby.lastHeartbeatTime = now;

                            lobby.ip = "Unknown";

                            lobbies[lobby.id] = lobby;
                            std::cout << "Lobby Registered: " << lobby.name << " (ID: " << lobby.id << ")\n";
                        }
                    }
                    else if (type == GamePacket::MASTER_HEARTBEAT) {
                        MasterHeartbeatPacket pkt; des.object(pkt);
                        if (des.adapter().error() == bitsery::ReaderError::NoError) {
                            std::lock_guard<std::mutex> lock(lobbyMutex);
                            for (auto& pair : lobbies) {
                                if (pair.second.peerId == peerId) {
                                    pair.second.currentPlayers = pkt.currentPlayers;
                                    pair.second.wave = pkt.wave;
                                    pair.second.lastHeartbeatTime = now;
                                    break;
                                }
                            }
                        }
                    }
                    else if (type == GamePacket::MASTER_LIST_REQ) {
                        std::lock_guard<std::mutex> lock(lobbyMutex);
                        MasterListResPacket res;
                        for (const auto& pair : lobbies) {
                            LobbyInfo info;
                            info.id = pair.second.id;
                            info.name = pair.second.name;
                            info.ip = pair.second.ip;
                            info.port = pair.second.port;
                            info.currentPlayers = pair.second.currentPlayers;
                            info.maxPlayers = pair.second.maxPlayers;
                            info.wave = pair.second.wave;
                            res.lobbies.push_back(info);
                        }

                        Buffer resBuf; OutputAdapter resAd(resBuf);
                        bitsery::Serializer<OutputAdapter> ser(std::move(resAd));
                        ser.value1b(GamePacket::MASTER_LIST_RES);
                        ser.object(res);
                        ser.adapter().flush();
                        server->send(peerId, DeliveryType::RELIABLE, StreamBuffer::alloc(resBuf.data(), resBuf.size()));

                    }
                }
            }
        }

        {
            std::lock_guard<std::mutex> lock(lobbyMutex);
            for (auto it = lobbies.begin(); it != lobbies.end(); ) {
                if (now - it->second.lastHeartbeatTime > 30.0) {
                    std::cout << "Lobby timed out: " << it->second.name << "\n";
                    it = lobbies.erase(it);
                }
                else {
                    ++it;
                }
            }
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }

    enet_deinitialize();
    return 0;
}
// server\main_server.cpp
﻿#include "../engine/ServerHost.h"
#include <iostream>
#include <string>
#include <thread>
#include <chrono>
#include <atomic>
#include <csignal>

std::atomic<bool> keepRunning{ true };

void SignalHandler(int signum) {
    std::cout << "\nSignal " << signum << " received. Stopping server...\n";
    keepRunning = false;
}

int main() {
    srand(time(NULL));
    if (enet_initialize() != 0) {
        std::cerr << "An error occurred while initializing ENet.\n";
        return 1;
    }

#ifdef WIN32
    InitWindow(100, 100, "ServerHeadless");
    SetWindowState(FLAG_WINDOW_HIDDEN);
#else
    signal(SIGINT, SignalHandler);
    signal(SIGTERM, SignalHandler);
#endif

    ServerHost server;
    if (server.Start(7777, 128)) {
        std::cout << "Dedicated Server started on port 7777.\n";

#ifdef WIN32
        std::cout << "Type 'quit' to stop.\n";
        std::string cmd;
        while (std::cin >> cmd) {
            if (cmd == "quit") break;
        }
#else
        while (keepRunning) {
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        }
#endif

        server.Stop();
    }
    enet_deinitialize();
    return 0;
}