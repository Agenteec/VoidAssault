
// merged.txt

// reader.py
import os

def merge_files(root_dir, output_file, extensions=None):
    """
    Рекурсивно считывает все файлы из root_dir и записывает в один файл.
    Перед каждым файлом вставляется комментарий с его путём.
    extensions — список расширений, если нужно фильтровать (например ['.h', '.cpp'])
    Если extensions=None — берутся все файлы.
    """
    with open(output_file, "w", encoding="utf-8") as out:
        for folder, _, files in os.walk(root_dir):
            for file in files:
                file_path = os.path.join(folder, file)
                rel_path = os.path.relpath(file_path, root_dir)
                
                # Фильтр по расширениям, если нужно
                if extensions is not None:
                    _, ext = os.path.splitext(file)
                    if ext.lower() not in extensions:
                        continue

                out.write(f"\n// {rel_path}\n")

                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        out.write(f.read())
                except Exception as e:
                    out.write(f"[Ошибка при чтении файла: {e}]\n")


if __name__ == "__main__":
    merge_files(
        root_dir=".", 
        output_file="merged.txt",
        extensions=None 
    )

// client\AudioManager.h
﻿#pragma once
#include "raylib.h"
#include <map>
#include <string>
#include <iostream>

class AudioManager {
    std::map<std::string, Sound> sounds;
    std::map<std::string, Music> musics;
    float masterVolume = 1.0f;

public:
    AudioManager() {
        InitAudioDevice();
    }

    ~AudioManager() {
        for (auto& s : sounds) UnloadSound(s.second);
        for (auto& m : musics) UnloadMusicStream(m.second);
        CloseAudioDevice();
    }

    void LoadSnd(const std::string& key, const std::string& path) {
        Sound s = LoadSound(path.c_str());
        if (s.frameCount > 0) sounds[key] = s;
        else std::cout << "Failed to load sound: " << path << std::endl;
    }

    void LoadMus(const std::string& key, const std::string& path) {
        Music m = LoadMusicStream(path.c_str());
        if (m.frameCount > 0) musics[key] = m;
    }

    void PlaySnd(const std::string& key) {
        if (sounds.count(key)) {
            SetSoundVolume(sounds[key], masterVolume);
            PlaySound(sounds[key]);
        }
    }

    void PlayMus(const std::string& key) {
        if (musics.count(key)) {
            if (!IsMusicStreamPlaying(musics[key])) PlayMusicStream(musics[key]);
            SetMusicVolume(musics[key], masterVolume);
            UpdateMusicStream(musics[key]);
        }
    }

    void Update() {
        for (auto& pair : musics) {
            if (IsMusicStreamPlaying(pair.second)) UpdateMusicStream(pair.second);
        }
    }

    void SetVolume(float vol) { masterVolume = vol; }
    float GetVolume() const { return masterVolume; }
};
// client\CMakeLists.txt
﻿    file(GLOB CLIENT_SOURCES "*.cpp" "scenes/*.cpp")
#file(GLOB_RECURSE Imgui_SFML_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/../imgui-sfml/*.*")
if(WIN32 OR CMAKE_SYSTEM_NAME STREQUAL "Linux" OR LINUX)

    add_executable(GameClient
        ${CLIENT_SOURCES}
    )

    #if(WIN32)
      #  set_target_properties(GameClient PROPERTIES WIN32_EXECUTABLE ON)
    #endif()

    target_link_libraries(GameClient PRIVATE raylib GameEngine GameCommon enet::enet_shared nlohmann_json)

    target_include_directories(GameClient PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
    target_include_directories(GameClient PRIVATE ${PROJECT_INCLUDE_DIR})
    target_include_directories(GameClient PRIVATE ${ENET_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PRIVATE ${RAYGUI_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
    file(COPY ${CMAKE_SOURCE_DIR}/assets DESTINATION ${GLOBAL_OUTPUT_DIR})

elseif(ANDROID)
    add_library(gameclient SHARED ${CLIENT_SOURCES})

    target_link_libraries(gameclient  PRIVATE android log
        raylib
    GameEngine 
    GameCommon
    enet::enet_shared
    chipmunk_static
    nlohmann_json)
    target_include_directories(gameclient PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
    target_include_directories(gameclient PRIVATE ${PROJECT_INCLUDE_DIR})
    target_include_directories(gameclient PRIVATE ${ENET_EXTERNAL_INCLUDE_DIR})
    target_include_directories(gameclient PRIVATE ${RAYGUI_EXTERNAL_INCLUDE_DIR})
    target_include_directories(gameclient PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})

target_include_directories(gameclient PUBLIC "${CMAKE_SOURCE_DIR}/external")
endif()






// client\GameClient.cpp
﻿#include "GameClient.h"
#include "scenes/MainMenuScene.h" 
#include "scenes/GameplayScene.h"

GameClient::GameClient() {
    InitWindow(screenWidth, screenHeight, "Void Assault");
    SetTargetFPS(60);
    SetWindowState(FLAG_WINDOW_RESIZABLE);

    // Инициализация ENetClient
    netClient = ENetClient::alloc();

    GuiSetStyle(DEFAULT, TEXT_SIZE, 20);
}

GameClient::~GameClient() {
    StopHost();
    if (currentScene) currentScene->Exit();

    if (netClient) netClient->disconnect();

    CloseWindow();
}

void GameClient::ChangeScene(std::shared_ptr<Scene> newScene) {
    nextScene = newScene;
}

void GameClient::ReturnToMenu() {
    if (netClient) netClient->disconnect();
    ChangeScene(std::make_shared<MainMenuScene>(this));
}

int GameClient::StartHost(int startPort) {
    StopHost();
    localServer = std::make_unique<ServerHost>();

    for (int p = startPort; p < startPort + 10; p++) {
        if (localServer->Start(p)) {
            TraceLog(LOG_INFO, "Local Server Started on port %d", p);
            return p;
        }
    }

    TraceLog(LOG_ERROR, "Failed to start local server. All ports busy?");
    localServer.reset();
    return -1;
}

void GameClient::StopHost() {
    if (localServer) {
        localServer->Stop();
        localServer.reset();
        TraceLog(LOG_INFO, "Local Server Stopped.");
    }
}

void GameClient::Run() {
    ChangeScene(std::make_shared<MainMenuScene>(this));

    while (!WindowShouldClose()) {
        if (nextScene) {
            if (currentScene) currentScene->Exit();
            currentScene = nextScene;
            currentScene->Enter();
            nextScene = nullptr;
        }

        float dt = GetFrameTime();

        // --- Сетевой цикл ---
        if (netClient) {
            auto msgs = netClient->poll();

            for (auto& msg : msgs) {
                if (msg->type() == MessageType::CONNECT) {
                    TraceLog(LOG_INFO, ">> CLIENT: Connected to server!");
                    // Если мы не в игре, переходим
                    if (!std::dynamic_pointer_cast<GameplayScene>(currentScene)) {
                        ChangeScene(std::make_shared<GameplayScene>(this));
                    }
                }
                else if (msg->type() == MessageType::DISCONNECT) {
                    TraceLog(LOG_INFO, ">> CLIENT: Disconnected.");
                    if (std::dynamic_pointer_cast<GameplayScene>(currentScene)) {
                        ReturnToMenu();
                    }
                }
                else if (msg->type() == MessageType::DATA) {
                    // Передаем данные в текущую сцену через OnMessage
                    if (currentScene) {
                        currentScene->OnMessage(msg);
                    }
                }
            }
        }
        // --------------------

        if (currentScene) {
            currentScene->Update(dt);
            BeginDrawing();
            ClearBackground(RAYWHITE);
            currentScene->Draw();
            currentScene->DrawGUI();
            EndDrawing();
        }
    }
}
// client\GameClient.h
﻿#pragma once
#include "raygui_wrapper.h"
#include "enet/ENetClient.h" 
#include "../engine/Scenes/Scene.h"
#include "../engine/ServerHost.h"
#include "AudioManager.h"
#include <memory>

class Scene;

class GameClient {
public:
    int screenWidth = 1280;
    int screenHeight = 720;

    // Сетевой клиент
    ENetClient::Shared netClient;

    std::unique_ptr<ServerHost> localServer;
    AudioManager audio;

    std::shared_ptr<Scene> currentScene;
    std::shared_ptr<Scene> nextScene;

    GameClient();
    ~GameClient();

    void Run();
    void ChangeScene(std::shared_ptr<Scene> newScene);
    void ReturnToMenu();

    int StartHost(int port);
    void StopHost();

    int GetWidth() const { return GetScreenWidth(); }
    int GetHeight() const { return GetScreenHeight(); }
};
// client\main_client.cpp
﻿// Определяем реализацию raygui ПЕРЕД включением заголовков
#define RAYGUI_IMPLEMENTATION
#include "raygui_wrapper.h" 

#include "GameClient.h"
#include "engine/Utils/ConfigManager.h"

// Обязательно подключаем ENet для main функции
#include <enet.h> 

int* GetCompleteCodepoints(int* count) {
    static int completeChars[] = {
            0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029,
            0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, 0x0030, 0x0031, 0x0032, 0x0033,
            0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D,
            0x003E, 0x003F, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
            0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, 0x0050, 0x0051,
            0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B,
            0x005C, 0x005D, 0x005E, 0x005F, 0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065,
            0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
            0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079,
            0x007A, 0x007B, 0x007C, 0x007D, 0x007E,
            0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419,
            0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F, 0x0420, 0x0421, 0x0422, 0x0423,
            0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D,
            0x042E, 0x042F, 0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
            0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F, 0x0440, 0x0441,
            0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044A, 0x044B,
            0x044C, 0x044D, 0x044E, 0x044F, 0x0401, 0x0451
    };

    *count = sizeof(completeChars) / sizeof(completeChars[0]);
    int* result = (int*)malloc(*count * sizeof(int));
    memcpy(result, completeChars, *count * sizeof(int));
    return result;
}

Font LoadFont() {
    int codepointCount = 0;
    int* completeCodepoints = GetCompleteCodepoints(&codepointCount);
    Font mainFont;
#ifdef ANDROID
    mainFont = LoadFontEx("assets/fonts/Roboto-Regular.ttf", 24, completeCodepoints, codepointCount);
#else
    mainFont = LoadFontEx("assets/fonts/Roboto-Regular.ttf", 24, completeCodepoints, codepointCount);
#endif 
    GuiSetStyle(DEFAULT, TEXT_SIZE, 20); // GuiSetStyle теперь будет виден
    free(completeCodepoints);
    GuiSetFont(mainFont); // GuiSetFont теперь будет виден
    return mainFont;
}

int main() {
    // Инициализация ENet глобально
    if (enet_initialize() != 0) {
        return -1;
    }
    atexit(enet_deinitialize);

    {
        // Создаем игру в области видимости, чтобы деструктор вызвался до atexit
        GameClient game;
        std::string configPath = "./";

#if defined(ANDROID) || defined(PLATFORM_ANDROID)
        configPath = GetApplicationDirectory();
#endif

        ConfigManager::Initialize(configPath);

        auto f = LoadFont();
        ConfigManager::SetFont(f);
        GuiSetFont(f);

        SetTargetFPS(ConfigManager::GetClient().targetFPS);
        if (ConfigManager::GetClient().fullscreen) {
            ToggleFullscreen();
        }

        game.Run();
    } // Здесь вызовется деструктор GameClient

    return 0;
}
// client\ParticleSystem.h
﻿#pragma once
#include "raylib.h"
#include <vector>
#include <algorithm>

struct Particle {
    Vector2 position;
    Vector2 velocity;
    float life;      // 1.0 -> 0.0
    float decayRate; // Скорость исчезновения
    float size;
    Color color;
};

class ParticleSystem {
    std::vector<Particle> particles;

public:
    void Spawn(Vector2 pos, Vector2 vel, Color col, float size, float lifeTime) {
        Particle p;
        p.position = pos;
        p.velocity = vel;
        p.color = col;
        p.size = size;
        p.life = 1.0f;
        p.decayRate = 1.0f / lifeTime;
        particles.push_back(p);
    }

    void SpawnExplosion(Vector2 pos, int count, Color col) {
        for (int i = 0; i < count; i++) {
            float angle = (float)GetRandomValue(0, 360) * DEG2RAD;
            float speed = (float)GetRandomValue(50, 200) / 10.0f;
            Vector2 vel = { cosf(angle) * speed, sinf(angle) * speed };
            Spawn(pos, vel, col, (float)GetRandomValue(3, 8), 0.5f);
        }
    }

    void Update(float dt) {
        for (auto& p : particles) {
            p.position.x += p.velocity.x * dt * 60.0f;
            p.position.y += p.velocity.y * dt * 60.0f;
            p.life -= p.decayRate * dt;
            p.size *= 0.95f;
        }

        particles.erase(
            std::remove_if(particles.begin(), particles.end(),
                [](const Particle& p) { return p.life <= 0; }),
            particles.end());
    }

    void Draw() {
        for (const auto& p : particles) {
            Color c = p.color;
            c.a = (unsigned char)(p.life * 255);
            DrawCircleV(p.position, p.size, c);
        }
    }
};
// client\raygui_wrapper.h
﻿// raygui_wrapper.h
#pragma once

#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "raylib.h"
#include "raygui.h"
// client\ResourceManager.h
﻿#pragma once
#include "raylib.h"
#include <string>

class ResourceManager {
public:
    Font mainFont;

    static ResourceManager& Get() {
        static ResourceManager instance;
        return instance;
    }

    void Load() {
        // Загружаем шрифт. Если файла нет, Raylib загрузит дефолтный, но с фильтрацией
        // В реальном проекте положи файл .ttf в папку assets
        // mainFont = LoadFontEx("assets/font.ttf", 64, 0, 0);

        // Пока используем дефолтный, но ставим фильтр для гладкости
        mainFont = GetFontDefault();
        SetTextureFilter(mainFont.texture, TEXTURE_FILTER_BILINEAR);
    }

    void Unload() {
        // UnloadFont(mainFont);
    }

    static void DrawTextCentered(const char* text, int cx, int cy, int fontSize, Color color) {
        int width = MeasureText(text, fontSize);
        DrawText(text, cx - width / 2, cy - fontSize / 2, fontSize, color);
    }
};
// client\Theme.h
#pragma once
#include "raylib.h"

namespace Theme {
    static const Color BG_COLOR = { 205, 205, 205, 255 };
    static const Color GRID_COLOR = { 170, 170, 170, 255 };
    static const Color BORDER_COLOR = { 85, 85, 85, 255 };

    static const Color COLOR_BLUE = { 0, 178, 225, 255 };
    static const Color COLOR_RED = { 241, 78, 84, 255 };
    static const Color COLOR_BARREL = { 153, 153, 153, 255 };

    static const float OUTLINE_THICKNESS = 3.0f;
    static const float BARREL_WIDTH_RATIO = 0.45f;
}
// client\VirtualJoystick.cpp
﻿#include "VirtualJoystick.h"
#include "raymath.h"

#ifndef MAX_TOUCH_POINTS
#define MAX_TOUCH_POINTS 10
#endif

VirtualJoystick::VirtualJoystick() {

}

VirtualJoystick::VirtualJoystick(Vector2 pos, float rStick, float rBody) {
    position = pos;
    stickPosition = pos;
    radiusStick = rStick;
    radiusBody = rBody;
    radiusInteraction = rBody * 1.5f;
}

void VirtualJoystick::SetPosition(Vector2 pos) {
    position = pos;
    if (!dragging) {
        stickPosition = pos;
    }
}

void VirtualJoystick::SetPosition(float x, float y) {
    SetPosition({ x, y });
}

bool VirtualJoystick::IsTouchInBounds(Vector2 touchPos) const {
    return Vector2Distance(touchPos, position) <= radiusInteraction;
}

void VirtualJoystick::Update() {
    bool inputFound = false;
    Vector2 inputPos = { 0, 0 };


    if (dragging) {
        if (touchId == -2) {
            if (IsMouseButtonDown(MOUSE_LEFT_BUTTON)) {
                inputPos = GetMousePosition();
                inputFound = true;
            }
        }
        else {
            if (touchId < GetTouchPointCount()) {
                inputPos = GetTouchPosition(touchId);
                inputFound = true;
            }
        }

        if (!inputFound) {
            Reset();
            return;
        }
    }
    else {
        int count = GetTouchPointCount();
        for (int i = 0; i < count && i < MAX_TOUCH_POINTS; i++) {
            Vector2 touchPos = GetTouchPosition(i);
            if (IsTouchInBounds(touchPos)) {
                dragging = true;
                touchId = i;
                inputPos = touchPos;
                inputFound = true;
                break;
            }
        }

        if (!inputFound && IsMouseButtonDown(MOUSE_LEFT_BUTTON)) {
            Vector2 mousePos = GetMousePosition();
            if (IsTouchInBounds(mousePos)) {
                dragging = true;
                touchId = -2;
                inputPos = mousePos;
                inputFound = true;
            }
        }
    }

    if (dragging) {
        Vector2 direction = Vector2Subtract(inputPos, position);
        float distance = Vector2Length(direction);

        if (distance > radiusBody) {
            direction = Vector2Scale(Vector2Normalize(direction), radiusBody);
            stickPosition = Vector2Add(position, direction);
        }
        else {
            stickPosition = inputPos;
        }

        if (radiusBody > 0) {
            axis = Vector2Scale(direction, 1.0f / radiusBody);
        }

        if (Vector2Length(axis) > 1.0f) {
            axis = Vector2Normalize(axis);
        }
    }
    else {
        Reset();
    }
}

void VirtualJoystick::Reset() {
    stickPosition = position;
    dragging = false;
    touchId = -1;
    axis = { 0, 0 };
}

void VirtualJoystick::Draw() {

    DrawCircleV(position, radiusBody, colorBody);
    DrawRing(position, radiusBody, radiusBody + 2, 0, 360, 24, Fade(colorBody, 0.8f));

    DrawCircleV(stickPosition, radiusStick, colorStick);

    if (dragging) {
        DrawCircleV(stickPosition, radiusStick * 0.8f, Fade(WHITE, 0.3f));
    }
}
// client\VirtualJoystick.h
﻿#pragma once
#include <raylib.h>

class VirtualJoystick {
public:
    VirtualJoystick();
    VirtualJoystick(Vector2 pos, float radiusStick, float radiusBody);

    void Update();
    void Draw();
    void Reset();


    Vector2 GetAxis() const { return axis; }

    const Vector2& GetPosition() const { return position; }
    void SetPosition(Vector2 pos);
    void SetPosition(float x, float y);

    bool IsDragging() const { return dragging; }


    void SetColors(Color body, Color stick) {
        colorBody = body;
        colorStick = stick;
    }

    void SetRadii(float body, float stick, float interaction) {
        radiusBody = body;
        radiusStick = stick;
        radiusInteraction = interaction;
    }

private:
    int touchId = -1;
    bool dragging = false;

    Vector2 position = { 0, 0 };
    Vector2 stickPosition = { 0, 0 };
    Vector2 axis = { 0, 0 };


    float radiusStick = 20.0f;
    float radiusBody = 50.0f;
    float radiusInteraction = 60.0f;


    Color colorStick = { 200, 200, 200, 255 };
    Color colorBody = { 50, 50, 50, 150 };


    bool IsTouchInBounds(Vector2 touchPos) const;
};
// client\scenes\GameplayScene.cpp
﻿#include "GameplayScene.h"
#include "MainMenuScene.h"
#include "GameClient.h"

GameplayScene::GameplayScene(GameClient* g) : Scene(g) {}

void GameplayScene::Enter() {
    float w = (float)game->GetWidth();
    float h = (float)game->GetHeight();

    camera.zoom = 1.0f;
    camera.offset = { w / 2, h / 2 };

    // Инициализация джойстиков
    leftStick = std::make_unique<VirtualJoystick>(Vector2{ 150, h - 150 }, 40.0f, 90.0f);
    rightStick = std::make_unique<VirtualJoystick>(Vector2{ w - 150, h - 150 }, 40.0f, 90.0f);
    rightStick->SetColors({ 60, 0, 0, 150 }, { 220, 50, 50, 200 });
}

void GameplayScene::Exit() {
    // Отключаемся при выходе
    if (game->netClient) game->netClient->disconnect();
    game->StopHost();
    worldEntities.clear();
}

void GameplayScene::OnMessage(Message::Shared msg) {
    // Получаем поток данных
    auto stream = msg->stream();

    // Читаем тип пакета (первый байт)
    uint8_t packetType = 0;
    stream->read(packetType);

    if (packetType == GamePacket::INIT) {
        // Читаем InitData (просто ID)
        stream->read(myPlayerId);
    }
    else if (packetType == GamePacket::SNAPSHOT) {
        // Читаем количество сущностей
        uint32_t entityCount = 0;
        stream->read(entityCount);

        std::vector<uint32_t> receivedIds;
        for (uint32_t i = 0; i < entityCount; i++) {
            EntityState st;
            stream >> st; // Десериализация сущности (через оператор >> в NetworkPackets.h)

            receivedIds.push_back(st.id);
            worldEntities[st.id].PushState(st);
        }

        // Удаляем устаревшие сущности
        for (auto it = worldEntities.begin(); it != worldEntities.end();) {
            bool found = false;
            for (uint32_t id : receivedIds) if (id == it->first) found = true;
            if (!found) it = worldEntities.erase(it);
            else ++it;
        }
    }
}

void GameplayScene::Update(float dt) {
    // 1. Обновляем джойстики
    leftStick->Update();
    rightStick->Update();

    PlayerInputPacket pkt;
    // pkt.type больше не нужно, тип пишется в stream отдельно

    // 2. Логика движения
    Vector2 moveDir = leftStick->GetAxis();
    pkt.movement = moveDir;

    // Поддержка клавиатуры (WASD)
    if (IsKeyDown(KEY_W)) pkt.movement.y -= 1.0f;
    if (IsKeyDown(KEY_S)) pkt.movement.y += 1.0f;
    if (IsKeyDown(KEY_A)) pkt.movement.x -= 1.0f;
    if (IsKeyDown(KEY_D)) pkt.movement.x += 1.0f;

    // Нормализация
    if (Vector2Length(pkt.movement) > 1.0f) {
        pkt.movement = Vector2Normalize(pkt.movement);
    }

    // 3. Логика стрельбы
    Vector2 aimDir = rightStick->GetAxis();

    if (Vector2Length(aimDir) > 0.2f) { // Deadzone
        pkt.isShooting = true;
        if (worldEntities.count(myPlayerId)) {
            Vector2 playerPos = worldEntities[myPlayerId].renderPos;
            pkt.aimTarget = Vector2Add(playerPos, Vector2Scale(aimDir, 300.0f));
        }
    }
    else {
        pkt.aimTarget = GetScreenToWorld2D(GetMousePosition(), camera);
        pkt.isShooting = IsMouseButtonDown(MOUSE_LEFT_BUTTON);
    }

    if (game->netClient && game->netClient->isConnected()) {
        auto stream = StreamBuffer::alloc();

        stream->write((uint8_t)GamePacket::INPUT);
        stream << pkt;


        game->netClient->send(DeliveryType::UNRELIABLE, stream);
    }

    for (auto& [id, ent] : worldEntities) {
        ent.UpdateInterpolation();
    }

    if (worldEntities.count(myPlayerId)) {
        Vector2 target = worldEntities[myPlayerId].renderPos;
        camera.target = Vector2Lerp(camera.target, target, 0.1f);
    }
}

void GameplayScene::Draw() {
    BeginMode2D(camera);
    DrawGrid(100, 50);
    DrawRectangleLines(0, 0, 2000, 2000, GRAY);

    for (auto& [id, ent] : worldEntities) {
        EntityState& st = ent.current;

        if (st.type == EntityType::PLAYER) {
            DrawCircleV(ent.renderPos, st.radius, st.color);
            Vector2 barrelEnd = {
                ent.renderPos.x + cosf(ent.renderRot * DEG2RAD) * 40,
                ent.renderPos.y + sinf(ent.renderRot * DEG2RAD) * 40
            };
            DrawLineEx(ent.renderPos, barrelEnd, 15, DARKGRAY);

            float hpPct = st.health / st.maxHealth;
            if (st.maxHealth > 0) {
                DrawRectangle((int)ent.renderPos.x - 20, (int)ent.renderPos.y - 40, 40, 5, RED);
                DrawRectangle((int)ent.renderPos.x - 20, (int)ent.renderPos.y - 40, (int)(40 * hpPct), 5, GREEN);
            }
        }
        else if (st.type == EntityType::BULLET) {
            DrawCircleV(ent.renderPos, st.radius, RED);
        }
    }
    EndMode2D();
}

void GameplayScene::DrawGUI() {
    DrawFPS(10, 10);

    if (game->netClient && !game->netClient->isConnected()) {
        DrawText("Connecting to server...", game->GetWidth() / 2 - 100, 20, 20, RED);
    }

    leftStick->Draw();
    rightStick->Draw();

    if (GuiButton(Rectangle{ (float)game->GetWidth() - 100, 10, 90, 30 }, "DISCONNECT")) {
        game->ReturnToMenu();
    }
}
// client\scenes\GameplayScene.h
﻿#pragma once
#include "external/fix_win32_compatibility.h"
#include "../../engine/Scenes/Scene.h"
#include "../../common/NetworkPackets.h"
#include "../ParticleSystem.h"
#include "../VirtualJoystick.h"
#include "raymath.h"
#include <map>
#include <vector>
#include <memory>

class GameClient;

struct InterpolatedEntity {
    EntityState current;
    EntityState previous;
    float lastUpdateTime;
    Vector2 renderPos;
    float renderRot;

    InterpolatedEntity() : lastUpdateTime(0), renderRot(0) {}

    void PushState(const EntityState& newState) {
        previous = current;
        current = newState;
        lastUpdateTime = (float)GetTime();
        if (previous.id == 0) previous = current;
    }

    void UpdateInterpolation() {
        double serverTickRate = 0.05;
        double t = (GetTime() - lastUpdateTime) / serverTickRate;
        if (t > 1.0) t = 1.0;
        if (t < 0.0) t = 0.0;

        renderPos = Vector2Lerp(previous.position, current.position, (float)t);
        renderRot = Lerp(previous.rotation, current.rotation, (float)t);
    }
};

class GameplayScene : public Scene {
    Camera2D camera = { 0 };
    std::map<uint32_t, InterpolatedEntity> worldEntities;
    uint32_t myPlayerId = 0;
    std::unique_ptr<VirtualJoystick> leftStick;
    std::unique_ptr<VirtualJoystick> rightStick;

public:
    GameplayScene(GameClient* g);
    virtual ~GameplayScene() = default;

    void Enter() override;
    void Exit() override;

    void OnMessage(Message::Shared msg) override;

    void Update(float dt) override;
    void Draw() override;
    void DrawGUI() override;
};
// client\scenes\MainMenuScene.cpp
﻿#define _CRT_SECURE_NO_WARNINGS
#include "MainMenuScene.h"
#include "raygui_wrapper.h"
#include "../GameClient.h"
#include "engine/Utils/ConfigManager.h"
#include <cstring>
#include <string>
#include <thread>
#include <chrono>

enum MenuState { STATE_MAIN, STATE_MULTIPLAYER, STATE_SETTINGS };
static MenuState currentState = STATE_MAIN;

static int mpTab = 0;
static char ipBuffer[64] = "";
static char portBuffer[16] = "";
static char nameBuffer[32] = "";
static bool editIp = false;
static bool editPort = false;
static bool editName = false;

MainMenuScene::MainMenuScene(GameClient* g) : Scene(g) {}

void MainMenuScene::Enter() {
    ClientConfig& cfg = ConfigManager::GetClient();
    strcpy(ipBuffer, cfg.lastIp.c_str());
    sprintf(portBuffer, "%d", cfg.lastPort);
    strcpy(nameBuffer, cfg.playerName.c_str());
    currentState = STATE_MAIN;
}

void MainMenuScene::Draw() {
    ClearBackground(GetColor(0x181818FF));
    int w = GetScreenWidth();
    int h = GetScreenHeight();
    float cx = w / 2.0f;

    const char* title = "VOID ASSAULT";
    DrawText(title, cx - MeasureText(title, 60) / 2, 50, 60, WHITE);

    if (currentState == STATE_MAIN) {
        float startY = 200;
        float btnW = 300; float btnH = 50; float spacing = 70;

        if (GuiButton({ cx - btnW / 2, startY, btnW, btnH }, ConfigManager::Text("btn_singleplayer"))) {
            //std::thread([this]() {
                int realPort = game->StartHost(7777);
                if (realPort > 0) {
                    std::this_thread::sleep_for(std::chrono::milliseconds(200));
                    game->netClient->connect("127.0.0.1", realPort);
                }
                //}).detach();
        }

        if (GuiButton({ cx - btnW / 2, startY + spacing, btnW, btnH }, ConfigManager::Text("btn_multiplayer"))) {
            currentState = STATE_MULTIPLAYER;
        }

        if (GuiButton({ cx - btnW / 2, startY + spacing * 2, btnW, btnH }, ConfigManager::Text("btn_settings"))) {
            currentState = STATE_SETTINGS;
        }

        if (GuiButton({ cx - btnW / 2, startY + spacing * 3, btnW, btnH }, ConfigManager::Text("btn_exit"))) {
            CloseWindow();
        }
    }
    else if (currentState == STATE_MULTIPLAYER) {
        GuiLabel({ cx - 150, 130, 300, 20 }, "Nickname:");
        if (GuiTextBox({ cx - 150, 150, 300, 30 }, nameBuffer, 32, editName)) {
            editName = !editName;
            ConfigManager::GetClient().playerName = nameBuffer;
            ConfigManager::Save();
        }

        GuiToggleGroup({ cx - 200, 210, 200, 40 }, "JOIN GAME;HOST GAME", &mpTab);

        float panelY = 270;
        GuiGroupBox({ cx - 250, panelY, 500, 300 }, mpTab == 0 ? "Join Server" : "Create Server");

        if (mpTab == 0) {
            float inY = panelY + 40;
            GuiLabel({ cx - 200, inY, 50, 30 }, "IP:");
            if (GuiTextBox({ cx - 150, inY, 200, 30 }, ipBuffer, 64, editIp)) editIp = !editIp;

            GuiLabel({ cx + 60, inY, 50, 30 }, "Port:");
            if (GuiTextBox({ cx + 100, inY, 80, 30 }, portBuffer, 16, editPort)) editPort = !editPort;

            if (GuiButton({ cx - 100, inY + 60, 200, 40 }, "CONNECT")) {
                ConfigManager::GetClient().lastIp = ipBuffer;
                ConfigManager::GetClient().lastPort = atoi(portBuffer);
                ConfigManager::Save();
                game->netClient->connect(ipBuffer, atoi(portBuffer));
            }

            GuiLabel({ cx - 200, inY + 120, 200, 20 }, "Favorites:");
            auto& favs = ConfigManager::GetClient().favoriteServers;
            for (size_t i = 0; i < favs.size() && i < 3; i++) {
                std::string label = favs[i].name + " (" + favs[i].ip + ")";
                if (GuiButton({ cx - 200, inY + 145 + (i * 35.0f), 400, 30 }, label.c_str())) {
                    game->netClient->connect(favs[i].ip, favs[i].port);
                }
            }
        }
        else {
            float inY = panelY + 80;
            GuiLabel({ cx - 100, inY, 200, 20 }, "Local Port:");
            if (GuiTextBox({ cx - 50, inY + 25, 100, 30 }, portBuffer, 16, editPort)) editPort = !editPort;

            if (GuiButton({ cx - 120, inY + 80, 240, 50 }, "START HOST & PLAY")) {
                int port = atoi(portBuffer);

                int p = game->StartHost(port);
                if (p > 0) {
                    //std::this_thread::sleep_for(std::chrono::milliseconds(50));

                    game->netClient->connect("127.0.0.1", p);
                }
            }
        }

        if (GuiButton({ 30, (float)h - 70, 120, 40 }, "BACK")) {
            currentState = STATE_MAIN;
        }
    }
    else if (currentState == STATE_SETTINGS) {
        float startY = 200;
        GuiLabel({ cx - 150, startY, 300, 20 }, "Master Volume");
        float vol = game->audio.GetVolume();
        if (GuiSlider({ cx - 150, startY + 25, 300, 30 }, "0", "1", &vol, 0, 1)) {
            game->audio.SetVolume(vol);
        }

        startY += 80;
        if (GuiButton({ cx - 150, startY, 300, 40 }, "Toggle Fullscreen")) {
            ToggleFullscreen();
        }

        if (GuiButton({ 30, (float)h - 70, 120, 40 }, "BACK")) {
            currentState = STATE_MAIN;
        }
    }
}
// client\scenes\MainMenuScene.h
﻿#pragma once
#include "external/fix_win32_compatibility.h"
#include "../../engine/Scenes/Scene.h"

class GameClient;

class MainMenuScene : public Scene {
    char ipBuffer[64] = "";
    char portBuffer[16] = "";
    char nameBuffer[32] = "";

    bool isEditingIp = false;
    bool isEditingPort = false;
    bool isEditingName = false;

    // Состояние табов
    int activeTab = 0; // 0 = Connect, 1 = Host

public:
    MainMenuScene(GameClient* g);
    virtual ~MainMenuScene() = default;

    void Enter() override;
    void Exit() override {}
    void Update(float dt) override {}
    void Draw() override;
    void DrawGUI() override {}
};
// client\scenes\SettingsScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"
#include "../../client/GameClient.h"
#include "../Theme.h"

class SettingsScene : public Scene {
public:
    SettingsScene(GameClient* g) : Scene(g) {}

    void Enter() override {}
    void Exit() override {}
    void Update(float dt) override {} // Логика в DrawGUI

    void Draw() override {
        ClearBackground(Theme::BG_COLOR);
        ResourceManager::DrawTextCentered("SETTINGS", game->GetWidth() / 2, 100, 60, Theme::COLOR_BLUE);
    }

    void DrawGUI() override {
        float cx = game->GetWidth() / 2.0f - 150;
        float cy = 200;

        // Управление громкостью
        GuiLabel(Rectangle{ cx, cy - 30, 300, 20 }, "Master Volume");
        float vol = game->audio.GetVolume();
        if (GuiSlider(Rectangle{ cx, cy, 300, 30 }, "0", "1", &vol, 0.0f, 1.0f)) {
            game->audio.SetVolume(vol);
        }
        cy += 80;

        // Полноэкранный режим (для ПК)
        static bool fullscreen = IsWindowFullscreen();
        if (GuiCheckBox(Rectangle{ cx, cy, 30, 30 }, "Fullscreen", &fullscreen)) {
            ToggleFullscreen();
        }
        cy += 80;

        // Кнопка назад
        if (GuiButton(Rectangle{ cx, game->GetHeight() - 100.0f, 300, 50 }, "BACK")) {
            // Возвращаемся в главное меню (нужен forward declaration или include)
            // Для простоты в GameClient сделаем метод ReturnToMenu
            game->ReturnToMenu();
        }
    }
};
// common\CMakeLists.txt
﻿file(GLOB COMMON_SOURCES "*.cpp" "net/*.cpp" "serial/*.cpp" "enet/*.cpp" "time/*.cpp")

add_library(GameCommon SHARED ${COMMON_SOURCES})

target_link_libraries(GameCommon PUBLIC enet::enet_shared raylib)
target_include_directories(GameCommon PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameCommon PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
// common\Common.cpp
﻿#include "external/fix_win32_compatibility.h"
// common\Common.h
﻿#pragma once
#include "external/fix_win32_compatibility.h"
#include <ctime>
#include <string>
#include <sstream>
#include "raylib.h"

/**
 * Precision explicit typedefs
 */
typedef float float32_t;
typedef double float64_t;

/**
 * Fixed width integer types
 */
#include <cstdint>

 /**
  * Define PI
  */
#ifndef M_PI
#define M_PI 3.14159265358979f
#endif

  /**
   * Define EPSILON
   */
#ifndef M_EPSILON
#define M_EPSILON 0.000001f
#endif



#define LOG_INFO(stream_input)  do { std::ostringstream s; s << stream_input; TraceLog(3, "[NET] %s", s.str().c_str()); } while(0)
#define LOG_WARN(stream_input)  do { std::ostringstream s; s << stream_input; TraceLog(4, "[NET WARN] %s", s.str().c_str()); } while(0)
#define LOG_ERROR(stream_input) do { std::ostringstream s; s << stream_input; TraceLog(5, "[NET ERROR] %s", s.str().c_str()); } while(0)
#define LOG_DEBUG(stream_input) do { std::ostringstream s; s << stream_input; TraceLog(2, "[NET DEBUG] %s", s.str().c_str()); } while(0)

// ------------------------------------------

/**
 * Utility lookup for const map types.
 */
template <typename T>
typename T::mapped_type get(T const& map, typename T::key_type const& key)
{
    typename T::const_iterator iter(map.find(key));
    return iter != map.end() ? iter->second : typename T::mapped_type();
}
// common\NetworkPackets.h
﻿#pragma once
#include "raylib.h"
#include <cstdint>
#include <vector>

#include "serial/StreamBuffer.h" 

namespace GamePacket {
    enum Type : uint8_t {
        INPUT = 1,
        INIT,
        SNAPSHOT,
        EVENT
    };
}

enum class EntityType : uint8_t { PLAYER, BULLET, ENEMY };


struct PlayerInputPacket {
    Vector2 movement;
    Vector2 aimTarget;
    bool isShooting;
};

struct EntityState {
    uint32_t id;
    Vector2 position;
    float rotation;
    float health;
    float maxHealth;
    EntityType type;
    float radius;
    Color color;
};


inline StreamBuffer::Shared& operator<<(StreamBuffer::Shared& stream, const Vector2& v) {
    stream->write(v.x);
    stream->write(v.y);
    return stream;
}

inline StreamBuffer::Shared& operator>>(StreamBuffer::Shared& stream, Vector2& v) {
    stream->read(v.x);
    stream->read(v.y);
    return stream;
}

inline StreamBuffer::Shared& operator<<(StreamBuffer::Shared& stream, const Color& c) {
    stream->write(c.r);
    stream->write(c.g);
    stream->write(c.b);
    stream->write(c.a);
    return stream;
}

inline StreamBuffer::Shared& operator>>(StreamBuffer::Shared& stream, Color& c) {
    stream->read(c.r);
    stream->read(c.g);
    stream->read(c.b);
    stream->read(c.a);
    return stream;
}


inline StreamBuffer::Shared& operator<<(StreamBuffer::Shared& stream, const PlayerInputPacket& p) {
    stream->write(p.movement);
    stream->write(p.aimTarget);
    stream->write(p.isShooting);
    return stream;
}

inline StreamBuffer::Shared& operator>>(StreamBuffer::Shared& stream, PlayerInputPacket& p) {
    stream->read(p.movement);
    stream->read(p.aimTarget);
    stream->read(p.isShooting);
    return stream;
}

inline StreamBuffer::Shared& operator<<(StreamBuffer::Shared& stream, const EntityState& e) {
    stream->write(e.id);
    stream->write(e.position);
    stream->write(e.rotation);
    stream->write(e.health);
    stream->write(e.maxHealth);
    stream->write((uint8_t)e.type);
    stream->write(e.radius);
    stream << e.color;
    return stream;
}

inline StreamBuffer::Shared& operator>>(StreamBuffer::Shared& stream, EntityState& e) {
    stream->read(e.id);
    stream->read(e.position);
    stream->read(e.rotation);
    stream->read(e.health);
    stream->read(e.maxHealth);
    uint8_t t; stream->read(t); e.type = (EntityType)t;
    stream->read(e.radius);
    stream >> e.color;
    return stream;
}
// common\enet\ENetClient.cpp
﻿#include "enet/ENetClient.h"

#include "Common.h"
#include "time/Time.h"

const uint8_t SERVER_ID = 0;
const std::time_t TIMEOUT_MS = 5000;
const std::time_t REQUEST_INTERVAL = Time::fromSeconds(1.0 / 60.0);
const uint8_t RELIABLE_CHANNEL = 0;
const uint8_t UNRELIABLE_CHANNEL = 1;
const uint8_t NUM_CHANNELS = 2;

ENetClient::Shared ENetClient::alloc()
{
    return std::make_shared<ENetClient>();
}

ENetClient::ENetClient()
    : host_(nullptr)
    , server_(nullptr)
    , currentMsgId_(0)
{
    // Пытаемся создать хост. Если ENet еще не инициализирован (в main), host_ останется nullptr.
    // Это нормально, мы проверим это в connect() или poll().
    host_ = enet_host_create(nullptr, 1, NUM_CHANNELS, 0, 0);
    if (!host_) {
        LOG_ERROR("Client host creation failed (ENet might not be initialized yet)");
    }
}

ENetClient::~ENetClient()
{
    disconnect();
    if (host_) {
        enet_host_destroy(host_);
        host_ = nullptr;
    }
}

bool ENetClient::connect(const std::string& host, uint32_t port)
{
    if (!host_) {
        host_ = enet_host_create(nullptr, 1, NUM_CHANNELS, 0, 0);
        if (!host_) {
            LOG_ERROR("FATAL: Cannot connect. Failed to create ENet client host.");
            return false;
        }
    }

    if (isConnected()) {
        return true;
    }

    ENetAddress address;
    enet_address_set_host(&address, host.c_str());
    address.port = port;

    server_ = enet_host_connect(host_, &address, NUM_CHANNELS, 0);
    if (server_ == nullptr) {
        LOG_ERROR("No available peers for initiating an ENet connection");
        return false;
    }

    ENetEvent event;
    // Безопасный вызов сервиса
    if (enet_host_service(host_, &event, TIMEOUT_MS) > 0 && event.type == ENET_EVENT_TYPE_CONNECT) {
        LOG_DEBUG("Connection to `" << host << ":" << port << "` succeeded");
        return true;
    }

    LOG_ERROR("Connection to `" << host << ":" << port << "` failed");
    enet_peer_reset(server_);
    server_ = nullptr;
    return false;
}

bool ENetClient::disconnect()
{
    // ЗАЩИТА ОТ КРАША
    if (!host_ || !server_) return false;

    if (!isConnected()) return false;

    LOG_DEBUG("Disconnecting from server...");
    enet_peer_disconnect(server_, 0);

    ENetEvent event;
    auto timestamp = Time::timestamp();
    bool success = false;

    while (true) {
        int32_t res = enet_host_service(host_, &event, 0);
        if (res > 0) {
            if (event.type == ENET_EVENT_TYPE_RECEIVE) {
                enet_packet_destroy(event.packet);
            }
            else if (event.type == ENET_EVENT_TYPE_DISCONNECT) {
                success = true;
                break;
            }
        }
        else if (res < 0) {
            break;
        }

        if (Time::timestamp() - timestamp > Time::fromMilliseconds(TIMEOUT_MS)) break;
    }

    if (!success) {
        enet_peer_reset(server_);
    }
    server_ = nullptr;
    return !success;
}

bool ENetClient::isConnected() const
{
    // ЗАЩИТА ОТ КРАША
    return host_ != nullptr && server_ != nullptr && server_->state == ENET_PEER_STATE_CONNECTED;
}

void ENetClient::on(uint32_t id, RequestHandler handler)
{
    handlers_[id] = handler;
}

void ENetClient::handleRequest(uint32_t requestId, StreamBuffer::Shared stream) const
{
    auto iter = handlers_.find(requestId);
    if (iter != handlers_.end()) {
        auto handler = iter->second;
        auto res = handler(SERVER_ID, stream);
        sendResponse(requestId, res);
    }
}

void ENetClient::sendResponse(uint32_t requestId, StreamBuffer::Shared stream) const
{
    if (!isConnected()) return;
    auto msg = Message::alloc(++currentMsgId_, requestId, MessageType::DATA_RESPONSE, stream);
    sendMessage(DeliveryType::RELIABLE, msg);
}

void ENetClient::sendMessage(DeliveryType type, Message::Shared msg) const
{
    // ЗАЩИТА ОТ КРАША
    if (!host_ || !server_) return;

    uint32_t channel = (type == DeliveryType::RELIABLE) ? RELIABLE_CHANNEL : UNRELIABLE_CHANNEL;
    uint32_t flags = (type == DeliveryType::RELIABLE) ? ENET_PACKET_FLAG_RELIABLE : ENET_PACKET_FLAG_UNSEQUENCED;

    auto data = msg->serialize();
    ENetPacket* p = enet_packet_create(&data[0], data.size(), flags);

    enet_peer_send(server_, channel, p);
    enet_host_flush(host_);
}

void ENetClient::send(DeliveryType type, StreamBuffer::Shared stream) const
{
    if (!isConnected()) return;
    auto msg = Message::alloc(++currentMsgId_, MessageType::DATA, stream);
    sendMessage(type, msg);
}

void ENetClient::sendRequest(uint32_t requestId, StreamBuffer::Shared stream) const
{
    auto msg = Message::alloc(++currentMsgId_, requestId, MessageType::DATA_REQUEST, stream);
    sendMessage(DeliveryType::RELIABLE, msg);
}

Message::Shared ENetClient::request(uint32_t requestId, StreamBuffer::Shared stream)
{
    if (!isConnected()) return nullptr;
    sendRequest(requestId, stream);

    auto timestamp = Time::timestamp();
    while (true) {
        auto msgs = poll();
        for (auto msg : msgs) {
            if (msg->type() == MessageType::DATA_RESPONSE && msg->requestId() == requestId) {
                return msg;
            }
            queue_.push_back(msg);
        }
        if (Time::timestamp() - timestamp > Time::fromMilliseconds(TIMEOUT_MS)) break;
        Time::sleep(REQUEST_INTERVAL);
    }
    return nullptr;
}

std::vector<Message::Shared> ENetClient::poll()
{
    std::vector<Message::Shared> msgs;

    if (!host_) return msgs;

    ENetEvent event;
    while (true) {
        int32_t res = enet_host_service(host_, &event, 0);
        if (res > 0) {
            if (event.type == ENET_EVENT_TYPE_RECEIVE) {
                auto stream = StreamBuffer::alloc(event.packet->data, event.packet->dataLength);
                auto msg = Message::alloc(SERVER_ID);
                msg->deserialize(stream);
                msgs.push_back(msg);

                if (msg->type() == MessageType::DATA_REQUEST) {
                    handleRequest(msg->requestId(), msg->stream());
                }
                enet_packet_destroy(event.packet);

            }
            else if (event.type == ENET_EVENT_TYPE_DISCONNECT) {
                auto msg = Message::alloc(SERVER_ID, MessageType::DISCONNECT);
                msgs.push_back(msg);
                server_ = nullptr;
            }
        }
        else {
            break;
        }
    }
    if (!queue_.empty()) {
        msgs.insert(msgs.end(), queue_.begin(), queue_.end());
        queue_.clear();
    }
    return msgs;
}
// common\enet\ENetClient.h
﻿#pragma once

#include "net/Client.h"
#include "net/DeliveryType.h"
#include "net/Message.h"

#include <enet.h>

#include <iostream>
#include <map>
#include <memory>
#include <vector>

class ENetClient : public Client {

public:
    typedef std::shared_ptr<ENetClient> Shared;
    static Shared alloc();

    ENetClient();
    ~ENetClient();

    bool connect(const std::string&, uint32_t);
    bool disconnect();
    bool isConnected() const;

    void send(DeliveryType, StreamBuffer::Shared) const;
    Message::Shared request(uint32_t, StreamBuffer::Shared);
    std::vector<Message::Shared> poll();

    void on(uint32_t, RequestHandler);

private:
    void sendMessage(DeliveryType type, Message::Shared msg) const;
    void sendRequest(uint32_t responseId, StreamBuffer::Shared stream) const;
    void sendResponse(uint32_t requestId, StreamBuffer::Shared stream) const;
    void handleRequest(uint32_t, StreamBuffer::Shared stream) const;

    // prevent copy-construction
    ENetClient(const ENetClient&);
    // prevent assignment
    ENetClient& operator=(const ENetClient&);

    ENetHost* host_;
    ENetPeer* server_;
    std::vector<Message::Shared> queue_;
    std::map<uint32_t, RequestHandler> handlers_;
    mutable uint32_t currentMsgId_;
};

// common\enet\ENetServer.cpp
﻿#include "enet/ENetServer.h"

#include "Common.h"
#include "time/Time.h"

const uint32_t MAX_CONNECTIONS = 64;
const std::time_t TIMEOUT_MS = 5000;
const uint8_t RELIABLE_CHANNEL = 0;
const uint8_t UNRELIABLE_CHANNEL = 1;
const uint8_t NUM_CHANNELS = 2;

std::string addressToString(const ENetAddress* address)
{
    char ip_address_str[256];
    enet_address_get_host_ip(address, ip_address_str, sizeof(ip_address_str));
    return std::string(ip_address_str) + ":" + std::to_string(address->port);
}

ENetServer::Shared ENetServer::alloc()
{
    return std::make_shared<ENetServer>();
}

ENetServer::ENetServer()
    : host_(nullptr)
    , currentMsgId_(0)
{
}

ENetServer::~ENetServer()
{
    stop();
}

bool ENetServer::start(uint32_t port)
{
    if (host_) return true;

    ENetAddress address;
    address.host = ENET_HOST_ANY;
    address.port = port;
    enet_address_set_host(&address, "localhost");
    host_ = enet_host_create(&address, MAX_CONNECTIONS, NUM_CHANNELS, 0, 0);

    if (host_ == nullptr) {
        LOG_ERROR("Failed to create ENet server host (Port might be busy)");
        return false;
    }
    return true;
}

bool ENetServer::stop()
{
    // ЗАЩИТА ОТ КРАША
    if (!host_) return false;

    if (!isRunning()) return false;

    for (auto iter : clients_) {
        enet_peer_disconnect(iter.second, 0);
    }

    auto timestamp = Time::timestamp();
    bool success = false;
    ENetEvent event;

    while (true) {
        int32_t res = enet_host_service(host_, &event, 0);
        if (res > 0) {
            if (event.type == ENET_EVENT_TYPE_RECEIVE) {
                enet_packet_destroy(event.packet);
            }
            else if (event.type == ENET_EVENT_TYPE_DISCONNECT) {
                clients_.erase(event.peer->incomingPeerID);
            }
            else if (event.type == ENET_EVENT_TYPE_CONNECT) {
                enet_peer_disconnect(event.peer, 0);
            }
        }
        else if (res < 0) {
            break;
        }
        else {
            if (clients_.empty()) {
                success = true;
                break;
            }
        }
        if (Time::timestamp() - timestamp > Time::fromMilliseconds(TIMEOUT_MS)) break;
    }

    for (auto iter : clients_) {
        enet_peer_reset(iter.second);
    }
    clients_.clear();

    enet_host_destroy(host_);
    host_ = nullptr;
    return !success;
}

bool ENetServer::isRunning() const
{
    return host_ != nullptr;
}

uint32_t ENetServer::numClients() const
{
    if (!host_) return 0;
    return host_->connectedPeers;
}

void ENetServer::on(uint32_t id, RequestHandler handler)
{
    handlers_[id] = handler;
}

void ENetServer::handleRequest(uint32_t id, uint32_t requestId, StreamBuffer::Shared stream) const
{
    auto iter = handlers_.find(requestId);
    if (iter != handlers_.end()) {
        auto handler = iter->second;
        auto res = handler(id, stream);
        sendResponse(id, requestId, res);
    }
}

ENetPeer* ENetServer::getClient(uint32_t id) const
{
    auto iter = clients_.find(id);
    if (iter == clients_.end()) return nullptr;
    return iter->second;
}

void ENetServer::sendResponse(uint32_t id, uint32_t requestId, StreamBuffer::Shared stream) const
{
    if (!host_) return;
    auto client = getClient(id);
    if (!client) return;

    auto msg = Message::alloc(++currentMsgId_, requestId, MessageType::DATA_RESPONSE, stream);
    sendMessage(id, DeliveryType::RELIABLE, msg);
}

void ENetServer::sendMessage(uint32_t id, DeliveryType type, Message::Shared msg) const
{
    if (!host_) return;
    auto client = getClient(id);
    if (!client) return;

    uint32_t channel = (type == DeliveryType::RELIABLE) ? RELIABLE_CHANNEL : UNRELIABLE_CHANNEL;
    uint32_t flags = (type == DeliveryType::RELIABLE) ? ENET_PACKET_FLAG_RELIABLE : ENET_PACKET_FLAG_UNSEQUENCED;

    auto data = msg->serialize();
    ENetPacket* p = enet_packet_create(&data[0], data.size(), flags);

    enet_peer_send(client, channel, p);
    enet_host_flush(host_);
}

void ENetServer::send(uint32_t id, DeliveryType type, StreamBuffer::Shared stream) const
{
    auto msg = Message::alloc(++currentMsgId_, MessageType::DATA, stream);
    sendMessage(id, type, msg);
}

void ENetServer::broadcastMessage(DeliveryType type, Message::Shared msg) const
{
    if (!host_) return;
    if (numClients() == 0) return;

    uint32_t channel = (type == DeliveryType::RELIABLE) ? RELIABLE_CHANNEL : UNRELIABLE_CHANNEL;
    uint32_t flags = (type == DeliveryType::RELIABLE) ? ENET_PACKET_FLAG_RELIABLE : ENET_PACKET_FLAG_UNSEQUENCED;

    auto data = msg->serialize();
    ENetPacket* p = enet_packet_create(&data[0], data.size(), flags);

    enet_host_broadcast(host_, channel, p);
    enet_host_flush(host_);
}

void ENetServer::broadcast(DeliveryType type, StreamBuffer::Shared stream) const
{
    auto msg = Message::alloc(++currentMsgId_, MessageType::DATA, stream);
    broadcastMessage(type, msg);
}

std::vector<Message::Shared> ENetServer::poll()
{
    std::vector<Message::Shared> msgs;
    if (!host_) return msgs;

    ENetEvent event;
    while (true) {
        int32_t res = enet_host_service(host_, &event, 0);
        if (res > 0) {
            if (event.type == ENET_EVENT_TYPE_RECEIVE) {
                auto stream = StreamBuffer::alloc(event.packet->data, event.packet->dataLength);
                auto msg = Message::alloc(event.peer->incomingPeerID);
                msg->deserialize(stream);
                msgs.push_back(msg);

                if (msg->type() == MessageType::DATA_REQUEST) {
                    handleRequest(event.peer->incomingPeerID, msg->requestId(), msg->stream());
                }
                enet_packet_destroy(event.packet);

            }
            else if (event.type == ENET_EVENT_TYPE_CONNECT) {
                auto msg = Message::alloc(event.peer->incomingPeerID, MessageType::CONNECT);
                msgs.push_back(msg);
                clients_[event.peer->incomingPeerID] = event.peer;

            }
            else if (event.type == ENET_EVENT_TYPE_DISCONNECT) {
                auto msg = Message::alloc(event.peer->incomingPeerID, MessageType::DISCONNECT);
                msgs.push_back(msg);
                clients_.erase(event.peer->incomingPeerID);
            }
        }
        else {
            break;
        }
    }
    return msgs;
}
// common\enet\ENetServer.h
﻿#pragma once
#include "fix_win32_compatibility.h"
#include "net/DeliveryType.h"
#include "net/Message.h"
#include "net/Server.h"

#include <enet.h>

#include <iostream>
#include <map>
#include <memory>
#include <vector>

class ENetServer : public Server {

public:
    typedef std::shared_ptr<ENetServer> Shared;
    static Shared alloc();

    ENetServer();
    ~ENetServer();

    bool start(uint32_t);
    bool stop();
    bool isRunning() const;

    uint32_t numClients() const;

    void send(uint32_t, DeliveryType, StreamBuffer::Shared) const;
    void broadcast(DeliveryType, StreamBuffer::Shared) const;
    std::vector<Message::Shared> poll();

    void on(uint32_t, RequestHandler);

private:
    ENetPeer* getClient(uint32_t) const;
    void sendMessage(uint32_t id, DeliveryType type, Message::Shared msg) const;
    void broadcastMessage(DeliveryType type, Message::Shared msg) const;
    void sendResponse(uint32_t, uint32_t requestId, StreamBuffer::Shared stream) const;
    void handleRequest(uint32_t, uint32_t, StreamBuffer::Shared stream) const;

    // prevent copy-construction
    ENetServer(const ENetServer&);
    // prevent assignment
    ENetServer& operator=(const ENetServer&);

    ENetHost* host_;
    // NOTE: ENet allocates all peers at once and doesn't shuffle them,
    // which leads to non-contiguous connected peers. This map
    // will make it easier to manage them by id
    std::map<uint32_t, ENetPeer*> clients_;
    std::vector<Message::Shared> queue_;
    std::map<uint32_t, RequestHandler> handlers_;
    mutable uint32_t currentMsgId_;
};

std::string addressToString(const ENetAddress* address);

// common\net\Client.cpp
#include "net/Client.h"

Client::Client()
{
}

Client::~Client()
{
}

// common\net\Client.h
﻿#pragma once

#include "Common.h"
#include "net/DeliveryType.h"
#include "net/Message.h"
#include "serial/StreamBuffer.h"

#include <memory>
#include <vector>

class Client {

public:
    typedef std::shared_ptr<Client> Shared;

    Client();
    virtual ~Client();

    virtual bool connect(const std::string&, uint32_t) = 0;
    virtual bool disconnect() = 0;
    virtual bool isConnected() const = 0;

    virtual void send(DeliveryType, StreamBuffer::Shared) const = 0;
    virtual Message::Shared request(uint32_t, StreamBuffer::Shared) = 0;
    virtual std::vector<Message::Shared> poll() = 0;

    virtual void on(uint32_t, RequestHandler) = 0;

private:
    // prevent copy-construction
    Client(const Client&);
    // prevent assignment
    Client& operator=(const Client&);
};

// common\net\DeliveryType.h
#pragma once

enum class DeliveryType {
    RELIABLE,
    UNRELIABLE
};

// common\net\Message.cpp
﻿#include "net/Message.h"

Message::Shared Message::alloc(uint32_t id, uint8_t type, StreamBuffer::Shared stream)
{
    return std::make_shared<Message>(id, type, stream);
}

Message::Shared Message::alloc(uint32_t id, uint32_t requestId, uint8_t type, StreamBuffer::Shared stream)
{
    return std::make_shared<Message>(id, requestId, type, stream);
}

Message::Shared Message::alloc(uint32_t peerId, uint8_t type)
{
    return std::make_shared<Message>(peerId, type);
}

Message::Shared Message::alloc(uint32_t peerId)
{
    return std::make_shared<Message>(peerId);
}

Message::Message(uint32_t id, uint8_t type, StreamBuffer::Shared stream)
    : id_(id)
    , peerId_(0)
    , requestId_(0)
    , type_(type)
    , stream_(stream)
{
}

Message::Message(uint32_t id, uint32_t requestId, uint8_t type, StreamBuffer::Shared stream)
    : id_(id)
    , peerId_(0)
    , requestId_(requestId)
    , type_(type)
    , stream_(stream)
{
}

Message::Message(uint32_t peerId, uint8_t type)
    : id_(0)
    , peerId_(peerId)
    , requestId_(0)
    , type_(type)
{
}

Message::Message(uint32_t peerId)
    : id_(0)
    , peerId_(peerId)
    , requestId_(0)
    , type_(0)
{
}

uint32_t Message::id() const
{
    return id_;
}

uint32_t Message::requestId() const
{
    return requestId_;
}

uint32_t Message::peerId() const
{
    return peerId_;
}

uint8_t Message::type() const
{
    return type_;
}

StreamBuffer::Shared Message::stream() const
{
    return stream_;
}

std::vector<uint8_t> Message::serialize() const
{
    auto header = StreamBuffer::alloc();
    header << id_;
    header << requestId_;
    header << type_;
    return merge(header, stream_)->buffer();
}

void Message::deserialize(StreamBuffer::Shared stream)
{
    stream >> id_;
    stream >> requestId_;
    stream >> type_;
    stream_ = stream;
}

// common\net\Message.h
﻿#pragma once

#include "serial/StreamBuffer.h"

#include <memory>
#include <string>
#include <vector>
#include <functional>

typedef std::function<StreamBuffer::Shared(uint32_t, StreamBuffer::Shared)> RequestHandler;

namespace MessageType {
enum Types {
    CONNECT,
    DISCONNECT,
    DATA,
    DATA_REQUEST,
    DATA_RESPONSE
};
}

class Message {

public:
    typedef std::shared_ptr<Message> Shared;
    static Shared alloc(uint32_t id, uint8_t, StreamBuffer::Shared); // data
    static Shared alloc(uint32_t id, uint32_t requestId, uint8_t, StreamBuffer::Shared); // request / response
    static Shared alloc(uint32_t peerId, uint8_t); // connect / disconnect
    static Shared alloc(uint32_t peerId); // deserialize from

    Message(uint32_t id, uint8_t, StreamBuffer::Shared); // data
    Message(uint32_t id, uint32_t requestId, uint8_t, StreamBuffer::Shared); // request / response
    Message(uint32_t peerId, uint8_t); // connect / disconnect
    Message(uint32_t peerId); // deserialize from

    uint32_t peerId() const;
    uint32_t id() const;
    uint32_t requestId() const;
    uint8_t type() const;
    StreamBuffer::Shared stream() const;

    std::vector<uint8_t> serialize() const;
    void deserialize(StreamBuffer::Shared);

private:
    // prevent copy-construction
    Message(const Message&);
    // prevent assignment
    Message& operator=(const Message&);

    uint32_t id_;
    uint32_t peerId_;
    uint32_t requestId_;
    uint8_t type_;
    StreamBuffer::Shared stream_;
};

// common\net\Server.cpp
#include "net/Server.h"

Server::Server()
{
}

Server::~Server()
{
}

// common\net\Server.h
﻿#pragma once

#include "../Common.h"
#include "net/DeliveryType.h"
#include "net/Message.h"
#include "serial/StreamBuffer.h"

#include <memory>
#include <vector>

class Server {

public:
    typedef std::shared_ptr<Server> Shared;

    Server();
    virtual ~Server();

    virtual bool start(uint32_t) = 0;
    virtual bool stop() = 0;
    virtual bool isRunning() const = 0;

    virtual uint32_t numClients() const = 0;

    virtual void send(uint32_t, DeliveryType, StreamBuffer::Shared) const = 0;
    virtual void broadcast(DeliveryType, StreamBuffer::Shared) const = 0;
    virtual std::vector<Message::Shared> poll() = 0;

    virtual void on(uint32_t, RequestHandler) = 0;

private:
    // prevent copy-construction
    Server(const Server&);
    // prevent assignment
    Server& operator=(const Server&);
};

// common\serial\Serialization.cpp
﻿#include "serial/Serialization.h"

#include <cstring>

uint64_t pack754(float64_t f, uint32_t bits, uint32_t expbits)
{
    float64_t fnorm;
    int32_t shift;
    int64_t sign, expo, significand;
    uint32_t significandbits = bits - expbits - 1; // -1 for sign bit
    if (f == 0.0) {
        // get this special case out of the way
        return 0;
    }
    // check sign and begin normalization
    if (f < 0) {
        sign = 1;
        fnorm = -f;
    } else {
        sign = 0;
        fnorm = f;
    }
    // get the normalized form of f and track the exponent
    shift = 0;
    while (fnorm >= 2.0) {
        fnorm /= 2.0;
        shift++;
    }
    while (fnorm < 1.0) {
        fnorm *= 2.0;
        shift--;
    }
    fnorm = fnorm - 1.0;
    // calculate the binary form (non-float) of the significand data
    significand = fnorm * ((1LL << significandbits) + 0.5f);
    // get the biased exponent
    expo = shift + ((1 << (expbits - 1)) - 1); // shift + bias
    // return the final answer
    return (sign << (bits - 1)) | (expo << (bits - expbits - 1)) | significand;
}

float64_t unpack754(uint64_t i, uint32_t bits, uint32_t expbits)
{
    float64_t result;
    int64_t shift;
    uint32_t bias;
    uint32_t significandbits = bits - expbits - 1; // -1 for sign bit
    if (i == 0) {
        // get this special case out of the way
        return 0.0;
    }
    // pull the significand
    result = (i & ((1LL << significandbits) - 1)); // mask
    result /= (1LL << significandbits); // convert back to float
    result += 1.0f; // add the one back on
    // deal with the exponent
    bias = (1 << (expbits - 1)) - 1;
    shift = ((i >> significandbits) & ((1LL << expbits) - 1)) - bias;
    while (shift > 0) {
        result *= 2.0;
        shift--;
    }
    while (shift < 0) {
        result /= 2.0;
        shift++;
    }
    // sign it
    result *= (i >> (bits - 1)) & 1 ? -1.0 : 1.0;
    return result;
}

// common\serial\Serialization.h
﻿#pragma once

#include "Common.h"

/**
 * Bit packing macros
 * Brian "Beej Jorgensen" Hall
 * http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#serialization
 */
#define pack754_32(f) (static_cast<uint32_t>(pack754((f), 32, 8)))
#define pack754_64(f) (pack754((f), 64, 11))
#define unpack754_32(i) (static_cast<float32_t>(unpack754((i), 32, 8)))
#define unpack754_64(i) (unpack754((i), 64, 11))

uint64_t pack754(float64_t f, uint32_t bits, uint32_t expbits);
float64_t unpack754(uint64_t i, uint32_t bits, uint32_t expbits);

// common\serial\StreamBuffer.cpp
﻿#include "StreamBuffer.h"
#include "Serialization.h"

#include <fstream>
#include <cstring>

StreamBuffer::Shared StreamBuffer::alloc(size_t numBytes)
{
    return std::make_shared<StreamBuffer>(numBytes);
}

StreamBuffer::Shared StreamBuffer::alloc(const uint8_t* data, size_t numBytes)
{
    return std::make_shared<StreamBuffer>(data, numBytes);
}

StreamBuffer::StreamBuffer(size_t numBytes)
    : gpos_(0)
    , ppos_(0)
{
    buffer_.reserve(numBytes);
}

StreamBuffer::StreamBuffer(const uint8_t* data, size_t numBytes)
    : gpos_(0)
    , ppos_(0)
{
    buffer_.reserve(numBytes);
    buffer_.assign(data, data + numBytes);
}

const std::vector<uint8_t>& StreamBuffer::buffer() const
{
    return buffer_;
}

void StreamBuffer::seekg(size_t pos)
{
    gpos_ = pos;
}

void StreamBuffer::seekp(size_t pos)
{
    ppos_ = pos;
}

size_t StreamBuffer::tellg() const
{
    return gpos_;
}

size_t StreamBuffer::tellp() const
{
    return ppos_;
}

size_t StreamBuffer::size() const
{
    return buffer_.size();
}

bool StreamBuffer::eof() const
{
    return gpos_ >= buffer_.size();
}

// --- WRITE IMPLEMENTATIONS ---

void StreamBuffer::write(bool data)
{
    buffer_.push_back(data ? 1 : 0);
    ppos_++;
}

void StreamBuffer::write(uint8_t data)
{
    buffer_.push_back(data);
    ppos_++;
}

void StreamBuffer::write(uint16_t data)
{
    uint8_t buff[2];
    buff[0] = (uint8_t)(data >> 8);
    buff[1] = (uint8_t)(data);
    buffer_.insert(buffer_.end(), buff, buff + 2);
    ppos_ += 2;
}

void StreamBuffer::write(uint32_t data)
{
    uint8_t buff[4];
    buff[0] = (uint8_t)(data >> 24);
    buff[1] = (uint8_t)(data >> 16);
    buff[2] = (uint8_t)(data >> 8);
    buff[3] = (uint8_t)(data);
    buffer_.insert(buffer_.end(), buff, buff + 4);
    ppos_ += 4;
}

void StreamBuffer::write(uint64_t data)
{
    uint8_t buff[8];
    buff[0] = (uint8_t)(data >> 56);
    buff[1] = (uint8_t)(data >> 48);
    buff[2] = (uint8_t)(data >> 40);
    buff[3] = (uint8_t)(data >> 32);
    buff[4] = (uint8_t)(data >> 24);
    buff[5] = (uint8_t)(data >> 16);
    buff[6] = (uint8_t)(data >> 8);
    buff[7] = (uint8_t)(data);
    buffer_.insert(buffer_.end(), buff, buff + 8);
    ppos_ += 8;
}

void StreamBuffer::write(float32_t data)
{
    write(pack754_32(data));
}

void StreamBuffer::write(float64_t data)
{
    write(pack754_64(data));
}

void StreamBuffer::write(const std::string& data)
{
    auto len = data.size();
    write(uint32_t(len));
    const char* bytes = data.c_str();
    for (uint32_t i = 0; i < len; i++) {
        write(uint8_t(bytes[i]));
    }
}

void StreamBuffer::write(std::time_t data)
{
    write(uint64_t(data));
}

// --- RAYLIB TYPES WRITE ---

void StreamBuffer::write(const Vector2& data)
{
    write((float32_t)data.x);
    write((float32_t)data.y);
}

void StreamBuffer::write(const Vector3& data)
{
    write((float32_t)data.x);
    write((float32_t)data.y);
    write((float32_t)data.z);
}

void StreamBuffer::write(const Quaternion& data)
{
    write((float32_t)data.x);
    write((float32_t)data.y);
    write((float32_t)data.z);
    write((float32_t)data.w);
}

void StreamBuffer::write(const Color& data)
{
    write((uint8_t)data.r);
    write((uint8_t)data.g);
    write((uint8_t)data.b);
    write((uint8_t)data.a);
}

// --- READ IMPLEMENTATIONS ---

void StreamBuffer::read(bool& data)
{
    if (eof()) { data = false; return; }
    data = buffer_[gpos_++] ? true : false;
}

void StreamBuffer::read(uint8_t& data)
{
    if (eof()) { data = 0; return; }
    data = buffer_[gpos_++];
}

void StreamBuffer::read(int8_t& data)
{
    if (eof()) { data = 0; return; }
    data = (int8_t)buffer_[gpos_++];
}

void StreamBuffer::read(uint16_t& data)
{
    if (gpos_ + 2 > buffer_.size()) { data = 0; return; }
    data = ((uint16_t)buffer_[gpos_] << 8) | buffer_[gpos_ + 1];
    gpos_ += 2;
}

void StreamBuffer::read(int16_t& data)
{
    uint16_t ui = 0;
    read(ui);
    if (ui <= 0x7fffu) {
        data = ui;
    }
    else {
        data = -1 - (int16_t)(0xffffu - ui);
    }
}

void StreamBuffer::read(uint32_t& data)
{
    if (gpos_ + 4 > buffer_.size()) { data = 0; return; }
    data = ((uint32_t)buffer_[gpos_] << 24) |
        ((uint32_t)buffer_[gpos_ + 1] << 16) |
        ((uint32_t)buffer_[gpos_ + 2] << 8) |
        buffer_[gpos_ + 3];
    gpos_ += 4;
}

void StreamBuffer::read(int32_t& data)
{
    uint32_t ui = 0;
    read(ui);
    if (ui <= 0x7fffffffu) {
        data = ui;
    }
    else {
        data = -1 - (int32_t)(0xffffffffu - ui);
    }
}

void StreamBuffer::read(uint64_t& data)
{
    if (gpos_ + 8 > buffer_.size()) { data = 0; return; }
    data = ((uint64_t)buffer_[gpos_] << 56) |
        ((uint64_t)buffer_[gpos_ + 1] << 48) |
        ((uint64_t)buffer_[gpos_ + 2] << 40) |
        ((uint64_t)buffer_[gpos_ + 3] << 32) |
        ((uint64_t)buffer_[gpos_ + 4] << 24) |
        ((uint64_t)buffer_[gpos_ + 5] << 16) |
        ((uint64_t)buffer_[gpos_ + 6] << 8) |
        buffer_[gpos_ + 7];
    gpos_ += 8;
}

void StreamBuffer::read(int64_t& data)
{
    uint64_t ui = 0;
    read(ui);
    if (ui <= 0x7fffffffffffffffu) {
        data = ui;
    }
    else {
        data = -1 - (int64_t)(0xffffffffffffffffu - ui);
    }
}

void StreamBuffer::read(float32_t& data)
{
    uint32_t packed = 0;
    read(packed);
    data = unpack754_32(packed);
}

void StreamBuffer::read(float64_t& data)
{
    uint64_t packed = 0;
    read(packed);
    data = unpack754_64(packed);
}

#ifdef __APPLE__
void StreamBuffer::read(std::time_t& data)
{
    uint64_t val = 0;
    read(val);
    data = val;
}
#endif

void StreamBuffer::read(std::string& data)
{
    uint32_t len = 0;
    read(len);
    if (len > 0 && gpos_ + len <= buffer_.size()) {
        data.assign((const char*)&buffer_[gpos_], len);
        gpos_ += len;
    }
    else {
        data = "";
    }
}

// --- RAYLIB TYPES READ ---

void StreamBuffer::read(Vector2& data)
{
    read((float32_t&)data.x);
    read((float32_t&)data.y);
}

void StreamBuffer::read(Vector3& data)
{
    read((float32_t&)data.x);
    read((float32_t&)data.y);
    read((float32_t&)data.z);
}

void StreamBuffer::read(Quaternion& data)
{
    read((float32_t&)data.x);
    read((float32_t&)data.y);
    read((float32_t&)data.z);
    read((float32_t&)data.w);
}

void StreamBuffer::read(Color& data)
{
    read((uint8_t&)data.r);
    read((uint8_t&)data.g);
    read((uint8_t&)data.b);
    read((uint8_t&)data.a);
}

void StreamBuffer::writeToFile(const std::string& path) const
{
    std::ofstream file(path, std::ios::binary);
    if (file.is_open()) {
        file.write((const char*)buffer_.data(), buffer_.size());
        file.close();
    }
}

StreamBuffer::Shared merge(const StreamBuffer::Shared& a, const StreamBuffer::Shared& b)
{
    std::vector<uint8_t> abuff;
    std::vector<uint8_t> bbuff;
    size_t size = 0;
    if (a) {
        abuff = a->buffer();
        size += abuff.size();
    }
    if (b) {
        bbuff = b->buffer();
        size += bbuff.size();
    }
    auto bytes = std::vector<uint8_t>();
    bytes.reserve(size);
    if (a) {
        bytes.insert(bytes.end(), abuff.begin(), abuff.end());
    }
    if (b) {
        bytes.insert(bytes.end(), bbuff.begin(), bbuff.end());
    }
    return StreamBuffer::alloc(bytes.data(), bytes.size());
}
// common\serial\StreamBuffer.h
﻿#pragma once

#include "../Common.h"
#include "raylib.h"

#include <memory>
#include <vector>
#include <string>
#include <ctime>

class StreamBuffer {

public:
    typedef std::shared_ptr<StreamBuffer> Shared;
    static Shared alloc(size_t = 1024);
    static Shared alloc(const uint8_t*, size_t);

    explicit StreamBuffer(size_t = 1024);
    StreamBuffer(const uint8_t*, size_t);

    const std::vector<uint8_t>& buffer() const;
    void seekg(size_t);
    void seekp(size_t);
    size_t tellg() const;
    size_t tellp() const;
    size_t size() const;
    bool eof() const;

    void write(bool);
    void write(uint8_t);
    void write(uint16_t);
    void write(uint32_t);
    void write(uint64_t);
    void write(float32_t);
    void write(float64_t);
    void write(std::time_t);
    void write(const std::string&);

    void write(const Vector2&);
    void write(const Vector3&);
    void write(const Quaternion&);
    void write(const Color&);

    void read(bool&);
    void read(uint8_t&);
    void read(int8_t&);
    void read(uint16_t&);
    void read(int16_t&);
    void read(uint32_t&);
    void read(int32_t&);
    void read(uint64_t&);
    void read(int64_t&);
    void read(float32_t&);
    void read(float64_t&);
    void read(std::string&);
#ifdef __APPLE__
    void read(std::time_t&);
#endif

    void read(Vector2&);
    void read(Vector3&);
    void read(Quaternion&);
    void read(Color&);

    void writeToFile(const std::string&) const;

private:
    StreamBuffer(const StreamBuffer&);

    StreamBuffer& operator=(const StreamBuffer&);

    size_t gpos_;
    size_t ppos_;
    std::vector<uint8_t> buffer_;
};

StreamBuffer::Shared merge(const StreamBuffer::Shared&, const StreamBuffer::Shared&);


template <typename T>
StreamBuffer::Shared& operator<<(StreamBuffer::Shared& stream, const std::vector<T>& data)
{
    stream->write(uint32_t(data.size()));
    for (auto& d : data) {
        stream->write(d);
    }
    return stream;
}

template <typename T>
StreamBuffer::Shared& operator>>(StreamBuffer::Shared& stream, std::vector<T>& data)
{
    uint32_t size = 0;
    stream->read(size);
    data.resize(size);
    for (auto i = uint32_t(0); i < size; i++) {
        stream->read(data[i]);
    }
    return stream;
}

template <typename T>
StreamBuffer::Shared& operator<<(StreamBuffer::Shared& stream, const T& data)
{
    stream->write(data);
    return stream;
}

template <typename T>
StreamBuffer::Shared& operator>>(StreamBuffer::Shared& stream, T& data)
{
    stream->read(data);
    return stream;
}
// common\time\Time.cpp
﻿#include "time/Time.h"

#include <iomanip>
#include <sstream>

std::string to_string_fixed(float64_t val, uint8_t n = 2)
{
    std::ostringstream out;
    out << std::setprecision(n) << std::fixed << val;
    return out.str();
}

namespace Time {

std::time_t timestamp()
{
    return std::chrono::duration_cast<std::chrono::microseconds>(
        std::chrono::system_clock::now().time_since_epoch())
        .count();
}

void sleep(std::time_t duration)
{
    std::this_thread::sleep_for(std::chrono::microseconds(duration));
}

std::time_t fromMinutes(float64_t minutes)
{
    return minutes * 1000000 * 60;
}

std::time_t fromSeconds(float64_t seconds)
{
    return seconds * 1000000;
}

std::time_t fromMilliseconds(float64_t milliseconds)
{
    return milliseconds * 1000;
}

float64_t toMinutes(std::time_t t)
{
    return t / (1000000.0 * 60.0);
}

float64_t toSeconds(std::time_t t)
{
    return t / 1000000.0;
}

float64_t toMilliseconds(std::time_t t)
{
    return t / 1000.0;
}

std::string format(std::time_t microseconds)
{
    auto milliseconds = microseconds / 1000.0;
    if (milliseconds < 1) {
        return to_string_fixed(microseconds) + "μs";
    }
    auto seconds = milliseconds / 1000.0;
    if (seconds < 1) {
        return to_string_fixed(milliseconds) + "ms";
    }
    auto minutes = seconds / 60.0;
    if (minutes < 1) {
        return to_string_fixed(seconds) + "s";
    }
    auto hours = minutes / 60.0;
    if (hours < 1) {
        return to_string_fixed(minutes) + "m";
    }
    return to_string_fixed(hours) + "h";
}
}

// common\time\Time.h
#pragma once

#include "Common.h"

#include <chrono>
#include <ctime>
#include <string>
#include <thread>

namespace Time {

/**
 * Get timestamp in microseconds.
 */
std::time_t timestamp();

/**
 * Sleep thread for N microseconds.
 */
void sleep(std::time_t);

/**
 * Converts the arguments to microseconds.
 */
std::time_t fromMinutes(float64_t);
std::time_t fromSeconds(float64_t);
std::time_t fromMilliseconds(float64_t);

/**
 * Converts the arguments from microseconds to the specified type.
 */
float64_t toMinutes(std::time_t);
float64_t toSeconds(std::time_t);
float64_t toMilliseconds(std::time_t);

/**
 * Format microsecond into a pretty string.
 */
std::string format(std::time_t);
}

// engine\CMakeLists.txt
﻿#Engine module CMakeLists.txt
add_library(GameEngine SHARED
    Utils/ConfigManager.h
    Utils/ConfigManager.cpp
    ECS/GameObject.h
    ECS/Player.h
    ECS/Bullet.h
    Scenes/GameScene.h
    ServerHost.h
 "ServerHost.h"
 ServerHost.cpp
 "Utils/ConfigManager.h")
target_include_directories(GameEngine PUBLIC ${CHIPMUNK2D_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameEngine PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})

target_link_libraries(GameEngine PUBLIC chipmunk_static GameCommon enet::enet_shared raylib nlohmann_json)
target_include_directories(GameEngine PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

if(ANDROID)
    target_link_libraries(GameEngine PRIVATE log)
endif()
// engine\PhysicsUtils.h
﻿#pragma once
#include "raylib_compatibility.h"
#include "chipmunk/chipmunk.h"


// Конвертация Raylib Vector2 -> Chipmunk cpVect
inline cpVect ToCp(Vector2 v) {
    return cpv(v.x, v.y);
}

// Конвертация Chipmunk cpVect -> Raylib Vector2
inline Vector2 ToRay(cpVect v) {
    return Vector2{ (float)v.x, (float)v.y };
}
// engine\raylib_compatibility.h
﻿// raylib_compatibility.h
#pragma once

#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "raylib.h"
// engine\ServerHost.cpp
﻿#define _CRT_SECURE_NO_WARNINGS
#include "ServerHost.h"
#include "../common/NetworkPackets.h"
#include <iostream>
#include <chrono>

ServerHost::ServerHost() : running(false) {
    // Выделяем память под сервер
    netServer = ENetServer::alloc();
}

ServerHost::~ServerHost() {
    Stop();
}

bool ServerHost::Start(int port) {
    if (running) return false;

    // Запуск через обертку
    if (!netServer->start(port)) {
        std::cerr << "SERVER: Failed to start on port " << port << std::endl;
        return false;
    }

    std::cout << "SERVER: Started on port " << port << std::endl;
    running = true;
    serverThread = std::thread(&ServerHost::ServerLoop, this);
    return true;
}

void ServerHost::Stop() {
    running = false;
    if (serverThread.joinable()) {
        serverThread.join();
    }
    // Остановка обертки
    netServer->stop();
}

void ServerHost::ServerLoop() {
    using clock = std::chrono::high_resolution_clock;
    auto lastTime = clock::now();
    double accumulator = 0.0;
    const double dt = 1.0 / 60.0;
    double snapshotTimer = 0.0;

    while (running && netServer->isRunning()) {
        auto currentTime = clock::now();
        std::chrono::duration<double> frameTime = currentTime - lastTime;
        lastTime = currentTime;
        accumulator += frameTime.count();
        snapshotTimer += frameTime.count();

        // 1. Обработка входящих сообщений
        auto msgs = netServer->poll();

        for (auto& msg : msgs) {
            uint32_t peerId = msg->peerId();

            if (msg->type() == MessageType::CONNECT) {
                std::cout << "SERVER: Client " << peerId << " connected.\n";

                // Создаем игрока, используя ID пира
                // (Придется доработать CreatePlayer в GameScene, см. ниже, 
                // или просто передадим этот ID)
                auto player = gameScene.CreatePlayerWithId(peerId);

                // Отправляем INIT пакет
                auto stream = StreamBuffer::alloc();
                stream->write((uint8_t)GamePacket::INIT);
                stream->write(player->id);

                // Шлем надежно конкретному клиенту
                netServer->send(peerId, DeliveryType::RELIABLE, stream);
            }
            else if (msg->type() == MessageType::DISCONNECT) {
                std::cout << "SERVER: Client " << peerId << " disconnected.\n";
                // Удаляем игрока
                gameScene.objects.erase(peerId);
            }
            else if (msg->type() == MessageType::DATA) {
                // Читаем Payload
                auto stream = msg->stream();
                uint8_t packetType = 0;
                stream->read(packetType);

                if (packetType == GamePacket::INPUT) {
                    PlayerInputPacket input;
                    stream >> input; // Десериализация

                    if (gameScene.objects.count(peerId)) {
                        auto p = std::dynamic_pointer_cast<Player>(gameScene.objects[peerId]);
                        if (p) {
                            p->ApplyInput(input.movement);
                            p->aimTarget = input.aimTarget;
                            p->wantsToShoot = input.isShooting;
                        }
                    }
                }
            }
        }

        // 2. Обновление мира
        while (accumulator >= dt) {
            gameScene.Update((float)dt);
            accumulator -= dt;
        }

        // 3. Рассылка состояния (Snapshot) - 20 раз в секунду
        if (snapshotTimer >= 0.05) {
            BroadcastSnapshot();
            snapshotTimer = 0;
        }

        // Разгрузка CPU
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}

void ServerHost::BroadcastSnapshot() {
    if (netServer->numClients() == 0) return;

    auto stream = StreamBuffer::alloc(4096); // Буфер побольше

    stream->write((uint8_t)GamePacket::SNAPSHOT);
    stream->write((uint32_t)gameScene.objects.size());

    for (auto& [id, obj] : gameScene.objects) {
        EntityState state;
        state.id = obj->id;

        if (obj->body) {
            state.position = ToRay(cpBodyGetPosition(obj->body));
            state.rotation = (float)cpBodyGetAngle(obj->body) * RAD2DEG;
        }
        else {
            state.position = { 0,0 };
            state.rotation = 0;
        }

        state.health = obj->health;
        state.maxHealth = obj->maxHealth;
        state.type = obj->type;
        state.radius = (obj->type == EntityType::BULLET) ? 5.0f : 20.0f;
        state.color = obj->color;

        stream << state;
    }

    netServer->broadcast(DeliveryType::UNRELIABLE, stream);
}
// engine\ServerHost.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "enet/ENetServer.h"
#include "Scenes/GameScene.h"
#include <thread>
#include <atomic>

class ServerHost {
    ENetServer::Shared netServer;
    GameScene gameScene;

    std::atomic<bool> running{ false };
    std::thread serverThread;

public:
    ServerHost();
    ~ServerHost();

    bool Start(int port);
    void Stop();

    void ServerLoop();
    void BroadcastSnapshot();
};
// engine\ECS\Bullet.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"

class Bullet : public GameObject {
public:
    uint32_t ownerId;
    float lifeTime = 2.0f;

    Bullet(uint32_t id, Vector2 pos, Vector2 dir, uint32_t owner, cpSpace* space)
        : GameObject(id, EntityType::BULLET), ownerId(owner)
    {
        spaceRef = space;
        color = BLACK;
        float moveSpeed = 600.0f;

        cpFloat radius = 5.0;
        cpFloat mass = 1.0;
        // Пуля - кинематический или легкий динамический объект
        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);

        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(pos));

        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetElasticity(shape, 0.8);
        cpShapeSetCollisionType(shape, COLLISION_BULLET);
        cpShapeSetUserData(shape, (void*)this);

        // Задаем скорость
        Vector2 normDir = Vector2Normalize(dir);
        cpBodySetVelocity(body, cpv(normDir.x * moveSpeed, normDir.y * moveSpeed));
    }

    void Update(float dt) override {
        lifeTime -= dt;
        if (lifeTime <= 0) destroyFlag = true;
    }
};
// engine\ECS\GameObject.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif
#include "raylib.h"
#include "chipmunk/chipmunk.h"
#include "../../common/NetworkPackets.h"

// Определяем типы коллизий для фильтрации (понадобится в будущем)
enum CollisionType {
    COLLISION_PLAYER = 1,
    COLLISION_BULLET = 2,
    COLLISION_WALL = 3
};

class GameObject {
public:
    uint32_t id;
    EntityType type;

    // Ссылки на физические объекты
    cpBody* body = nullptr;
    cpShape* shape = nullptr;
    cpSpace* spaceRef = nullptr; // Ссылка на мир для очистки

    bool destroyFlag = false;
    Color color = RED;
    float rotation = 0.0f;
    float health = 100.0f;
    float maxHealth = 100.0f;

    GameObject(uint32_t _id, EntityType _type) : id(_id), type(_type) {}

    virtual ~GameObject() {
        if (spaceRef) {
            if (shape) {
                cpSpaceRemoveShape(spaceRef, shape);
                cpShapeFree(shape);
            }
            if (body) {
                cpSpaceRemoveBody(spaceRef, body);
                cpBodyFree(body);
            }
        }
    }

    virtual void Update(float dt) = 0;
};
// engine\ECS\Player.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"

class Player : public GameObject {
public:
    float speed = 200.0f; // Сила/Скорость движения
    float shootCooldown = 0.0f;
    const float FIRE_RATE = 0.2f;

    bool wantsToShoot = false;
    Vector2 aimTarget = { 0,0 };
    bool spawnBulletSignal = false;
    Vector2 bulletDir = { 0,0 };

    Player(uint32_t id, Vector2 startPos, cpSpace* space) : GameObject(id, EntityType::PLAYER) {
        spaceRef = space;
        color = BLUE;

        // 1. Создаем тело (масса 10, инерция для круга)
        cpFloat radius = 20.0;
        cpFloat mass = 10.0;
        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);

        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(startPos));

        // Отключаем вращение от коллизий (бесконечная инерция)
        cpBodySetMoment(body, INFINITY);

        // 2. Создаем форму (коллизию)
        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetFriction(shape, 0.7);
        cpShapeSetElasticity(shape, 0.1); // Упругость
        cpShapeSetCollisionType(shape, COLLISION_PLAYER);

        // Pointer на самого себя для логики коллизий
        cpShapeSetUserData(shape, (void*)this);
    }

    void Update(float dt) override {
        if (shootCooldown > 0) shootCooldown -= dt;

        // Позиция для стрельбы и камеры
        Vector2 pos = ToRay(cpBodyGetPosition(body));

        if (wantsToShoot && shootCooldown <= 0) {
            shootCooldown = FIRE_RATE;
            spawnBulletSignal = true;
            bulletDir = Vector2Subtract(aimTarget, pos);
        }

        // Вычисляем угол поворота (визуально)
        Vector2 diff = Vector2Subtract(aimTarget, pos);
        rotation = atan2(diff.y, diff.x) * RAD2DEG;

        // Передаем угол в физику (хоть она и не вращается от ударов)
        cpBodySetAngle(body, atan2(diff.y, diff.x));

        // Линейное затухание (трение о воздух/землю)
        // В Chipmunk это делается через damping space, но можно и вручную:
        cpVect vel = cpBodyGetVelocity(body);
        cpBodySetVelocity(body, cpvmult(vel, 0.90f)); // Торможение
    }

    void ApplyInput(Vector2 move) {
        if (body) {
            // Прямая установка скорости для четкого управления
            // (или можно использовать forces для "ледяного" управления)
            cpBodySetVelocity(body, cpv(move.x * speed, move.y * speed));
        }
    }
};
// engine\Scenes\GameScene.h
﻿#pragma once
#include <vector>
#include <memory>
#include <map>
#include <algorithm>
#include "ECS/Player.h"
#include "ECS/Bullet.h"
#include "PhysicsUtils.h"

class GameScene {
public:
    cpSpace* space;
    std::map<uint32_t, std::shared_ptr<GameObject>> objects;
    uint32_t nextId = 1000; // Начинаем с 1000, чтобы не пересекаться с PeerID (0-64), хотя это не критично
    float width = 2000;
    float height = 2000;

    GameScene() {
        space = cpSpaceNew();
        cpSpaceSetGravity(space, cpv(0, 0));
        CreateMapBoundaries();
    }

    ~GameScene() {
        objects.clear();
        cpSpaceFree(space);
    }

    void CreateMapBoundaries() {
        cpBody* staticBody = cpSpaceGetStaticBody(space);
        float w = width;
        float h = height;
        float thick = 20.0f;

        auto addWall = [&](Vector2 a, Vector2 b) {
            cpShape* wall = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, ToCp(a), ToCp(b), thick));
            cpShapeSetElasticity(wall, 0.5f);
            cpShapeSetFriction(wall, 1.0f);
            cpShapeSetCollisionType(wall, COLLISION_WALL);
            };

        addWall({ 0,0 }, { w, 0 });
        addWall({ 0,h }, { w, h });
        addWall({ 0,0 }, { 0, h });
        addWall({ w,0 }, { w, h });
    }

    // Создание игрока с конкретным ID (от ENet)
    std::shared_ptr<Player> CreatePlayerWithId(uint32_t id) {
        Vector2 startPos = { width / 2, height / 2 };
        auto p = std::make_shared<Player>(id, startPos, space);
        objects[id] = p;
        return p;
    }

    // Обычное создание (для ботов)
    std::shared_ptr<Player> CreatePlayer() {
        return CreatePlayerWithId(nextId++);
    }

    void Update(float dt) {
        cpSpaceStep(space, dt);

        std::vector<std::shared_ptr<Bullet>> newBullets;

        for (auto it = objects.begin(); it != objects.end();) {
            auto& obj = it->second;
            obj->Update(dt);

            if (obj->type == EntityType::PLAYER) {
                auto p = std::dynamic_pointer_cast<Player>(obj);
                if (p && p->spawnBulletSignal) {
                    p->spawnBulletSignal = false;
                    Vector2 spawnPos = ToRay(cpBodyGetPosition(p->body));
                    // ID пули генерируем сами
                    auto b = std::make_shared<Bullet>(nextId++, spawnPos, p->bulletDir, p->id, space);
                    newBullets.push_back(b);
                }
            }

            if (obj->destroyFlag) {
                it = objects.erase(it);
            }
            else {
                ++it;
            }
        }

        for (auto& b : newBullets) objects[b->id] = b;

        HandleDamageManual();
    }

    void HandleDamageManual() {
        for (auto& [bid, bObj] : objects) {
            if (bObj->type != EntityType::BULLET) continue;
            auto bullet = std::dynamic_pointer_cast<Bullet>(bObj);
            Vector2 bPos = ToRay(cpBodyGetPosition(bullet->body));

            for (auto& [pid, pObj] : objects) {
                if (pObj->type != EntityType::PLAYER) continue;
                if (pid == bullet->ownerId) continue;

                Vector2 pPos = ToRay(cpBodyGetPosition(pObj->body));
                if (Vector2Distance(bPos, pPos) < 25.0f) {
                    pObj->health -= 10;
                    bullet->destroyFlag = true;

                    if (pObj->health <= 0) {
                        pObj->health = 100;
                        cpVect randPos = cpv(GetRandomValue(100, (int)width - 100), GetRandomValue(100, (int)height - 100));
                        cpBodySetPosition(pObj->body, randPos);
                        cpBodySetVelocity(pObj->body, cpvzero);
                    }
                }
            }
        }
    }
};
// engine\Scenes\Scene.h
﻿#pragma once
#include "external/fix_win32_compatibility.h"
#include <vector>
#include <memory>
#include "net/Message.h" // Подключаем Message из примера

class GameClient;

class Scene {
protected:
    GameClient* game;

public:
    Scene(GameClient* _game) : game(_game) {}
    virtual ~Scene() = default;

    virtual void Enter() = 0;
    virtual void Update(float dt) = 0;
    virtual void Draw() = 0;
    virtual void DrawGUI() = 0;
    virtual void Exit() = 0;

    virtual void OnMessage(Message::Shared msg) {};
};
// engine\Utils\ConfigManager.cpp
﻿#include "ConfigManager.h"

GameConfig ConfigManager::config;
std::string ConfigManager::configPath;
Font ConfigManager::mainFont = { 0 };
std::map<std::string, std::string> ConfigManager::localizedStrings;

void ConfigManager::Initialize(const std::string& savePath) {
    if (!std::filesystem::exists(savePath)) {
        try { std::filesystem::create_directories(savePath); }
        catch (const std::exception& e) { std::cerr << e.what() << std::endl; }
    }
    configPath = savePath + "config.json";
    Load();
    LoadFonts();
    LoadLanguage(config.client.language);
}

void ConfigManager::CreateDefaultConfig() {
    config.client.playerName = "Player";
    config.client.lastIp = "127.0.0.1";
    config.server.port = 7777;
    config.client.favoriteServers.push_back({ "Localhost", "127.0.0.1", 7777 });
    Save();
}

void ConfigManager::Save() {
    json j;
    json jFav = json::array();
    for (const auto& s : config.client.favoriteServers) {
        jFav.push_back({ {"name", s.name}, {"ip", s.ip}, {"port", s.port} });
    }

    j["client"] = {
        {"playerName", config.client.playerName},
        {"lastIp", config.client.lastIp},
        {"lastPort", config.client.lastPort},
        {"language", config.client.language},
        {"fullscreen", config.client.fullscreen},
        {"targetFPS", config.client.targetFPS},
        {"favorites", jFav}
    };
    j["server"] = {
        {"port", config.server.port}
    };

    std::ofstream file(configPath);
    if (file.is_open()) file << j.dump(4);
}

void ConfigManager::Load() {
    if (!std::filesystem::exists(configPath)) { CreateDefaultConfig(); return; }
    std::ifstream file(configPath);
    if (file.is_open()) {
        try {
            json j = json::parse(file);
            if (j.contains("client")) {
                auto& c = j["client"];
                config.client.playerName = c.value("playerName", "Player");
                config.client.lastIp = c.value("lastIp", "127.0.0.1");
                config.client.lastPort = c.value("lastPort", 7777);
                config.client.targetFPS = c.value("targetFPS", 60);

                if (c.contains("favorites")) {
                    config.client.favoriteServers.clear();
                    for (auto& elem : c["favorites"]) {
                        SavedServer s;
                        s.name = elem.value("name", "Server");
                        s.ip = elem.value("ip", "127.0.0.1");
                        s.port = elem.value("port", 7777);
                        config.client.favoriteServers.push_back(s);
                    }
                }
            }
            if (j.contains("server")) {
                config.server.port = j["server"].value("port", 7777);
            }
        }
        catch (...) { CreateDefaultConfig(); }
    }
}

void ConfigManager::LoadFonts() {
    int codepoints[512] = { 0 };
    for (int i = 0; i < 95; i++) codepoints[i] = 32 + i;
    for (int i = 0; i < 255; i++) codepoints[96 + i] = 0x400 + i;
    const char* fontPath = "assets/fonts/Roboto-Regular.ttf";
    if (FileExists(fontPath)) {
#ifdef ANDROID
        mainFont = LoadFontEx(fontPath, 60, codepoints, 512);
#else
        mainFont = LoadFontEx(fontPath, 32, codepoints, 512);
#endif 
    }
    else { mainFont = GetFontDefault(); }
}
void ConfigManager::UnloadResources() { if (mainFont.texture.id != 0) UnloadFont(mainFont); }
void ConfigManager::LoadLanguage(const std::string& langCode) {
    localizedStrings.clear();
    std::string path = "assets/lang/lang_" + langCode + ".json";
    char* text = LoadFileText(path.c_str());
    if (text) {
        try {
            json j = json::parse(text);
            for (auto& element : j.items()) localizedStrings[element.key()] = element.value().get<std::string>();
        }
        catch (...) {}
        UnloadFileText(text);
    }
}
const char* ConfigManager::Text(const std::string& key) {
    if (localizedStrings.count(key)) return localizedStrings[key].c_str();
    return key.c_str();
}
ClientConfig& ConfigManager::GetClient() { return config.client; }
ServerConfig& ConfigManager::GetServer() { return config.server; }
Font ConfigManager::GetFont() { return mainFont; }
void ConfigManager::SetFont(Font font) { mainFont = font; }
// engine\Utils\ConfigManager.h
﻿#pragma once
#include <string>
#include <fstream>
#include <filesystem>
#include <iostream>
#include <map>
#include <vector>
#include "raylib.h"
#include "nlohmann/json.hpp"

using json = nlohmann::json;

struct SavedServer {
    std::string name;
    std::string ip;
    int port;
};

struct ClientConfig {
    std::string playerName = "Player";
    std::string lastIp = "127.0.0.1";
    int lastPort = 7777;
    std::string language = "ru";

    float masterVolume = 1.0f;
    float musicVolume = 0.7f;
    bool fullscreen = false;
    int targetFPS = 60;

    std::vector<SavedServer> favoriteServers;
};

struct ServerConfig {
    int port = 7777;
    int maxPlayers = 8;
    int tickRate = 60;
};

struct GameConfig {
    ClientConfig client;
    ServerConfig server;
};

class ConfigManager {
private:
    static GameConfig config;
    static std::string configPath;
    static Font mainFont;
    static std::map<std::string, std::string> localizedStrings;

    static void CreateDefaultConfig();

public:
    static void Initialize(const std::string& savePath);
    static void Save();
    static void Load();
    static void LoadLanguage(const std::string& langCode);
    static const char* Text(const std::string& key);

    static ClientConfig& GetClient();
    static ServerConfig& GetServer();

    static void LoadFonts();
    static Font GetFont();
    static void SetFont(Font font);
    static void UnloadResources();
};
// server\CMakeLists.txt
﻿#server module CMakeLists.txt
add_executable(GameServer
    main_server.cpp
 "MasterServerLogic.h")
target_include_directories(GameServer PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_link_libraries(GameServer PRIVATE GameEngine GameCommon enet::enet_shared)

// server\main_server.cpp
﻿#include "../engine/ServerHost.h"
#include <iostream>
#include <string>

int main() {
    if (enet_initialize() != 0) {
        std::cerr << "An error occurred while initializing ENet.\n";
        return 1;
    }
//    std::string configPath = "./";
//
//#if defined(ANDROID) || defined(PLATFORM_ANDROID)
//
//    configPath = GetApplicationDirectory();
//#endif
//
//    ConfigManager::Initialize(configPath);
    InitWindow(100, 100, "ServerHeadless");
    SetWindowState(FLAG_WINDOW_HIDDEN);

    ServerHost server;
    if (server.Start(7777)) {
        std::cout << "Dedicated Server started on port 7777. Type 'quit' to stop.\n";

        std::string cmd;
        while (std::cin >> cmd) {
            if (cmd == "quit") break;
        }

        server.Stop();
    }

    CloseWindow();
    enet_deinitialize();
    return 0;
}
// server\MasterServerLogic.h
﻿#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <enet.h>
#include <map>
#include <string>
#include <vector>
#include <iostream>
#include <cstring>
#include "../common/NetworkPackets.h"

struct ActiveLobby {
    ENetAddress address;
    uint16_t gamePort;
    std::string name;
    std::string map;
    int players;
    int maxPlayers;
    double lastHeartbeatTime;
};

class MasterServer {
    ENetHost* host = nullptr;
    std::map<std::string, ActiveLobby> lobbies;

public:
    bool Start(int port) {
        ENetAddress address;
        address.host = ENET_HOST_ANY;
        address.port = port;
        host = enet_host_create(&address, 32, 2, 0, 0);
        return host != nullptr;
    }

    void Update() {
        if (!host) return;

        ENetEvent event;
        while (enet_host_service(host, &event, 0) > 0) {
            switch (event.type) {
            case ENET_EVENT_TYPE_RECEIVE:
                OnPacket(event.peer, event.packet);
                enet_packet_destroy(event.packet);
                break;
            case ENET_EVENT_TYPE_DISCONNECT:
                break;
            }
        }

        double now = GetTime();
        for (auto it = lobbies.begin(); it != lobbies.end();) {
            if (now - it->second.lastHeartbeatTime > 15.0) {
                std::cout << "Server timed out: " << it->second.name << "\n";
                it = lobbies.erase(it);
            }
            else {
                ++it;
            }
        }
    }

    void OnPacket(ENetPeer* peer, ENetPacket* packet) {
        if (packet->dataLength < sizeof(PacketHeader)) return;
        PacketHeader* header = (PacketHeader*)packet->data;

        char ipStr[64];
        enet_address_get_host_ip(&peer->address, ipStr, 64);
        std::string key = std::string(ipStr) + ":" + std::to_string(peer->address.port);

        if (header->type == PacketType::master_REGISTER) {
            auto* pkt = (MasterRegisterPacket*)packet->data;
            ActiveLobby lobby;
            lobby.address = peer->address;
            lobby.gamePort = pkt->gamePort;
            lobby.name = pkt->serverName;
            lobby.map = pkt->mapName;
            lobby.maxPlayers = pkt->maxPlayers;
            lobby.players = 0;
            lobby.lastHeartbeatTime = GetTime();

            lobbies[key] = lobby;
            std::cout << "Registered server: " << lobby.name << " at " << ipStr << "\n";
        }
        else if (header->type == PacketType::master_HEARTBEAT) {
            auto* pkt = (MasterHeartbeatPacket*)packet->data;
            if (lobbies.count(key)) {
                lobbies[key].lastHeartbeatTime = GetTime();
                lobbies[key].players = pkt->currentPlayers;
            }
        }
        else if (header->type == PacketType::master_LIST_REQ) {
            SendList(peer);
        }
    }

    void SendList(ENetPeer* peer) {
        size_t dataSize = sizeof(MasterListResponsePacket) + (lobbies.size() * sizeof(LobbyInfo));
        std::vector<uint8_t> buffer(dataSize);

        MasterListResponsePacket* header = (MasterListResponsePacket*)buffer.data();
        header->type = PacketType::master_LIST_RES;
        header->count = (uint16_t)lobbies.size();

        LobbyInfo* infos = (LobbyInfo*)(buffer.data() + sizeof(MasterListResponsePacket));
        int i = 0;
        for (const auto& pair : lobbies) {
            const auto& lobby = pair.second;
            infos[i].id = i;
            infos[i].players = lobby.players;
            infos[i].maxPlayers = lobby.maxPlayers;
            infos[i].port = lobby.gamePort;

            char ipBuf[64];
            enet_address_get_host_ip(&lobby.address, ipBuf, 64);
            strncpy(infos[i].ip, ipBuf, 16);

            strncpy(infos[i].name, lobby.name.c_str(), 31);
            strncpy(infos[i].mapName, lobby.map.c_str(), 31);
            i++;
        }

        ENetPacket* packet = enet_packet_create(buffer.data(), buffer.size(), ENET_PACKET_FLAG_RELIABLE);
        enet_peer_send(peer, 0, packet);
    }

    void Stop() {
        if (host) enet_host_destroy(host);
    }
};
// tests\CMakeLists.txt
﻿
    add_executable(test_net
        test_net.cpp
    )
        target_include_directories(test_net PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})

    target_link_libraries(test_net PRIVATE enet::enet_shared GameCommon)
// tests\test_net.cpp
﻿#define _CRT_SECURE_NO_WARNINGS
// Если fix_win32_compatibility.h не нужен для консольного приложения, можно закомментировать
#include "external/fix_win32_compatibility.h"

#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include "enet/ENetServer.h"
#include "enet/ENetClient.h"

// Глобальные переменные для теста
ENetServer::Shared server;
ENetClient::Shared client;
std::atomic<bool> serverRunning{ true };

void ServerThreadFunc(int port) {
    if (!server->start(port)) {
        std::cerr << "SERVER: Failed to start on port " << port << "!" << std::endl;
        return;
    }
    std::cout << "SERVER: Listening on port " << port << std::endl;

    while (serverRunning) {
        auto msgs = server->poll();

        for (auto& msg : msgs) {
            if (msg->type() == MessageType::CONNECT) {
                std::cout << "SERVER: Client connected! ID: " << msg->peerId() << std::endl;
            }
            else if (msg->type() == MessageType::DATA) {
                std::string s;
                msg->stream()->read(s);
                std::cout << "SERVER: Received data: " << s << std::endl;
            }
            else if (msg->type() == MessageType::DISCONNECT) {
                std::cout << "SERVER: Client disconnected." << std::endl;
            }
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }

    server->stop();
    std::cout << "SERVER: Stopped." << std::endl;
}

int main() {
    if (enet_initialize() != 0) {
        std::cerr << "FATAL: Failed to initialize ENet!" << std::endl;
        return -1;
    }
    atexit(enet_deinitialize);

    std::cout << "--- STARTING NETWORK TEST ---" << std::endl;

    server = ENetServer::alloc();
    client = ENetClient::alloc();

    int port = 7780;

    std::thread sThread(ServerThreadFunc, port);

    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    system("pause");
    std::cout << "CLIENT: Connecting to 127.0.0.1:" << port << "..." << std::endl;

    if (client->connect("::1", port)) {
        std::cout << "CLIENT: Connected successfully!" << std::endl;

        auto stream = StreamBuffer::alloc();
        stream->write(std::string("Hello Server!"));
        client->send(DeliveryType::RELIABLE, stream);
        std::cout << "CLIENT: Data sent." << std::endl;

        std::cout << "CLIENT: Polling loop started..." << std::endl;
        for (int i = 0; i < 50; i++) {
            client->poll();
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
    }
    else {
        std::cerr << "CLIENT: Failed to connect. Check firewall or server status." << std::endl;
    }
    std::cout << "--- STOPPING ---" << std::endl;
    serverRunning = false;

    if (sThread.joinable()) {
        sThread.join();
    }

    client.reset();
    server.reset();

    std::cout << "--- TEST FINISHED ---" << std::endl;
    return 0;
}