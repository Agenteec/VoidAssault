
// merged.txt

// reader.py
import os

def merge_files(root_dir, output_file, extensions=None):
    """
    Рекурсивно считывает все файлы из root_dir и записывает в один файл.
    Перед каждым файлом вставляется комментарий с его путём.
    extensions — список расширений, если нужно фильтровать (например ['.h', '.cpp'])
    Если extensions=None — берутся все файлы.
    """
    with open(output_file, "w", encoding="utf-8") as out:
        for folder, _, files in os.walk(root_dir):
            for file in files:
                file_path = os.path.join(folder, file)
                rel_path = os.path.relpath(file_path, root_dir)
                
                # Фильтр по расширениям, если нужно
                if extensions is not None:
                    _, ext = os.path.splitext(file)
                    if ext.lower() not in extensions:
                        continue

                out.write(f"\n// {rel_path}\n")

                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        out.write(f.read())
                except Exception as e:
                    out.write(f"[Ошибка при чтении файла: {e}]\n")


if __name__ == "__main__":
    merge_files(
        root_dir=".", 
        output_file="merged.txt",
        extensions=None 
    )

// client\CMakeLists.txt
﻿
file(GLOB CLIENT_SOURCES 
    "*.cpp" 
    "Scenes/*.cpp"
    "raygui_impl.cpp" 
)

if(WIN32 OR CMAKE_SYSTEM_NAME STREQUAL "Linux" OR LINUX)
    add_executable(GameClient ${CLIENT_SOURCES})

    if(WIN32)
        target_compile_definitions(GameClient PRIVATE NOGDI)
        if(MSVC)
            set_target_properties(GameClient PROPERTIES LINK_FLAGS "/SUBSYSTEM:CONSOLE")
        endif()
    endif()
    target_include_directories(GameClient PRIVATE ${ENET_EXTERNAL_INCLUDE_DIR})
    target_include_directories(GameClient PRIVATE ${RAYGUI_EXTERNAL_INCLUDE_DIR})

    target_include_directories(GameClient PUBLIC "${CMAKE_SOURCE_DIR}/external")
    target_link_libraries(GameClient PRIVATE 
    raylib
    GameEngine 
    GameCommon
)

    #file(COPY ${CMAKE_SOURCE_DIR}/assets DESTINATION ${CMAKE_CURRENT_BINARY_DIR})

elseif(ANDROID)
    add_library(gameclient SHARED ${CLIENT_SOURCES})

    target_link_libraries(gameclient  PRIVATE android log
        raylib
    GameEngine 
    GameCommon
    enet::enet_shared
    chipmunk_static)
    target_include_directories(gameclient PRIVATE ${ENET_EXTERNAL_INCLUDE_DIR})
target_include_directories(gameclient PRIVATE ${RAYGUI_EXTERNAL_INCLUDE_DIR})

target_include_directories(gameclient PUBLIC "${CMAKE_SOURCE_DIR}/external")
endif()






// client\config.h
﻿// client/config.h
#pragma once

// Общие настройки для клиента
#if defined(_WIN32)
#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#endif
// client\GameClient.cpp
﻿#include "GameClient.h"
#include "scenes/MainMenuScene.h" 



GameClient::GameClient() {
    InitWindow(screenWidth, screenHeight, "Void Assault");
    SetTargetFPS(60);
    SetWindowState(FLAG_WINDOW_RESIZABLE);

    if (enet_initialize() != 0) {
        TraceLog(LOG_ERROR, "Failed to init ENet");
    }

    if (!network.Init()) {
        TraceLog(LOG_ERROR, "Failed to create ENet client host");
    }

    GuiSetStyle(DEFAULT, TEXT_SIZE, 20);
}

GameClient::~GameClient() {
    StopHost();
    if (currentScene) currentScene->Exit();
    network.Shutdown();
    enet_deinitialize();
    CloseWindow();
}

void GameClient::ChangeScene(std::shared_ptr<Scene> newScene) {
    nextScene = newScene;
}

void GameClient::StartHost() {
    if (!localServer) {
        localServer = std::make_unique<ServerHost>();
        if (localServer->Start(7777)) {
            TraceLog(LOG_INFO, "Local Server Started!");
        }
        else {
            TraceLog(LOG_ERROR, "Failed to start local server!");
        }
    }
}

void GameClient::StopHost() {
    if (localServer) {
        localServer->Stop();
        localServer.reset();
        TraceLog(LOG_INFO, "Local Server Stopped.");
    }
}

void GameClient::Run() {
    ChangeScene(std::make_shared<MainMenuScene>(this));

    while (!WindowShouldClose()) {
        if (nextScene) {
            if (currentScene) currentScene->Exit();
            currentScene = nextScene;
            currentScene->Enter();
            nextScene = nullptr;
        }

        float dt = GetFrameTime();

        ENetEvent event;
        while (enet_host_service(network.clientHost, &event, 0) > 0) {
            switch (event.type) {
            case ENET_EVENT_TYPE_CONNECT:
                network.isConnected = true;
                TraceLog(LOG_INFO, "Connected to server!");
                break;
            case ENET_EVENT_TYPE_DISCONNECT:
                network.isConnected = false;
                TraceLog(LOG_INFO, "Disconnected from server.");
                break;
            case ENET_EVENT_TYPE_RECEIVE:
                if (currentScene) {
                    currentScene->OnPacketReceived(event.packet->data, event.packet->dataLength);
                }
                enet_packet_destroy(event.packet);
                break;
            }
        }

        if (currentScene) {
            currentScene->Update(dt);

            BeginDrawing();
            ClearBackground(RAYWHITE);

            currentScene->Draw();
            currentScene->DrawGUI();

            EndDrawing();
        }
    }
}
// client\GameClient.h
﻿#pragma once
#include "raygui_wrapper.h"
#include "NetworkManager.h"
#include "../engine/Scenes/Scene.h"
#include "../engine/ServerHost.h"
#include <memory>

class GameClient {
public:
    int screenWidth = 1280;
    int screenHeight = 720;

    NetworkManager network;
    std::unique_ptr<ServerHost> localServer;

    std::shared_ptr<Scene> currentScene;
    std::shared_ptr<Scene> nextScene;

    GameClient();
    ~GameClient();

    void Run();
    void ChangeScene(std::shared_ptr<Scene> newScene);

    void StartHost();
    void StopHost();

    int GetWidth() const { return GetScreenWidth(); }
    int GetHeight() const { return GetScreenHeight(); }
};
// client\main_client.cpp
﻿#define RAYGUI_IMPLEMENTATION
#include "GameClient.h"

int main() {
    GameClient game;
    game.Run();
    return 0;
}
// client\NetworkManager.h
﻿#pragma once
#include <enet.h>
#include <string>
#include <iostream>
#include "../common/NetworkPackets.h"

class NetworkManager {
public:
    ENetHost* clientHost = nullptr;
    ENetPeer* serverPeer = nullptr;
    bool isConnected = false;

    bool Init() {
        if (enet_initialize() != 0) return false;
        clientHost = enet_host_create(NULL, 1, 2, 0, 0);
        return (clientHost != nullptr);
    }

    void Connect(const std::string& ip, int port) {
        ENetAddress address;
        enet_address_set_host(&address, ip.c_str());
        address.port = port;
        serverPeer = enet_host_connect(clientHost, &address, 2, 0);
    }

    void Disconnect() {
        if (serverPeer) {
            enet_peer_disconnect(serverPeer, 0);
            enet_host_flush(clientHost);
            serverPeer = nullptr;
        }
        isConnected = false;
    }

    void SendInput(const PlayerInputPacket& input) {
        if (!isConnected || !serverPeer) return;
        ENetPacket* packet = enet_packet_create(&input, sizeof(PlayerInputPacket), ENET_PACKET_FLAG_UNSEQUENCED);
        enet_peer_send(serverPeer, 0, packet);
    }

    void Shutdown() {
        if (clientHost) enet_host_destroy(clientHost);
        enet_deinitialize();
    }
};
// client\ParticleSystem.h
﻿#pragma once
#include "raylib.h"
#include <vector>
#include <algorithm>

struct Particle {
    Vector2 position;
    Vector2 velocity;
    float life;      // 1.0 -> 0.0
    float decayRate; // Скорость исчезновения
    float size;
    Color color;
};

class ParticleSystem {
    std::vector<Particle> particles;

public:
    void Spawn(Vector2 pos, Vector2 vel, Color col, float size, float lifeTime) {
        Particle p;
        p.position = pos;
        p.velocity = vel;
        p.color = col;
        p.size = size;
        p.life = 1.0f;
        p.decayRate = 1.0f / lifeTime;
        particles.push_back(p);
    }

    void SpawnExplosion(Vector2 pos, int count, Color col) {
        for (int i = 0; i < count; i++) {
            float angle = (float)GetRandomValue(0, 360) * DEG2RAD;
            float speed = (float)GetRandomValue(50, 200) / 10.0f;
            Vector2 vel = { cosf(angle) * speed, sinf(angle) * speed };
            Spawn(pos, vel, col, (float)GetRandomValue(3, 8), 0.5f);
        }
    }

    void Update(float dt) {
        for (auto& p : particles) {
            p.position.x += p.velocity.x * dt * 60.0f;
            p.position.y += p.velocity.y * dt * 60.0f;
            p.life -= p.decayRate * dt;
            p.size *= 0.95f;
        }

        particles.erase(
            std::remove_if(particles.begin(), particles.end(),
                [](const Particle& p) { return p.life <= 0; }),
            particles.end());
    }

    void Draw() {
        for (const auto& p : particles) {
            Color c = p.color;
            c.a = (unsigned char)(p.life * 255);
            DrawCircleV(p.position, p.size, c);
        }
    }
};
// client\raygui_wrapper.h
﻿// raygui_wrapper.h
#pragma once

#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "raylib.h"
#include "raygui.h"
// client\ResourceManager.h
﻿#pragma once
#include "raylib.h"
#include <string>

class ResourceManager {
public:
    Font mainFont;

    static ResourceManager& Get() {
        static ResourceManager instance;
        return instance;
    }

    void Load() {
        // Загружаем шрифт. Если файла нет, Raylib загрузит дефолтный, но с фильтрацией
        // В реальном проекте положи файл .ttf в папку assets
        // mainFont = LoadFontEx("assets/font.ttf", 64, 0, 0);

        // Пока используем дефолтный, но ставим фильтр для гладкости
        mainFont = GetFontDefault();
        SetTextureFilter(mainFont.texture, TEXTURE_FILTER_BILINEAR);
    }

    void Unload() {
        // UnloadFont(mainFont);
    }

    static void DrawTextCentered(const char* text, int cx, int cy, int fontSize, Color color) {
        int width = MeasureText(text, fontSize);
        DrawText(text, cx - width / 2, cy - fontSize / 2, fontSize, color);
    }
};
// client\Theme.h
#pragma once
#include "raylib.h"

namespace Theme {
    static const Color BG_COLOR = { 205, 205, 205, 255 };
    static const Color GRID_COLOR = { 170, 170, 170, 255 };
    static const Color BORDER_COLOR = { 85, 85, 85, 255 };

    static const Color COLOR_BLUE = { 0, 178, 225, 255 };
    static const Color COLOR_RED = { 241, 78, 84, 255 };
    static const Color COLOR_BARREL = { 153, 153, 153, 255 };

    static const float OUTLINE_THICKNESS = 3.0f;
    static const float BARREL_WIDTH_RATIO = 0.45f;
}
// client\scenes\GameplayScene.cpp
﻿#include "GameplayScene.h"
#include "MainMenuScene.h" // Теперь это безопасно

GameplayScene::GameplayScene(GameClient* g) : Scene(g) {}

void GameplayScene::Enter() {
    camera.zoom = 1.0f;
    camera.offset = { (float)game->GetWidth() / 2, (float)game->GetHeight() / 2 };
}

void GameplayScene::Exit() {
    game->network.Disconnect();
    game->StopHost();
    worldEntities.clear();
}

void GameplayScene::OnPacketReceived(const uint8_t* data, size_t size) {
    PacketHeader* header = (PacketHeader*)data;

    if (header->type == PacketType::server_INIT) {
        InitPacket* init = (InitPacket*)data;
        myPlayerId = init->yourPlayerId;
    }
    else if (header->type == PacketType::server_SNAPSHOT) {
        WorldSnapshotPacket* snap = (WorldSnapshotPacket*)data;
        EntityState* states = (EntityState*)(data + sizeof(WorldSnapshotPacket));

        std::vector<uint32_t> receivedIds;
        for (uint32_t i = 0; i < snap->entityCount; i++) {
            receivedIds.push_back(states[i].id);
            worldEntities[states[i].id].PushState(states[i]);
        }
        for (auto it = worldEntities.begin(); it != worldEntities.end();) {
            bool found = false;
            for (uint32_t id : receivedIds) if (id == it->first) found = true;
            if (!found) it = worldEntities.erase(it);
            else ++it;
        }
    }
}

void GameplayScene::Update(float dt) {
    PlayerInputPacket pkt;
    pkt.type = PacketType::client_INPUT;
    pkt.movement = { 0, 0 };
    if (IsKeyDown(KEY_W)) pkt.movement.y -= 1.0f;
    if (IsKeyDown(KEY_S)) pkt.movement.y += 1.0f;
    if (IsKeyDown(KEY_A)) pkt.movement.x -= 1.0f;
    if (IsKeyDown(KEY_D)) pkt.movement.x += 1.0f;

    pkt.aimTarget = GetScreenToWorld2D(GetMousePosition(), camera);
    pkt.isShooting = IsMouseButtonDown(MOUSE_LEFT_BUTTON);

    game->network.SendInput(pkt);

    for (auto& [id, ent] : worldEntities) {
        ent.UpdateInterpolation();
    }

    if (worldEntities.count(myPlayerId)) {
        Vector2 target = worldEntities[myPlayerId].renderPos;
        camera.target = Vector2Lerp(camera.target, target, 0.1f);
    }
}

void GameplayScene::Draw() {
    BeginMode2D(camera);
    DrawGrid(100, 50);
    DrawRectangleLines(0, 0, 2000, 2000, GRAY);

    for (auto& [id, ent] : worldEntities) {
        EntityState& st = ent.current;

        if (st.type == EntityType::PLAYER) {
            DrawCircleV(ent.renderPos, st.radius, st.color);
            Vector2 barrelEnd = {
                ent.renderPos.x + cosf(ent.renderRot * DEG2RAD) * 40,
                ent.renderPos.y + sinf(ent.renderRot * DEG2RAD) * 40
            };
            DrawLineEx(ent.renderPos, barrelEnd, 15, DARKGRAY);

            float hpPct = st.health / st.maxHealth;
            DrawRectangle((int)ent.renderPos.x - 20, (int)ent.renderPos.y - 40, 40, 5, RED);
            DrawRectangle((int)ent.renderPos.x - 20, (int)ent.renderPos.y - 40, (int)(40 * hpPct), 5, GREEN);
        }
        else if (st.type == EntityType::BULLET) {
            DrawCircleV(ent.renderPos, st.radius, RED);
        }
    }
    EndMode2D();
}

void GameplayScene::DrawGUI() {
    DrawFPS(10, 10);
    if (!game->network.isConnected) {
        DrawText("Connecting to server...", game->GetWidth() / 2 - 100, 20, 20, RED);
    }

    // Здесь конфликтов больше быть не должно, так как raygui_wrapper подчистил макросы
    if (GuiButton(Rectangle{ (float)game->GetWidth() - 100, 10, 90, 30 }, "DISCONNECT")) {
        game->ChangeScene(std::make_shared<MainMenuScene>(game));
    }
}
// client\scenes\GameplayScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"
#include "../../client/GameClient.h"
#include "../../common/NetworkPackets.h"
#include "../ParticleSystem.h"
#include "raymath.h"
#include <map>
#include <vector>

struct InterpolatedEntity {
    EntityState current;
    EntityState previous;
    float lastUpdateTime;
    Vector2 renderPos;
    float renderRot;

    InterpolatedEntity() : lastUpdateTime(0), renderRot(0) {}

    void PushState(const EntityState& newState) {
        previous = current;
        current = newState;
        lastUpdateTime = (float)GetTime();
        if (previous.id == 0) previous = current;
    }

    void UpdateInterpolation() {
        double serverTickRate = 0.05;
        double t = (GetTime() - lastUpdateTime) / serverTickRate;
        if (t > 1.0) t = 1.0;
        if (t < 0.0) t = 0.0;

        renderPos = Vector2Lerp(previous.position, current.position, (float)t);
        renderRot = Lerp(previous.rotation, current.rotation, (float)t);
    }
};

class GameplayScene : public Scene {
    Camera2D camera = { 0 };
    std::map<uint32_t, InterpolatedEntity> worldEntities;
    uint32_t myPlayerId = 0;

public:
    GameplayScene(GameClient* g);
    virtual ~GameplayScene() = default;

    void Enter() override;
    void Exit() override;
    void OnPacketReceived(const uint8_t* data, size_t size) override;
    void Update(float dt) override;
    void Draw() override;
    void DrawGUI() override;
};
// client\scenes\MainMenuScene.cpp
﻿#include "../raygui_wrapper.h"
#include "MainMenuScene.h"
#include "GameplayScene.h"
#include "../../client/ResourceManager.h"
#include "../../client/Theme.h"

MainMenuScene::MainMenuScene(GameClient* g) : Scene(g) {}

void MainMenuScene::Draw() {
    ClearBackground(Theme::BG_COLOR);
    float time = (float)GetTime() * 20.0f;
    for (int x = 0; x < game->GetWidth(); x += 50)
        DrawLine(x + (int)time % 50, 0, x + (int)time % 50, game->GetHeight(), Fade(Theme::GRID_COLOR, 0.5f));

    const char* title = "VOID ASSAULT";
    int fontSize = 80;
    int cx = game->GetWidth() / 2;
    int cy = 150;

    ResourceManager::DrawTextCentered(title, cx + 4, cy + 4, fontSize, Fade(BLACK, 0.3f));
    ResourceManager::DrawTextCentered(title, cx, cy, fontSize, Theme::COLOR_BLUE);

    DrawText("WASD to Move, LMB to Shoot", cx - 100, game->GetHeight() - 50, 20, DARKGRAY);
}

void MainMenuScene::DrawGUI() {
    float cx = game->GetWidth() / 2.0f - 100;
    float cy = game->GetHeight() / 2.0f;

    if (GuiTextBox(Rectangle{ cx, cy, 200, 30 }, ipBuffer, 64, ipEditMode)) {
        ipEditMode = !ipEditMode;
    }

    if (GuiButton(Rectangle{ cx, cy + 40, 200, 30 }, "CONNECT")) {
        game->network.Connect(ipBuffer, 7777);
        game->ChangeScene(std::make_shared<GameplayScene>(game));
    }

    if (GuiButton(Rectangle{ cx, cy + 80, 200, 30 }, "HOST LAN GAME")) {
        game->StartHost();
        game->network.Connect("127.0.0.1", 7777);
        game->ChangeScene(std::make_shared<GameplayScene>(game));
    }

    if (GuiButton(Rectangle{ cx, cy + 130, 200, 30 }, "QUIT")) {
        CloseWindow();
    }
}
// client\scenes\MainMenuScene.h
﻿#pragma once
#include "../../engine/Scenes/Scene.h"
#include "../../client/GameClient.h"

class MainMenuScene : public Scene {
    char ipBuffer[64] = "127.0.0.1";
    bool ipEditMode = false;

public:
    MainMenuScene(GameClient* g);
    virtual ~MainMenuScene() = default;

    void Enter() override {}
    void Exit() override {}
    void Update(float dt) override {}
    void Draw() override;
    void DrawGUI() override;
};
// common\CMakeLists.txt
﻿add_library(GameCommon SHARED
    NetworkPackets.h Common.cpp
)

target_link_libraries(GameCommon PUBLIC enet::enet_shared raylib)
target_include_directories(GameCommon PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameCommon PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
// common\Common.cpp

// common\NetworkPackets.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif
#include <cstdint>
#include "raylib.h"

enum class PacketType : uint8_t {
    client_CONNECT,
    client_INPUT,
    server_INIT,
    server_SNAPSHOT,
    server_EVENT
};

struct PacketHeader {
    PacketType type;
};

struct PlayerInputPacket : PacketHeader {
    Vector2 movement;
    Vector2 aimTarget;
    bool isShooting;
};

enum class EntityType : uint8_t { PLAYER, BULLET, ENEMY };

struct EntityState {
    uint32_t id;
    Vector2 position;
    float rotation;
    float health;
    float maxHealth;
    EntityType type;
    float radius;
    Color color;
};

struct WorldSnapshotPacket : PacketHeader {
    uint32_t entityCount;
};


struct InitPacket : PacketHeader {
    uint32_t yourPlayerId;
};


enum class GameEvent : uint8_t {
    BULLET_HIT,
    PLAYER_DEATH
};

struct EventPacket : PacketHeader {
    GameEvent eventId;
    Vector2 position;
};
// engine\CMakeLists.txt
﻿#Engine module CMakeLists.txt
add_library(GameEngine SHARED
    
    ECS/GameObject.h
    ECS/Player.h
    ECS/Bullet.h
    Scenes/GameScene.h
    ServerHost.h
 "ServerHost.h"
 ServerHost.cpp
)

target_compile_definitions(GameEngine PRIVATE PHYSAC_NO_THREADS)
target_include_directories(GameEngine PUBLIC ${CHIPMUNK2D_EXTERNAL_INCLUDE_DIR})
target_include_directories(GameEngine PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})

target_link_libraries(GameEngine PUBLIC chipmunk_static GameCommon enet::enet_shared raylib)
target_include_directories(GameEngine PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

if(ANDROID)
    target_link_libraries(GameEngine PRIVATE log)
endif()
// engine\PhysicsUtils.h
﻿#pragma once
#include "raylib_compatibility.h"
#include "chipmunk/chipmunk.h"


// Конвертация Raylib Vector2 -> Chipmunk cpVect
inline cpVect ToCp(Vector2 v) {
    return cpv(v.x, v.y);
}

// Конвертация Chipmunk cpVect -> Raylib Vector2
inline Vector2 ToRay(cpVect v) {
    return Vector2{ (float)v.x, (float)v.y };
}
// engine\raylib_compatibility.h
﻿// raylib_compatibility.h
#pragma once

#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include "raylib.h"
// engine\ServerHost.cpp
﻿#define _CRT_SECURE_NO_WARNINGS
#include "ServerHost.h"
#include <iostream>

ServerHost::ServerHost() : running(false) {}

ServerHost::~ServerHost() {
    Stop();
}

bool ServerHost::Start(int port) {
    if (running) return false;

    ENetAddress address;
    address.host = ENET_HOST_ANY;
    address.port = port;

    server = enet_host_create(&address, 32, 2, 0, 0);
    if (!server) {
        std::cerr << "An error occurred while trying to create an ENet server host.\n";
        return false;
    }

    running = true;
    // Запускаем цикл в отдельном потоке
    serverThread = std::thread(&ServerHost::ServerLoop, this);
    return true;
}

void ServerHost::Stop() {
    running = false;
    if (serverThread.joinable()) {
        serverThread.join();
    }
    if (server) {
        enet_host_destroy(server);
        server = nullptr;
    }
}

void ServerHost::ServerLoop() {
    std::cout << "Server started loop.\n";
    const double dt = 1.0 / 60.0;
    double accumulator = 0.0;
    double lastTime = GetTime();

    while (running) {
        double currentTime = GetTime();
        double frameTime = currentTime - lastTime;
        lastTime = currentTime;
        accumulator += frameTime;

        ENetEvent event;
        while (enet_host_service(server, &event, 0) > 0) {
            switch (event.type) {
            case ENET_EVENT_TYPE_CONNECT: {
                std::cout << "A new client connected from...\n";// << event.peer->address.host.u.Word << ":" << event.peer->address.port << ".\n";

                auto player = gameScene.CreatePlayer();

                event.peer->data = (void*)(uintptr_t)player->id;

                InitPacket initPkt;
                initPkt.type = PacketType::server_INIT;
                initPkt.yourPlayerId = player->id;

                ENetPacket* packet = enet_packet_create(&initPkt, sizeof(InitPacket), ENET_PACKET_FLAG_RELIABLE);
                enet_peer_send(event.peer, 0, packet);
                break;
            }
            case ENET_EVENT_TYPE_RECEIVE: {
                PacketHeader* header = (PacketHeader*)event.packet->data;
                if (header->type == PacketType::client_INPUT) {
                    PlayerInputPacket* input = (PlayerInputPacket*)event.packet->data;
                    uint32_t playerId = (uint32_t)(uintptr_t)event.peer->data;

                    if (gameScene.objects.count(playerId)) {
                        auto p = std::dynamic_pointer_cast<Player>(gameScene.objects[playerId]);
                        if (p) {
                            p->ApplyInput(input->movement);
                            p->aimTarget = input->aimTarget;
                            p->wantsToShoot = input->isShooting;
                        }
                    }
                }
                enet_packet_destroy(event.packet);
                break;
            }
            case ENET_EVENT_TYPE_DISCONNECT:
                uint32_t playerId = (uint32_t)(uintptr_t)event.peer->data;
                gameScene.objects.erase(playerId);
                std::cout << "Client disconnected.\n";
            }
        }

        // Физический апдейт
        while (accumulator >= dt) {
            gameScene.Update((float)dt);
            accumulator -= dt;
        }

        // Рассылка снапшота (раз в 2 тика, например, или каждый тик)
        static double snapshotTimer = 0;
        snapshotTimer += frameTime;
        if (snapshotTimer > 0.05) { // 20 раз в секунду
            snapshotTimer = 0;
            auto data = gameScene.SerializeSnapshot();

            ENetPacket* packet = enet_packet_create(data.data(), data.size(), ENET_PACKET_FLAG_UNSEQUENCED);
            enet_host_broadcast(server, 1, packet);
        }

        // Небольшой sleep, чтобы не грузить CPU на 100% в пустом цикле
        WaitTime(0.001);
    }
}
// engine\ServerHost.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif

#include <enet.h>

#include <thread>
#include <atomic>
#include "Scenes/GameScene.h"

class ServerHost {
    ENetHost* server = nullptr;
    GameScene gameScene;
    std::atomic<bool> running;
    std::thread serverThread;

public:
    ServerHost();
    ~ServerHost();

    bool Start(int port);
    void Stop();

    void ServerLoop();
};
// engine\ECS\Bullet.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"

class Bullet : public GameObject {
public:
    uint32_t ownerId;
    float lifeTime = 2.0f;

    Bullet(uint32_t id, Vector2 pos, Vector2 dir, uint32_t owner, cpSpace* space)
        : GameObject(id, EntityType::BULLET), ownerId(owner)
    {
        spaceRef = space;
        color = BLACK;
        float moveSpeed = 600.0f;

        cpFloat radius = 5.0;
        cpFloat mass = 1.0;
        // Пуля - кинематический или легкий динамический объект
        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);

        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(pos));

        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetElasticity(shape, 0.8);
        cpShapeSetCollisionType(shape, COLLISION_BULLET);
        cpShapeSetUserData(shape, (void*)this);

        // Задаем скорость
        Vector2 normDir = Vector2Normalize(dir);
        cpBodySetVelocity(body, cpv(normDir.x * moveSpeed, normDir.y * moveSpeed));
    }

    void Update(float dt) override {
        lifeTime -= dt;
        if (lifeTime <= 0) destroyFlag = true;
    }
};
// engine\ECS\GameObject.h
﻿#pragma once
#if defined(_WIN32)
#include "fix_win32_compatibility.h"
#endif
#include "raylib.h"
#include "chipmunk/chipmunk.h"
#include "../../common/NetworkPackets.h"

// Определяем типы коллизий для фильтрации (понадобится в будущем)
enum CollisionType {
    COLLISION_PLAYER = 1,
    COLLISION_BULLET = 2,
    COLLISION_WALL = 3
};

class GameObject {
public:
    uint32_t id;
    EntityType type;

    // Ссылки на физические объекты
    cpBody* body = nullptr;
    cpShape* shape = nullptr;
    cpSpace* spaceRef = nullptr; // Ссылка на мир для очистки

    bool destroyFlag = false;
    Color color = RED;
    float rotation = 0.0f;
    float health = 100.0f;
    float maxHealth = 100.0f;

    GameObject(uint32_t _id, EntityType _type) : id(_id), type(_type) {}

    virtual ~GameObject() {
        if (spaceRef) {
            if (shape) {
                cpSpaceRemoveShape(spaceRef, shape);
                cpShapeFree(shape);
            }
            if (body) {
                cpSpaceRemoveBody(spaceRef, body);
                cpBodyFree(body);
            }
        }
    }

    virtual void Update(float dt) = 0;
};
// engine\ECS\Player.h
﻿#pragma once
#include "GameObject.h"
#include "../PhysicsUtils.h"
#include "raymath.h"

class Player : public GameObject {
public:
    float speed = 200.0f; // Сила/Скорость движения
    float shootCooldown = 0.0f;
    const float FIRE_RATE = 0.2f;

    bool wantsToShoot = false;
    Vector2 aimTarget = { 0,0 };
    bool spawnBulletSignal = false;
    Vector2 bulletDir = { 0,0 };

    Player(uint32_t id, Vector2 startPos, cpSpace* space) : GameObject(id, EntityType::PLAYER) {
        spaceRef = space;
        color = BLUE;

        // 1. Создаем тело (масса 10, инерция для круга)
        cpFloat radius = 20.0;
        cpFloat mass = 10.0;
        cpFloat moment = cpMomentForCircle(mass, 0, radius, cpvzero);

        body = cpSpaceAddBody(space, cpBodyNew(mass, moment));
        cpBodySetPosition(body, ToCp(startPos));

        // Отключаем вращение от коллизий (бесконечная инерция)
        cpBodySetMoment(body, INFINITY);

        // 2. Создаем форму (коллизию)
        shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));
        cpShapeSetFriction(shape, 0.7);
        cpShapeSetElasticity(shape, 0.1); // Упругость
        cpShapeSetCollisionType(shape, COLLISION_PLAYER);

        // Pointer на самого себя для логики коллизий
        cpShapeSetUserData(shape, (void*)this);
    }

    void Update(float dt) override {
        if (shootCooldown > 0) shootCooldown -= dt;

        // Позиция для стрельбы и камеры
        Vector2 pos = ToRay(cpBodyGetPosition(body));

        if (wantsToShoot && shootCooldown <= 0) {
            shootCooldown = FIRE_RATE;
            spawnBulletSignal = true;
            bulletDir = Vector2Subtract(aimTarget, pos);
        }

        // Вычисляем угол поворота (визуально)
        Vector2 diff = Vector2Subtract(aimTarget, pos);
        rotation = atan2(diff.y, diff.x) * RAD2DEG;

        // Передаем угол в физику (хоть она и не вращается от ударов)
        cpBodySetAngle(body, atan2(diff.y, diff.x));

        // Линейное затухание (трение о воздух/землю)
        // В Chipmunk это делается через damping space, но можно и вручную:
        cpVect vel = cpBodyGetVelocity(body);
        cpBodySetVelocity(body, cpvmult(vel, 0.90f)); // Торможение
    }

    void ApplyInput(Vector2 move) {
        if (body) {
            // Прямая установка скорости для четкого управления
            // (или можно использовать forces для "ледяного" управления)
            cpBodySetVelocity(body, cpv(move.x * speed, move.y * speed));
        }
    }
};
// engine\Scenes\GameScene.h
﻿#pragma once
#include <vector>
#include <memory>
#include <map>
#include <algorithm>
#include "../ECS/Player.h"
#include "../ECS/Bullet.h"
#include "../PhysicsUtils.h"

class GameScene {
public:
    cpSpace* space;
    std::map<uint32_t, std::shared_ptr<GameObject>> objects;
    uint32_t nextId = 1;
    float width = 2000;
    float height = 2000;

    GameScene() {
        space = cpSpaceNew();
        // Гравитации нет
        cpSpaceSetGravity(space, cpv(0, 0));

        CreateMapBoundaries();
    }

    ~GameScene() {
        // Сначала очищаем объекты (их деструкторы удалят тела из space)
        objects.clear();
        // Потом удаляем space
        cpSpaceFree(space);
    }

    void CreateMapBoundaries() {
        // Статическое тело для стен (не добавляем его в space, только shape)
        cpBody* staticBody = cpSpaceGetStaticBody(space);

        float w = width;
        float h = height;
        float thick = 20.0f;

        // 4 Стены (Segment Shapes)
        auto addWall = [&](Vector2 a, Vector2 b) {
            cpShape* wall = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, ToCp(a), ToCp(b), thick));
            cpShapeSetElasticity(wall, 0.5f);
            cpShapeSetFriction(wall, 1.0f);
            cpShapeSetCollisionType(wall, COLLISION_WALL);
            };

        addWall({ 0,0 }, { w, 0 });      // Top
        addWall({ 0,h }, { w, h });      // Bottom
        addWall({ 0,0 }, { 0, h });      // Left
        addWall({ w,0 }, { w, h });      // Right
    }

    std::shared_ptr<Player> CreatePlayer() {
        Vector2 startPos = { width / 2, height / 2 };
        auto p = std::make_shared<Player>(nextId++, startPos, space);
        objects[p->id] = p;
        return p;
    }

    void Update(float dt) {
        // Шаг физики (фиксированный шаг для стабильности)
        cpSpaceStep(space, dt);

        // Логика объектов и спавн пуль
        std::vector<std::shared_ptr<Bullet>> newBullets;

        for (auto it = objects.begin(); it != objects.end();) {
            auto& obj = it->second;
            obj->Update(dt);

            if (obj->type == EntityType::PLAYER) {
                auto p = std::dynamic_pointer_cast<Player>(obj);
                if (p && p->spawnBulletSignal) {
                    p->spawnBulletSignal = false;
                    Vector2 spawnPos = ToRay(cpBodyGetPosition(p->body));
                    auto b = std::make_shared<Bullet>(nextId++, spawnPos, p->bulletDir, p->id, space);
                    newBullets.push_back(b);
                }
            }

            if (obj->destroyFlag) {
                it = objects.erase(it); // Деструктор GameObject очистит Chipmunk ресурсы
            }
            else {
                ++it;
            }
        }

        for (auto& b : newBullets) objects[b->id] = b;

        // Обработка урона (Manual Query)
        // Chipmunk имеет систему коллбеков, но для совместимости с вашей логикой
        // сделаем простую проверку расстояний, но физика отталкивания будет от Chipmunk.
        HandleDamageManual();
    }

    void HandleDamageManual() {
        for (auto& [bid, bObj] : objects) {
            if (bObj->type != EntityType::BULLET) continue;
            auto bullet = std::dynamic_pointer_cast<Bullet>(bObj);

            Vector2 bPos = ToRay(cpBodyGetPosition(bullet->body));

            for (auto& [pid, pObj] : objects) {
                if (pObj->type != EntityType::PLAYER) continue;
                if (pid == bullet->ownerId) continue;

                Vector2 pPos = ToRay(cpBodyGetPosition(pObj->body));

                // Простая проверка радиуса (20 танк + 5 пуля)
                if (Vector2Distance(bPos, pPos) < 25.0f) {
                    pObj->health -= 10;
                    bullet->destroyFlag = true;

                    if (pObj->health <= 0) {
                        // Respawn
                        pObj->health = 100;
                        cpVect randPos = cpv(GetRandomValue(100, (int)width - 100), GetRandomValue(100, (int)height - 100));
                        cpBodySetPosition(pObj->body, randPos);
                        cpBodySetVelocity(pObj->body, cpvzero);
                    }
                }
            }
        }
    }

    std::vector<uint8_t> SerializeSnapshot() {
        size_t size = sizeof(WorldSnapshotPacket) + (objects.size() * sizeof(EntityState));
        std::vector<uint8_t> buffer(size);

        WorldSnapshotPacket* header = (WorldSnapshotPacket*)buffer.data();
        header->type = PacketType::server_SNAPSHOT;
        header->entityCount = (uint32_t)objects.size();

        EntityState* states = (EntityState*)(buffer.data() + sizeof(WorldSnapshotPacket));
        int i = 0;
        for (auto& [id, obj] : objects) {
            states[i].id = obj->id;

            // Берем координаты из Chipmunk
            if (obj->body) {
                states[i].position = ToRay(cpBodyGetPosition(obj->body));
                states[i].rotation = (float)cpBodyGetAngle(obj->body) * RAD2DEG;
            }

            states[i].health = obj->health;
            states[i].maxHealth = obj->maxHealth;
            states[i].type = obj->type;
            states[i].radius = (obj->type == EntityType::BULLET) ? 5.0f : 20.0f;
            states[i].color = obj->color;
            i++;
        }
        return buffer;
    }
};
// engine\Scenes\Scene.h
﻿#pragma once

#include "raylib.h"
#include <vector>
#include <cstdint>

class GameClient;

class Scene {
protected:
    GameClient* game;

public:
    Scene(GameClient* _game) : game(_game) {}
    virtual ~Scene() = default;

    virtual void Enter() = 0;
    virtual void Update(float dt) = 0;
    virtual void Draw() = 0;
    virtual void DrawGUI() = 0;
    virtual void Exit() = 0;
    virtual void OnPacketReceived(const uint8_t* data, size_t size) {};
};
// server\CMakeLists.txt
﻿#server module CMakeLists.txt
add_executable(GameServer
    main_server.cpp
)
target_include_directories(GameServer PUBLIC ${FIX_EXTERNAL_INCLUDE_DIR})
target_link_libraries(GameServer PRIVATE GameEngine GameCommon enet::enet_shared)

// server\main_server.cpp
﻿#include "../engine/ServerHost.h"
#include <iostream>
#include <string>

int main() {
    if (enet_initialize() != 0) {
        std::cerr << "An error occurred while initializing ENet.\n";
        return 1;
    }

    InitWindow(100, 100, "ServerHeadless");
    SetWindowState(FLAG_WINDOW_HIDDEN);

    ServerHost server;
    if (server.Start(7777)) {
        std::cout << "Dedicated Server started on port 7777. Type 'quit' to stop.\n";

        std::string cmd;
        while (std::cin >> cmd) {
            if (cmd == "quit") break;
        }

        server.Stop();
    }

    CloseWindow();
    enet_deinitialize();
    return 0;
}